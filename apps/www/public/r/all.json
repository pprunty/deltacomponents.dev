{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "all",
  "type": "registry:ui",
  "description": "All UI components from Delta UI",
  "dependencies": [
    "@elevenlabs/elevenlabs-js",
    "@elevenlabs/react",
    "@radix-ui/react-slider",
    "@react-three/drei",
    "@react-three/fiber",
    "@types/three",
    "class-variance-authority",
    "motion",
    "streamdown",
    "three",
    "use-stick-to-bottom"
  ],
  "registryDependencies": [
    "avatar",
    "badge",
    "button",
    "card",
    "command",
    "https://deltacomponents.dev/r/audio-player.json",
    "https://deltacomponents.dev/r/live-waveform.json",
    "https://deltacomponents.dev/r/orb.json",
    "popover",
    "separator",
    "textarea",
    "x-scrollable"
  ],
  "files": [
    {
      "path": "components/ui/orb.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport { useEffect, useMemo, useRef } from \"react\"\nimport { useTexture } from \"@react-three/drei\"\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\"\nimport * as THREE from \"three\"\n\nexport type AgentState = null | \"thinking\" | \"listening\" | \"talking\"\n\ntype OrbProps = {\n  colors?: [string, string]\n  colorsRef?: React.RefObject<[string, string]>\n  resizeDebounce?: number\n  seed?: number\n  agentState?: AgentState\n  volumeMode?: \"auto\" | \"manual\"\n  manualInput?: number\n  manualOutput?: number\n  inputVolumeRef?: React.RefObject<number>\n  outputVolumeRef?: React.RefObject<number>\n  getInputVolume?: () => number\n  getOutputVolume?: () => number\n  className?: string\n}\n\nexport function Orb({\n  colors = [\"#CADCFC\", \"#A0B9D1\"],\n  colorsRef,\n  resizeDebounce = 100,\n  seed,\n  agentState = null,\n  volumeMode = \"auto\",\n  manualInput,\n  manualOutput,\n  inputVolumeRef,\n  outputVolumeRef,\n  getInputVolume,\n  getOutputVolume,\n  className,\n}: OrbProps) {\n  return (\n    <div className={className ?? \"relative h-full w-full\"}>\n      <Canvas\n        resize={{ debounce: resizeDebounce }}\n        gl={{\n          alpha: true,\n          antialias: true,\n          premultipliedAlpha: true,\n        }}\n      >\n        <Scene\n          colors={colors}\n          colorsRef={colorsRef}\n          seed={seed}\n          agentState={agentState}\n          volumeMode={volumeMode}\n          manualInput={manualInput}\n          manualOutput={manualOutput}\n          inputVolumeRef={inputVolumeRef}\n          outputVolumeRef={outputVolumeRef}\n          getInputVolume={getInputVolume}\n          getOutputVolume={getOutputVolume}\n        />\n      </Canvas>\n    </div>\n  )\n}\n\nfunction Scene({\n  colors,\n  colorsRef,\n  seed,\n  agentState,\n  volumeMode,\n  manualInput,\n  manualOutput,\n  inputVolumeRef,\n  outputVolumeRef,\n  getInputVolume,\n  getOutputVolume,\n}: {\n  colors: [string, string]\n  colorsRef?: React.RefObject<[string, string]>\n  seed?: number\n  agentState: AgentState\n  volumeMode: \"auto\" | \"manual\"\n  manualInput?: number\n  manualOutput?: number\n  inputVolumeRef?: React.RefObject<number>\n  outputVolumeRef?: React.RefObject<number>\n  getInputVolume?: () => number\n  getOutputVolume?: () => number\n}) {\n  const { gl } = useThree()\n  const circleRef =\n    useRef<THREE.Mesh<THREE.CircleGeometry, THREE.ShaderMaterial>>(null)\n  const initialColorsRef = useRef<[string, string]>(colors)\n  const targetColor1Ref = useRef(new THREE.Color(colors[0]))\n  const targetColor2Ref = useRef(new THREE.Color(colors[1]))\n  const animSpeedRef = useRef(0.1)\n  const perlinNoiseTexture = useTexture(\n    \"https://storage.googleapis.com/eleven-public-cdn/images/perlin-noise.png\"\n  )\n\n  const agentRef = useRef<AgentState>(agentState)\n  const modeRef = useRef<\"auto\" | \"manual\">(volumeMode)\n  const manualInRef = useRef<number>(manualInput ?? 0)\n  const manualOutRef = useRef<number>(manualOutput ?? 0)\n  const curInRef = useRef(0)\n  const curOutRef = useRef(0)\n\n  useEffect(() => {\n    agentRef.current = agentState\n  }, [agentState])\n\n  useEffect(() => {\n    modeRef.current = volumeMode\n  }, [volumeMode])\n\n  useEffect(() => {\n    manualInRef.current = clamp01(\n      manualInput ?? inputVolumeRef?.current ?? getInputVolume?.() ?? 0\n    )\n  }, [manualInput, inputVolumeRef, getInputVolume])\n\n  useEffect(() => {\n    manualOutRef.current = clamp01(\n      manualOutput ?? outputVolumeRef?.current ?? getOutputVolume?.() ?? 0\n    )\n  }, [manualOutput, outputVolumeRef, getOutputVolume])\n\n  const random = useMemo(\n    () => splitmix32(seed ?? Math.floor(Math.random() * 2 ** 32)),\n    [seed]\n  )\n  const offsets = useMemo(\n    () =>\n      new Float32Array(Array.from({ length: 7 }, () => random() * Math.PI * 2)),\n    [random]\n  )\n\n  useEffect(() => {\n    targetColor1Ref.current = new THREE.Color(colors[0])\n    targetColor2Ref.current = new THREE.Color(colors[1])\n  }, [colors])\n\n  useEffect(() => {\n    const apply = () => {\n      if (!circleRef.current) return\n      const isDark = document.documentElement.classList.contains(\"dark\")\n      circleRef.current.material.uniforms.uInverted.value = isDark ? 1 : 0\n    }\n\n    apply()\n\n    const observer = new MutationObserver(apply)\n    observer.observe(document.documentElement, {\n      attributes: true,\n      attributeFilter: [\"class\"],\n    })\n    return () => observer.disconnect()\n  }, [])\n\n  useFrame((_, delta: number) => {\n    const mat = circleRef.current?.material\n    if (!mat) return\n    const live = colorsRef?.current\n    if (live) {\n      if (live[0]) targetColor1Ref.current.set(live[0])\n      if (live[1]) targetColor2Ref.current.set(live[1])\n    }\n    const u = mat.uniforms\n    u.uTime.value += delta * 0.5\n\n    if (u.uOpacity.value < 1) {\n      u.uOpacity.value = Math.min(1, u.uOpacity.value + delta * 2)\n    }\n\n    let targetIn = 0\n    let targetOut = 0.3\n    if (modeRef.current === \"manual\") {\n      targetIn = clamp01(\n        manualInput ?? inputVolumeRef?.current ?? getInputVolume?.() ?? 0\n      )\n      targetOut = clamp01(\n        manualOutput ?? outputVolumeRef?.current ?? getOutputVolume?.() ?? 0\n      )\n    } else {\n      const t = u.uTime.value * 2\n      if (agentRef.current === null) {\n        targetIn = 0\n        targetOut = 0.3\n      } else if (agentRef.current === \"listening\") {\n        targetIn = clamp01(0.55 + Math.sin(t * 3.2) * 0.35)\n        targetOut = 0.45\n      } else if (agentRef.current === \"talking\") {\n        targetIn = clamp01(0.65 + Math.sin(t * 4.8) * 0.22)\n        targetOut = clamp01(0.75 + Math.sin(t * 3.6) * 0.22)\n      } else {\n        const base = 0.38 + 0.07 * Math.sin(t * 0.7)\n        const wander = 0.05 * Math.sin(t * 2.1) * Math.sin(t * 0.37 + 1.2)\n        targetIn = clamp01(base + wander)\n        targetOut = clamp01(0.48 + 0.12 * Math.sin(t * 1.05 + 0.6))\n      }\n    }\n\n    curInRef.current += (targetIn - curInRef.current) * 0.2\n    curOutRef.current += (targetOut - curOutRef.current) * 0.2\n\n    const targetSpeed = 0.1 + (1 - Math.pow(curOutRef.current - 1, 2)) * 0.9\n    animSpeedRef.current += (targetSpeed - animSpeedRef.current) * 0.12\n\n    u.uAnimation.value += delta * animSpeedRef.current\n    u.uInputVolume.value = curInRef.current\n    u.uOutputVolume.value = curOutRef.current\n    u.uColor1.value.lerp(targetColor1Ref.current, 0.08)\n    u.uColor2.value.lerp(targetColor2Ref.current, 0.08)\n  })\n\n  useEffect(() => {\n    const canvas = gl.domElement\n    const onContextLost = (event: Event) => {\n      event.preventDefault()\n      setTimeout(() => {\n        gl.forceContextRestore()\n      }, 1)\n    }\n    canvas.addEventListener(\"webglcontextlost\", onContextLost, false)\n    return () =>\n      canvas.removeEventListener(\"webglcontextlost\", onContextLost, false)\n  }, [gl])\n\n  const uniforms = useMemo(() => {\n    perlinNoiseTexture.wrapS = THREE.RepeatWrapping\n    perlinNoiseTexture.wrapT = THREE.RepeatWrapping\n    const isDark =\n      typeof document !== \"undefined\" &&\n      document.documentElement.classList.contains(\"dark\")\n    return {\n      uColor1: new THREE.Uniform(new THREE.Color(initialColorsRef.current[0])),\n      uColor2: new THREE.Uniform(new THREE.Color(initialColorsRef.current[1])),\n      uOffsets: { value: offsets },\n      uPerlinTexture: new THREE.Uniform(perlinNoiseTexture),\n      uTime: new THREE.Uniform(0),\n      uAnimation: new THREE.Uniform(0.1),\n      uInverted: new THREE.Uniform(isDark ? 1 : 0),\n      uInputVolume: new THREE.Uniform(0),\n      uOutputVolume: new THREE.Uniform(0),\n      uOpacity: new THREE.Uniform(0),\n    }\n  }, [perlinNoiseTexture, offsets])\n\n  return (\n    <mesh ref={circleRef}>\n      <circleGeometry args={[3.5, 64]} />\n      <shaderMaterial\n        uniforms={uniforms}\n        fragmentShader={fragmentShader}\n        vertexShader={vertexShader}\n        transparent={true}\n      />\n    </mesh>\n  )\n}\n\nfunction splitmix32(a: number) {\n  return function () {\n    a |= 0\n    a = (a + 0x9e3779b9) | 0\n    let t = a ^ (a >>> 16)\n    t = Math.imul(t, 0x21f0aaad)\n    t = t ^ (t >>> 15)\n    t = Math.imul(t, 0x735a2d97)\n    return ((t = t ^ (t >>> 15)) >>> 0) / 4294967296\n  }\n}\n\nfunction clamp01(n: number) {\n  if (!Number.isFinite(n)) return 0\n  return Math.min(1, Math.max(0, n))\n}\nconst vertexShader = /* glsl */ `\nuniform float uTime;\nuniform sampler2D uPerlinTexture;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`\n\nconst fragmentShader = /* glsl */ `\nuniform float uTime;\nuniform float uAnimation;\nuniform float uInverted;\nuniform float uOffsets[7];\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform float uInputVolume;\nuniform float uOutputVolume;\nuniform float uOpacity;\nuniform sampler2D uPerlinTexture;\nvarying vec2 vUv;\n\nconst float PI = 3.14159265358979323846;\n\n// Draw a single oval with soft edges and calculate its gradient color\nbool drawOval(vec2 polarUv, vec2 polarCenter, float a, float b, bool reverseGradient, float softness, out vec4 color) {\n    vec2 p = polarUv - polarCenter;\n    float oval = (p.x * p.x) / (a * a) + (p.y * p.y) / (b * b);\n\n    float edge = smoothstep(1.0, 1.0 - softness, oval);\n\n    if (edge > 0.0) {\n        float gradient = reverseGradient ? (1.0 - (p.x / a + 1.0) / 2.0) : ((p.x / a + 1.0) / 2.0);\n        // Flatten gradient toward middle value for more uniform appearance\n        gradient = mix(0.5, gradient, 0.1);\n        color = vec4(vec3(gradient), 0.85 * edge);\n        return true;\n    }\n    return false;\n}\n\n// Map grayscale value to a 4-color ramp (color1, color2, color3, color4)\nvec3 colorRamp(float grayscale, vec3 color1, vec3 color2, vec3 color3, vec3 color4) {\n    if (grayscale < 0.33) {\n        return mix(color1, color2, grayscale * 3.0);\n    } else if (grayscale < 0.66) {\n        return mix(color2, color3, (grayscale - 0.33) * 3.0);\n    } else {\n        return mix(color3, color4, (grayscale - 0.66) * 3.0);\n    }\n}\n\nvec2 hash2(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// 2D noise for the ring\nfloat noise2D(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 u = f * f * (3.0 - 2.0 * f);\n    float n = mix(\n        mix(dot(hash2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n            dot(hash2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n        mix(dot(hash2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n            dot(hash2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x),\n        u.y\n    );\n\n    return 0.5 + 0.5 * n;\n}\n\nfloat sharpRing(vec3 decomposed, float time) {\n    float ringStart = 1.0;\n    float ringWidth = 0.3;\n    float noiseScale = 5.0;\n\n    float noise = mix(\n        noise2D(vec2(decomposed.x, time) * noiseScale),\n        noise2D(vec2(decomposed.y, time) * noiseScale),\n        decomposed.z\n    );\n\n    noise = (noise - 0.5) * 2.5;\n\n    return ringStart + noise * ringWidth * 1.5;\n}\n\nfloat smoothRing(vec3 decomposed, float time) {\n    float ringStart = 0.9;\n    float ringWidth = 0.2;\n    float noiseScale = 6.0;\n\n    float noise = mix(\n        noise2D(vec2(decomposed.x, time) * noiseScale),\n        noise2D(vec2(decomposed.y, time) * noiseScale),\n        decomposed.z\n    );\n\n    noise = (noise - 0.5) * 5.0;\n\n    return ringStart + noise * ringWidth;\n}\n\nfloat flow(vec3 decomposed, float time) {\n    return mix(\n        texture(uPerlinTexture, vec2(time, decomposed.x / 2.0)).r,\n        texture(uPerlinTexture, vec2(time, decomposed.y / 2.0)).r,\n        decomposed.z\n    );\n}\n\nvoid main() {\n    // Normalize vUv to be centered around (0.0, 0.0)\n    vec2 uv = vUv * 2.0 - 1.0;\n\n    // Convert uv to polar coordinates\n    float radius = length(uv);\n    float theta = atan(uv.y, uv.x);\n    if (theta < 0.0) theta += 2.0 * PI; // Normalize theta to [0, 2*PI]\n\n    // Decomposed angle is used for sampling noise textures without seams:\n    // float noise = mix(sample(decomposed.x), sample(decomposed.y), decomposed.z);\n    vec3 decomposed = vec3(\n        // angle in the range [0, 1]\n        theta / (2.0 * PI),\n        // angle offset by 180 degrees in the range [1, 2]\n        mod(theta / (2.0 * PI) + 0.5, 1.0) + 1.0,\n        // mixing factor between two noises\n        abs(theta / PI - 1.0)\n    );\n\n    // Add noise to the angle for a flow-like distortion (reduced for flatter look)\n    float noise = flow(decomposed, radius * 0.03 - uAnimation * 0.2) - 0.5;\n    theta += noise * mix(0.08, 0.25, uOutputVolume);\n\n    // Initialize the base color to white\n    vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n\n    // Original parameters for the ovals in polar coordinates\n    float originalCenters[7] = float[7](0.0, 0.5 * PI, 1.0 * PI, 1.5 * PI, 2.0 * PI, 2.5 * PI, 3.0 * PI);\n\n    // Parameters for the animated centers in polar coordinates\n    float centers[7];\n    for (int i = 0; i < 7; i++) {\n        centers[i] = originalCenters[i] + 0.5 * sin(uTime / 20.0 + uOffsets[i]);\n    }\n\n    float a, b;\n    vec4 ovalColor;\n\n    // Check if the pixel is inside any of the ovals\n    for (int i = 0; i < 7; i++) {\n        float noise = texture(uPerlinTexture, vec2(mod(centers[i] + uTime * 0.05, 1.0), 0.5)).r;\n        a = 0.5 + noise * 0.3; // Increased for more coverage\n        b = noise * mix(3.5, 2.5, uInputVolume); // Increased height for fuller appearance\n        bool reverseGradient = (i % 2 == 1); // Reverse gradient for every second oval\n\n        // Calculate the distance in polar coordinates\n        float distTheta = min(\n            abs(theta - centers[i]),\n            min(\n                abs(theta + 2.0 * PI - centers[i]),\n                abs(theta - 2.0 * PI - centers[i])\n            )\n        );\n        float distRadius = radius;\n\n        float softness = 0.6; // Increased softness for flatter, less pronounced edges\n\n        // Check if the pixel is inside the oval in polar coordinates\n        if (drawOval(vec2(distTheta, distRadius), vec2(0.0, 0.0), a, b, reverseGradient, softness, ovalColor)) {\n            // Blend the oval color with the existing color\n            color.rgb = mix(color.rgb, ovalColor.rgb, ovalColor.a);\n            color.a = max(color.a, ovalColor.a); // Max alpha\n        }\n    }\n    \n    // Calculate both noisy rings\n    float ringRadius1 = sharpRing(decomposed, uTime * 0.1);\n    float ringRadius2 = smoothRing(decomposed, uTime * 0.1);\n    \n    // Adjust rings based on input volume (reduced for flatter appearance)\n    float inputRadius1 = radius + uInputVolume * 0.2;\n    float inputRadius2 = radius + uInputVolume * 0.15;\n    float opacity1 = mix(0.2, 0.6, uInputVolume);\n    float opacity2 = mix(0.15, 0.45, uInputVolume);\n\n    // Blend both rings\n    float ringAlpha1 = (inputRadius2 >= ringRadius1) ? opacity1 : 0.0;\n    float ringAlpha2 = smoothstep(ringRadius2 - 0.05, ringRadius2 + 0.05, inputRadius1) * opacity2;\n    \n    float totalRingAlpha = max(ringAlpha1, ringAlpha2);\n    \n    // Apply screen blend mode for combined rings\n    vec3 ringColor = vec3(1.0); // White ring color\n    color.rgb = 1.0 - (1.0 - color.rgb) * (1.0 - ringColor * totalRingAlpha);\n\n    // Define colours to ramp against greyscale (could increase the amount of colours in the ramp)\n    vec3 color1 = vec3(0.0, 0.0, 0.0); // Black\n    vec3 color2 = uColor1; // Darker Color\n    vec3 color3 = uColor2; // Lighter Color\n    vec3 color4 = vec3(1.0, 1.0, 1.0); // White\n\n    // Convert grayscale color to the color ramp\n    float luminance = mix(color.r, 1.0 - color.r, uInverted);\n    color.rgb = colorRamp(luminance, color1, color2, color3, color4); // Apply the color ramp\n\n    // Apply fade-in opacity\n    color.a *= uOpacity;\n\n    gl_FragColor = color;\n}\n`\n"
    },
    {
      "path": "components/ui/waveform.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport { useEffect, useRef, type HTMLAttributes } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport type WaveformProps = HTMLAttributes<HTMLDivElement> & {\n  height?: string | number\n  barWidth?: number\n  barGap?: number\n  barRadius?: number\n  barColor?: string\n  fadeEdges?: boolean\n  fadeWidth?: number\n  data?: number[]\n}\n\nexport type ScrollingWaveformProps = WaveformProps & {\n  speed?: number\n  barCount?: number\n  amplitude?: number\n}\n\nexport const Waveform = ({\n  height = 100,\n  barWidth = 3,\n  barGap = 1,\n  barRadius = 2,\n  barColor = \"currentColor\",\n  fadeEdges = false,\n  fadeWidth = 20,\n  data = [],\n  className,\n  ...props\n}: WaveformProps) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n\n  useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext(\"2d\")\n    if (!ctx) return\n\n    const rect = canvas.getBoundingClientRect()\n    const dpr = window.devicePixelRatio || 1\n\n    canvas.width = rect.width * dpr\n    canvas.height = rect.height * dpr\n    ctx.scale(dpr, dpr)\n\n    ctx.clearRect(0, 0, rect.width, rect.height)\n    ctx.fillStyle = barColor\n\n    const barCount = Math.floor(rect.width / (barWidth + barGap))\n    const centerY = rect.height / 2\n\n    for (let i = 0; i < barCount && i < data.length; i++) {\n      const x = i * (barWidth + barGap)\n      const barHeight = Math.max(2, data[i] * rect.height * 0.8)\n      const y = centerY - barHeight / 2\n\n      if (barRadius > 0) {\n        ctx.beginPath()\n        ctx.roundRect(x, y, barWidth, barHeight, barRadius)\n        ctx.fill()\n      } else {\n        ctx.fillRect(x, y, barWidth, barHeight)\n      }\n    }\n\n    if (fadeEdges && fadeWidth > 0) {\n      const gradient = ctx.createLinearGradient(0, 0, fadeWidth, 0)\n      gradient.addColorStop(0, \"rgba(255, 255, 255, 1)\")\n      gradient.addColorStop(1, \"rgba(255, 255, 255, 0)\")\n\n      ctx.globalCompositeOperation = \"destination-out\"\n      ctx.fillStyle = gradient\n      ctx.fillRect(0, 0, fadeWidth, rect.height)\n\n      const rightGradient = ctx.createLinearGradient(\n        rect.width - fadeWidth,\n        0,\n        rect.width,\n        0\n      )\n      rightGradient.addColorStop(0, \"rgba(255, 255, 255, 0)\")\n      rightGradient.addColorStop(1, \"rgba(255, 255, 255, 1)\")\n\n      ctx.fillStyle = rightGradient\n      ctx.fillRect(rect.width - fadeWidth, 0, fadeWidth, rect.height)\n    }\n  }, [data, barWidth, barGap, barRadius, barColor, fadeEdges, fadeWidth])\n\n  return (\n    <div className={cn(\"relative\", className)} {...props}>\n      <canvas\n        ref={canvasRef}\n        className=\"w-full\"\n        style={{ height: typeof height === \"number\" ? `${height}px` : height }}\n      />\n    </div>\n  )\n}\n\nexport const ScrollingWaveform = ({\n  speed = 50,\n  barCount = 50,\n  amplitude = 0.8,\n  ...props\n}: ScrollingWaveformProps) => {\n  const dataRef = useRef<number[]>([])\n  const animationRef = useRef<number>()\n  const lastUpdateRef = useRef(0)\n\n  useEffect(() => {\n    // Initialize with random data\n    dataRef.current = Array.from(\n      { length: barCount },\n      () => Math.random() * amplitude\n    )\n\n    const animate = (timestamp: number) => {\n      if (timestamp - lastUpdateRef.current >= speed) {\n        // Shift data left and add new random value\n        dataRef.current.shift()\n        dataRef.current.push(Math.random() * amplitude)\n        lastUpdateRef.current = timestamp\n      }\n      animationRef.current = requestAnimationFrame(animate)\n    }\n\n    animationRef.current = requestAnimationFrame(animate)\n\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current)\n      }\n    }\n  }, [speed, barCount, amplitude])\n\n  return <Waveform {...props} data={dataRef.current} />\n}\n"
    },
    {
      "path": "components/ui/live-waveform.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport { useEffect, useRef, type HTMLAttributes } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport type LiveWaveformProps = HTMLAttributes<HTMLDivElement> & {\n  active?: boolean\n  processing?: boolean\n  barWidth?: number\n  barGap?: number\n  barRadius?: number\n  barColor?: string\n  fadeEdges?: boolean\n  fadeWidth?: number\n  height?: string | number\n  sensitivity?: number\n  smoothingTimeConstant?: number\n  fftSize?: number\n  historySize?: number\n  updateRate?: number\n  mode?: \"scrolling\" | \"static\"\n  onError?: (error: Error) => void\n  onStreamReady?: (stream: MediaStream) => void\n  onStreamEnd?: () => void\n}\n\nexport const LiveWaveform = ({\n  active = false,\n  processing = false,\n  barWidth = 3,\n  barGap = 1,\n  barRadius = 1.5,\n  barColor,\n  fadeEdges = true,\n  fadeWidth = 24,\n  height = 64,\n  sensitivity = 1,\n  smoothingTimeConstant = 0.8,\n  fftSize = 256,\n  historySize = 60,\n  updateRate = 30,\n  mode = \"static\",\n  onError,\n  onStreamReady,\n  onStreamEnd,\n  className,\n  ...props\n}: LiveWaveformProps) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const containerRef = useRef<HTMLDivElement>(null)\n  const historyRef = useRef<number[]>([])\n  const analyserRef = useRef<AnalyserNode | null>(null)\n  const audioContextRef = useRef<AudioContext | null>(null)\n  const streamRef = useRef<MediaStream | null>(null)\n  const animationRef = useRef<number>(0)\n  const lastUpdateRef = useRef<number>(0)\n  const processingAnimationRef = useRef<number | null>(null)\n  const lastActiveDataRef = useRef<number[]>([])\n  const transitionProgressRef = useRef(0)\n  const staticBarsRef = useRef<number[]>([])\n  const needsRedrawRef = useRef(true)\n  const gradientCacheRef = useRef<CanvasGradient | null>(null)\n  const lastWidthRef = useRef(0)\n\n  const heightStyle = typeof height === \"number\" ? `${height}px` : height\n\n  // Handle canvas resizing\n  useEffect(() => {\n    const canvas = canvasRef.current\n    const container = containerRef.current\n    if (!canvas || !container) return\n\n    const resizeObserver = new ResizeObserver(() => {\n      const rect = container.getBoundingClientRect()\n      const dpr = window.devicePixelRatio || 1\n\n      canvas.width = rect.width * dpr\n      canvas.height = rect.height * dpr\n      canvas.style.width = `${rect.width}px`\n      canvas.style.height = `${rect.height}px`\n\n      const ctx = canvas.getContext(\"2d\")\n      if (ctx) {\n        ctx.scale(dpr, dpr)\n      }\n\n      gradientCacheRef.current = null\n      lastWidthRef.current = rect.width\n      needsRedrawRef.current = true\n    })\n\n    resizeObserver.observe(container)\n    return () => resizeObserver.disconnect()\n  }, [])\n\n  useEffect(() => {\n    if (processing && !active) {\n      let time = 0\n      transitionProgressRef.current = 0\n\n      const animateProcessing = () => {\n        time += 0.03\n        transitionProgressRef.current = Math.min(\n          1,\n          transitionProgressRef.current + 0.02\n        )\n\n        const processingData = []\n        const barCount = Math.floor(\n          (containerRef.current?.getBoundingClientRect().width || 200) /\n            (barWidth + barGap)\n        )\n\n        if (mode === \"static\") {\n          const halfCount = Math.floor(barCount / 2)\n\n          for (let i = 0; i < barCount; i++) {\n            const normalizedPosition = (i - halfCount) / halfCount\n            const centerWeight = 1 - Math.abs(normalizedPosition) * 0.4\n\n            const wave1 = Math.sin(time * 1.5 + normalizedPosition * 3) * 0.25\n            const wave2 = Math.sin(time * 0.8 - normalizedPosition * 2) * 0.2\n            const wave3 = Math.cos(time * 2 + normalizedPosition) * 0.15\n            const combinedWave = wave1 + wave2 + wave3\n            const processingValue = (0.2 + combinedWave) * centerWeight\n\n            let finalValue = processingValue\n            if (\n              lastActiveDataRef.current.length > 0 &&\n              transitionProgressRef.current < 1\n            ) {\n              const lastDataIndex = Math.min(\n                i,\n                lastActiveDataRef.current.length - 1\n              )\n              const lastValue = lastActiveDataRef.current[lastDataIndex] || 0\n              finalValue =\n                lastValue * (1 - transitionProgressRef.current) +\n                processingValue * transitionProgressRef.current\n            }\n\n            processingData.push(Math.max(0.05, Math.min(1, finalValue)))\n          }\n        } else {\n          for (let i = 0; i < barCount; i++) {\n            const normalizedPosition = (i - barCount / 2) / (barCount / 2)\n            const centerWeight = 1 - Math.abs(normalizedPosition) * 0.4\n\n            const wave1 = Math.sin(time * 1.5 + i * 0.15) * 0.25\n            const wave2 = Math.sin(time * 0.8 - i * 0.1) * 0.2\n            const wave3 = Math.cos(time * 2 + i * 0.05) * 0.15\n            const combinedWave = wave1 + wave2 + wave3\n            const processingValue = (0.2 + combinedWave) * centerWeight\n\n            let finalValue = processingValue\n            if (\n              lastActiveDataRef.current.length > 0 &&\n              transitionProgressRef.current < 1\n            ) {\n              const lastDataIndex = Math.floor(\n                (i / barCount) * lastActiveDataRef.current.length\n              )\n              const lastValue = lastActiveDataRef.current[lastDataIndex] || 0\n              finalValue =\n                lastValue * (1 - transitionProgressRef.current) +\n                processingValue * transitionProgressRef.current\n            }\n\n            processingData.push(Math.max(0.05, Math.min(1, finalValue)))\n          }\n        }\n\n        if (mode === \"static\") {\n          staticBarsRef.current = processingData\n        } else {\n          historyRef.current = processingData\n        }\n\n        needsRedrawRef.current = true\n        processingAnimationRef.current =\n          requestAnimationFrame(animateProcessing)\n      }\n\n      animateProcessing()\n\n      return () => {\n        if (processingAnimationRef.current) {\n          cancelAnimationFrame(processingAnimationRef.current)\n        }\n      }\n    } else if (!active && !processing) {\n      const hasData =\n        mode === \"static\"\n          ? staticBarsRef.current.length > 0\n          : historyRef.current.length > 0\n\n      if (hasData) {\n        let fadeProgress = 0\n        const fadeToIdle = () => {\n          fadeProgress += 0.03\n          if (fadeProgress < 1) {\n            if (mode === \"static\") {\n              staticBarsRef.current = staticBarsRef.current.map(\n                (value) => value * (1 - fadeProgress)\n              )\n            } else {\n              historyRef.current = historyRef.current.map(\n                (value) => value * (1 - fadeProgress)\n              )\n            }\n            needsRedrawRef.current = true\n            requestAnimationFrame(fadeToIdle)\n          } else {\n            if (mode === \"static\") {\n              staticBarsRef.current = []\n            } else {\n              historyRef.current = []\n            }\n          }\n        }\n        fadeToIdle()\n      }\n    }\n  }, [processing, active, barWidth, barGap, mode])\n\n  // Handle microphone setup and teardown\n  useEffect(() => {\n    if (!active) {\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach((track) => track.stop())\n        streamRef.current = null\n        onStreamEnd?.()\n      }\n      if (\n        audioContextRef.current &&\n        audioContextRef.current.state !== \"closed\"\n      ) {\n        audioContextRef.current.close()\n        audioContextRef.current = null\n      }\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current)\n        animationRef.current = 0\n      }\n      return\n    }\n\n    const setupMicrophone = async () => {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: {\n            echoCancellation: true,\n            noiseSuppression: true,\n            autoGainControl: true,\n          },\n        })\n        streamRef.current = stream\n        onStreamReady?.(stream)\n\n        const AudioContextConstructor =\n          window.AudioContext ||\n          (window as unknown as { webkitAudioContext: typeof AudioContext })\n            .webkitAudioContext\n        const audioContext = new AudioContextConstructor()\n        const analyser = audioContext.createAnalyser()\n        analyser.fftSize = fftSize\n        analyser.smoothingTimeConstant = smoothingTimeConstant\n\n        const source = audioContext.createMediaStreamSource(stream)\n        source.connect(analyser)\n\n        audioContextRef.current = audioContext\n        analyserRef.current = analyser\n\n        // Clear history when starting\n        historyRef.current = []\n      } catch (error) {\n        onError?.(error as Error)\n      }\n    }\n\n    setupMicrophone()\n\n    return () => {\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach((track) => track.stop())\n        streamRef.current = null\n        onStreamEnd?.()\n      }\n      if (\n        audioContextRef.current &&\n        audioContextRef.current.state !== \"closed\"\n      ) {\n        audioContextRef.current.close()\n        audioContextRef.current = null\n      }\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current)\n        animationRef.current = 0\n      }\n    }\n  }, [\n    active,\n    fftSize,\n    smoothingTimeConstant,\n    onError,\n    onStreamReady,\n    onStreamEnd,\n  ])\n\n  // Animation loop\n  useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext(\"2d\")\n    if (!ctx) return\n\n    let rafId: number\n\n    const animate = (currentTime: number) => {\n      // Render waveform\n      const rect = canvas.getBoundingClientRect()\n\n      // Update audio data if active\n      if (active && currentTime - lastUpdateRef.current > updateRate) {\n        lastUpdateRef.current = currentTime\n\n        if (analyserRef.current) {\n          const dataArray = new Uint8Array(\n            analyserRef.current.frequencyBinCount\n          )\n          analyserRef.current.getByteFrequencyData(dataArray)\n\n          if (mode === \"static\") {\n            // For static mode, update bars in place\n            const startFreq = Math.floor(dataArray.length * 0.05)\n            const endFreq = Math.floor(dataArray.length * 0.4)\n            const relevantData = dataArray.slice(startFreq, endFreq)\n\n            const barCount = Math.floor(rect.width / (barWidth + barGap))\n            const halfCount = Math.floor(barCount / 2)\n            const newBars: number[] = []\n\n            // Mirror the data for symmetric display\n            for (let i = halfCount - 1; i >= 0; i--) {\n              const dataIndex = Math.floor(\n                (i / halfCount) * relevantData.length\n              )\n              const value = Math.min(\n                1,\n                (relevantData[dataIndex] / 255) * sensitivity\n              )\n              newBars.push(Math.max(0.05, value))\n            }\n\n            for (let i = 0; i < halfCount; i++) {\n              const dataIndex = Math.floor(\n                (i / halfCount) * relevantData.length\n              )\n              const value = Math.min(\n                1,\n                (relevantData[dataIndex] / 255) * sensitivity\n              )\n              newBars.push(Math.max(0.05, value))\n            }\n\n            staticBarsRef.current = newBars\n            lastActiveDataRef.current = newBars\n          } else {\n            // Scrolling mode - original behavior\n            let sum = 0\n            const startFreq = Math.floor(dataArray.length * 0.05)\n            const endFreq = Math.floor(dataArray.length * 0.4)\n            const relevantData = dataArray.slice(startFreq, endFreq)\n\n            for (let i = 0; i < relevantData.length; i++) {\n              sum += relevantData[i]\n            }\n            const average = (sum / relevantData.length / 255) * sensitivity\n\n            // Add to history\n            historyRef.current.push(Math.min(1, Math.max(0.05, average)))\n            lastActiveDataRef.current = [...historyRef.current]\n\n            // Maintain history size\n            if (historyRef.current.length > historySize) {\n              historyRef.current.shift()\n            }\n          }\n          needsRedrawRef.current = true\n        }\n      }\n\n      // Only redraw if needed\n      if (!needsRedrawRef.current && !active) {\n        rafId = requestAnimationFrame(animate)\n        return\n      }\n\n      needsRedrawRef.current = active\n      ctx.clearRect(0, 0, rect.width, rect.height)\n\n      const computedBarColor =\n        barColor ||\n        (() => {\n          const style = getComputedStyle(canvas)\n          // Try to get the computed color value directly\n          const color = style.color\n          return color || \"#000\"\n        })()\n\n      const step = barWidth + barGap\n      const barCount = Math.floor(rect.width / step)\n      const centerY = rect.height / 2\n\n      // Draw bars based on mode\n      if (mode === \"static\") {\n        // Static mode - bars in fixed positions\n        const dataToRender = processing\n          ? staticBarsRef.current\n          : active\n            ? staticBarsRef.current\n            : staticBarsRef.current.length > 0\n              ? staticBarsRef.current\n              : []\n\n        for (let i = 0; i < barCount && i < dataToRender.length; i++) {\n          const value = dataToRender[i] || 0.1\n          const x = i * step\n          const barHeight = Math.max(4, value * rect.height * 0.8)\n          const y = centerY - barHeight / 2\n\n          ctx.fillStyle = computedBarColor\n          ctx.globalAlpha = 0.4 + value * 0.6\n\n          if (barRadius > 0) {\n            ctx.beginPath()\n            ctx.roundRect(x, y, barWidth, barHeight, barRadius)\n            ctx.fill()\n          } else {\n            ctx.fillRect(x, y, barWidth, barHeight)\n          }\n        }\n      } else {\n        // Scrolling mode - original behavior\n        for (let i = 0; i < barCount && i < historyRef.current.length; i++) {\n          const dataIndex = historyRef.current.length - 1 - i\n          const value = historyRef.current[dataIndex] || 0.1\n          const x = rect.width - (i + 1) * step\n          const barHeight = Math.max(4, value * rect.height * 0.8)\n          const y = centerY - barHeight / 2\n\n          ctx.fillStyle = computedBarColor\n          ctx.globalAlpha = 0.4 + value * 0.6\n\n          if (barRadius > 0) {\n            ctx.beginPath()\n            ctx.roundRect(x, y, barWidth, barHeight, barRadius)\n            ctx.fill()\n          } else {\n            ctx.fillRect(x, y, barWidth, barHeight)\n          }\n        }\n      }\n\n      // Apply edge fading\n      if (fadeEdges && fadeWidth > 0 && rect.width > 0) {\n        // Cache gradient if width hasn't changed\n        if (!gradientCacheRef.current || lastWidthRef.current !== rect.width) {\n          const gradient = ctx.createLinearGradient(0, 0, rect.width, 0)\n          const fadePercent = Math.min(0.3, fadeWidth / rect.width)\n\n          // destination-out: removes destination where source alpha is high\n          // We want: fade edges out, keep center solid\n          // Left edge: start opaque (1) = remove, fade to transparent (0) = keep\n          gradient.addColorStop(0, \"rgba(255,255,255,1)\")\n          gradient.addColorStop(fadePercent, \"rgba(255,255,255,0)\")\n          // Center stays transparent = keep everything\n          gradient.addColorStop(1 - fadePercent, \"rgba(255,255,255,0)\")\n          // Right edge: fade from transparent (0) = keep to opaque (1) = remove\n          gradient.addColorStop(1, \"rgba(255,255,255,1)\")\n\n          gradientCacheRef.current = gradient\n          lastWidthRef.current = rect.width\n        }\n\n        ctx.globalCompositeOperation = \"destination-out\"\n        ctx.fillStyle = gradientCacheRef.current\n        ctx.fillRect(0, 0, rect.width, rect.height)\n        ctx.globalCompositeOperation = \"source-over\"\n      }\n\n      ctx.globalAlpha = 1\n\n      rafId = requestAnimationFrame(animate)\n    }\n\n    rafId = requestAnimationFrame(animate)\n\n    return () => {\n      if (rafId) {\n        cancelAnimationFrame(rafId)\n      }\n    }\n  }, [\n    active,\n    processing,\n    sensitivity,\n    updateRate,\n    historySize,\n    barWidth,\n    barGap,\n    barRadius,\n    barColor,\n    fadeEdges,\n    fadeWidth,\n    mode,\n  ])\n\n  return (\n    <div\n      className={cn(\"relative h-full w-full\", className)}\n      ref={containerRef}\n      style={{ height: heightStyle }}\n      aria-label={\n        active\n          ? \"Live audio waveform\"\n          : processing\n            ? \"Processing audio\"\n            : \"Audio waveform idle\"\n      }\n      role=\"img\"\n      {...props}\n    >\n      {!active && !processing && (\n        <div className=\"border-muted-foreground/20 absolute top-1/2 right-0 left-0 -translate-y-1/2 border-t-2 border-dotted\" />\n      )}\n      <canvas\n        className=\"block h-full w-full\"\n        ref={canvasRef}\n        aria-hidden=\"true\"\n      />\n    </div>\n  )\n}\n"
    },
    {
      "path": "components/ui/shimmering-text.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport React, { useMemo, useRef } from \"react\"\nimport { motion, useInView, UseInViewOptions } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface ShimmeringTextProps {\n  /** Text to display with shimmer effect */\n  text: string\n  /** Animation duration in seconds */\n  duration?: number\n  /** Delay before starting animation */\n  delay?: number\n  /** Whether to repeat the animation */\n  repeat?: boolean\n  /** Pause duration between repeats in seconds */\n  repeatDelay?: number\n  /** Custom className */\n  className?: string\n  /** Whether to start animation when component enters viewport */\n  startOnView?: boolean\n  /** Whether to animate only once */\n  once?: boolean\n  /** Margin for in-view detection (rootMargin) */\n  inViewMargin?: UseInViewOptions[\"margin\"]\n  /** Shimmer spread multiplier */\n  spread?: number\n  /** Base text color */\n  color?: string\n  /** Shimmer gradient color */\n  shimmerColor?: string\n}\n\nexport function ShimmeringText({\n  text,\n  duration = 2,\n  delay = 0,\n  repeat = true,\n  repeatDelay = 0.5,\n  className,\n  startOnView = true,\n  once = false,\n  inViewMargin,\n  spread = 2,\n  color,\n  shimmerColor,\n}: ShimmeringTextProps) {\n  const ref = useRef<HTMLSpanElement>(null)\n  const isInView = useInView(ref, { once, margin: inViewMargin })\n\n  // Calculate dynamic spread based on text length\n  const dynamicSpread = useMemo(() => {\n    return text.length * spread\n  }, [text, spread])\n\n  // Determine if we should start animation\n  const shouldAnimate = !startOnView || isInView\n\n  return (\n    <motion.span\n      ref={ref}\n      className={cn(\n        \"relative inline-block bg-[length:250%_100%,auto] bg-clip-text text-transparent\",\n        \"[--base-color:var(--muted-foreground)] [--shimmer-color:var(--foreground)]\",\n        \"[background-repeat:no-repeat,padding-box]\",\n        \"[--shimmer-bg:linear-gradient(90deg,transparent_calc(50%-var(--spread)),var(--shimmer-color),transparent_calc(50%+var(--spread)))]\",\n        \"dark:[--base-color:var(--muted-foreground)] dark:[--shimmer-color:var(--foreground)]\",\n        className\n      )}\n      style={\n        {\n          \"--spread\": `${dynamicSpread}px`,\n          ...(color && { \"--base-color\": color }),\n          ...(shimmerColor && { \"--shimmer-color\": shimmerColor }),\n          backgroundImage: `var(--shimmer-bg), linear-gradient(var(--base-color), var(--base-color))`,\n        } as React.CSSProperties\n      }\n      initial={{\n        backgroundPosition: \"100% center\",\n        opacity: 0,\n      }}\n      animate={\n        shouldAnimate\n          ? {\n              backgroundPosition: \"0% center\",\n              opacity: 1,\n            }\n          : {}\n      }\n      transition={{\n        backgroundPosition: {\n          repeat: repeat ? Infinity : 0,\n          duration,\n          delay,\n          repeatDelay,\n          ease: \"linear\",\n        },\n        opacity: {\n          duration: 0.3,\n          delay,\n        },\n      }}\n    >\n      {text}\n    </motion.span>\n  )\n}\n"
    },
    {
      "path": "components/ui/audio-player.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport {\n  ComponentProps,\n  createContext,\n  HTMLProps,\n  ReactNode,\n  RefObject,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport * as SliderPrimitive from \"@radix-ui/react-slider\"\nimport { PauseIcon, PlayIcon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\nenum ReadyState {\n  HAVE_NOTHING = 0,\n  HAVE_METADATA = 1,\n  HAVE_CURRENT_DATA = 2,\n  HAVE_FUTURE_DATA = 3,\n  HAVE_ENOUGH_DATA = 4,\n}\n\nenum NetworkState {\n  NETWORK_EMPTY = 0,\n  NETWORK_IDLE = 1,\n  NETWORK_LOADING = 2,\n  NETWORK_NO_SOURCE = 3,\n}\n\nfunction formatTime(seconds: number) {\n  const hrs = Math.floor(seconds / 3600)\n  const mins = Math.floor((seconds % 3600) / 60)\n  const secs = Math.floor(seconds % 60)\n\n  const formattedMins = mins < 10 ? `0${mins}` : mins\n  const formattedSecs = secs < 10 ? `0${secs}` : secs\n\n  return hrs > 0\n    ? `${hrs}:${formattedMins}:${formattedSecs}`\n    : `${mins}:${formattedSecs}`\n}\n\ninterface AudioPlayerItem<TData = unknown> {\n  id: string | number\n  src: string\n  data?: TData\n}\n\ninterface AudioPlayerApi<TData = unknown> {\n  ref: RefObject<HTMLAudioElement | null>\n  activeItem: AudioPlayerItem<TData> | null\n  duration: number | undefined\n  error: MediaError | null\n  isPlaying: boolean\n  isBuffering: boolean\n  isItemActive: (id: string | number | null) => boolean\n  setActiveItem: (item: AudioPlayerItem<TData> | null) => Promise<void>\n  play: (item?: AudioPlayerItem<TData> | null) => Promise<void>\n  pause: () => void\n  seek: (time: number) => void\n}\n\nconst AudioPlayerContext = createContext<AudioPlayerApi<unknown> | null>(null)\n\nexport function useAudioPlayer<TData = unknown>(): AudioPlayerApi<TData> {\n  const api = useContext(AudioPlayerContext) as AudioPlayerApi<TData> | null\n  if (!api) {\n    throw new Error(\n      \"useAudioPlayer cannot be called outside of AudioPlayerProvider\"\n    )\n  }\n  return api\n}\n\nconst AudioPlayerTimeContext = createContext<number | null>(null)\n\nexport const useAudioPlayerTime = () => {\n  const time = useContext(AudioPlayerTimeContext)\n  if (time === null) {\n    throw new Error(\n      \"useAudioPlayerTime cannot be called outside of AudioPlayerProvider\"\n    )\n  }\n  return time\n}\n\nexport function AudioPlayerProvider<TData = unknown>({\n  children,\n}: {\n  children: ReactNode\n}) {\n  const audioRef = useRef<HTMLAudioElement>(null)\n  const itemRef = useRef<AudioPlayerItem<TData> | null>(null)\n  const playPromiseRef = useRef<Promise<void> | null>(null)\n  const [readyState, setReadyState] = useState<number>(0)\n  const [networkState, setNetworkState] = useState<number>(0)\n  const [time, setTime] = useState<number>(0)\n  const [duration, setDuration] = useState<number | undefined>(undefined)\n  const [error, setError] = useState<MediaError | null>(null)\n  const [activeItem, _setActiveItem] = useState<AudioPlayerItem<TData> | null>(\n    null\n  )\n  const [paused, setPaused] = useState(true)\n\n  const setActiveItem = useCallback(\n    async (item: AudioPlayerItem<TData> | null) => {\n      if (!audioRef.current) return\n\n      if (item?.id === itemRef.current?.id) {\n        return\n      }\n      itemRef.current = item\n      audioRef.current.pause()\n      audioRef.current.currentTime = 0\n      if (item === null) {\n        audioRef.current.removeAttribute(\"src\")\n      } else {\n        audioRef.current.src = item.src\n      }\n      audioRef.current.load()\n    },\n    []\n  )\n\n  const play = useCallback(\n    async (item?: AudioPlayerItem<TData> | null) => {\n      if (!audioRef.current) return\n\n      if (playPromiseRef.current) {\n        try {\n          await playPromiseRef.current\n        } catch (error) {\n          console.error(\"Play promise error:\", error)\n        }\n      }\n\n      if (item === undefined) {\n        const playPromise = audioRef.current.play()\n        playPromiseRef.current = playPromise\n        return playPromise\n      }\n      if (item?.id === activeItem?.id) {\n        const playPromise = audioRef.current.play()\n        playPromiseRef.current = playPromise\n        return playPromise\n      }\n\n      itemRef.current = item\n      if (!audioRef.current.paused) {\n        audioRef.current.pause()\n      }\n      audioRef.current.currentTime = 0\n      if (item === null) {\n        audioRef.current.removeAttribute(\"src\")\n      } else {\n        audioRef.current.src = item.src\n      }\n      audioRef.current.load()\n      const playPromise = audioRef.current.play()\n      playPromiseRef.current = playPromise\n      return playPromise\n    },\n    [activeItem]\n  )\n\n  const pause = useCallback(async () => {\n    if (!audioRef.current) return\n\n    if (playPromiseRef.current) {\n      try {\n        await playPromiseRef.current\n      } catch (e) {\n        console.error(e)\n      }\n    }\n\n    audioRef.current.pause()\n    playPromiseRef.current = null\n  }, [])\n\n  const seek = useCallback((time: number) => {\n    if (!audioRef.current) return\n    audioRef.current.currentTime = time\n  }, [])\n\n  const isItemActive = useCallback(\n    (id: string | number | null) => {\n      return activeItem?.id === id\n    },\n    [activeItem]\n  )\n\n  useAnimationFrame(() => {\n    if (audioRef.current) {\n      _setActiveItem(itemRef.current)\n      setReadyState(audioRef.current.readyState)\n      setNetworkState(audioRef.current.networkState)\n      setTime(audioRef.current.currentTime)\n      setDuration(audioRef.current.duration)\n      setPaused(audioRef.current.paused)\n      setError(audioRef.current.error)\n    }\n  })\n\n  const isPlaying = !paused\n  const isBuffering =\n    readyState < ReadyState.HAVE_FUTURE_DATA &&\n    networkState === NetworkState.NETWORK_LOADING\n\n  const api = useMemo<AudioPlayerApi<TData>>(\n    () => ({\n      ref: audioRef,\n      duration,\n      error,\n      isPlaying,\n      isBuffering,\n      activeItem,\n      isItemActive,\n      setActiveItem,\n      play,\n      pause,\n      seek,\n    }),\n    [\n      audioRef,\n      duration,\n      error,\n      isPlaying,\n      isBuffering,\n      activeItem,\n      isItemActive,\n      setActiveItem,\n      play,\n      pause,\n      seek,\n    ]\n  )\n\n  return (\n    <AudioPlayerContext.Provider value={api as AudioPlayerApi<unknown>}>\n      <AudioPlayerTimeContext.Provider value={time}>\n        <audio ref={audioRef} className=\"hidden\" crossOrigin=\"anonymous\" />\n        {children}\n      </AudioPlayerTimeContext.Provider>\n    </AudioPlayerContext.Provider>\n  )\n}\n\nexport const AudioPlayerProgress = ({\n  ...otherProps\n}: Omit<\n  ComponentProps<typeof SliderPrimitive.Root>,\n  \"min\" | \"max\" | \"value\"\n>) => {\n  const player = useAudioPlayer()\n  const time = useAudioPlayerTime()\n  const wasPlayingRef = useRef(false)\n\n  return (\n    <SliderPrimitive.Root\n      {...otherProps}\n      value={[time]}\n      onValueChange={(vals) => {\n        player.seek(vals[0])\n        otherProps.onValueChange?.(vals)\n      }}\n      min={0}\n      max={player.duration ?? 0}\n      step={otherProps.step || 0.25}\n      onPointerDown={(e) => {\n        wasPlayingRef.current = player.isPlaying\n        player.pause()\n        otherProps.onPointerDown?.(e)\n      }}\n      onPointerUp={(e) => {\n        if (wasPlayingRef.current) {\n          player.play()\n        }\n        otherProps.onPointerUp?.(e)\n      }}\n      className={cn(\n        \"group/player relative flex h-4 touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col\",\n        otherProps.className\n      )}\n      onKeyDown={(e) => {\n        if (e.key === \" \") {\n          e.preventDefault()\n          if (!player.isPlaying) {\n            player.play()\n          } else {\n            player.pause()\n          }\n        }\n        otherProps.onKeyDown?.(e)\n      }}\n      disabled={\n        player.duration === undefined ||\n        !Number.isFinite(player.duration) ||\n        Number.isNaN(player.duration)\n      }\n    >\n      <SliderPrimitive.Track className=\"bg-muted relative h-[4px] w-full grow overflow-hidden rounded-full\">\n        <SliderPrimitive.Range className=\"bg-primary absolute h-full\" />\n      </SliderPrimitive.Track>\n      <SliderPrimitive.Thumb\n        className=\"relative flex h-0 w-0 items-center justify-center opacity-0 group-hover/player:opacity-100 focus-visible:opacity-100 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50\"\n        data-slot=\"slider-thumb\"\n      >\n        <div className=\"bg-foreground absolute size-3 rounded-full\" />\n      </SliderPrimitive.Thumb>\n    </SliderPrimitive.Root>\n  )\n}\n\nexport const AudioPlayerTime = ({\n  className,\n  ...otherProps\n}: HTMLProps<HTMLSpanElement>) => {\n  const time = useAudioPlayerTime()\n  return (\n    <span\n      {...otherProps}\n      className={cn(\"text-muted-foreground text-sm tabular-nums\", className)}\n    >\n      {formatTime(time)}\n    </span>\n  )\n}\n\nexport const AudioPlayerDuration = ({\n  className,\n  ...otherProps\n}: HTMLProps<HTMLSpanElement>) => {\n  const player = useAudioPlayer()\n  return (\n    <span\n      {...otherProps}\n      className={cn(\"text-muted-foreground text-sm tabular-nums\", className)}\n    >\n      {player.duration !== null &&\n      player.duration !== undefined &&\n      !Number.isNaN(player.duration)\n        ? formatTime(player.duration)\n        : \"--:--\"}\n    </span>\n  )\n}\n\ninterface SpinnerProps {\n  className?: string\n}\n\nfunction Spinner({ className }: SpinnerProps) {\n  return (\n    <div\n      className={cn(\n        \"border-muted border-t-foreground size-3.5 animate-spin rounded-full border-2\",\n        className\n      )}\n      role=\"status\"\n      aria-label=\"Loading\"\n    >\n      <span className=\"sr-only\">Loading...</span>\n    </div>\n  )\n}\n\ninterface PlayButtonProps extends React.ComponentProps<typeof Button> {\n  playing: boolean\n  onPlayingChange: (playing: boolean) => void\n  loading?: boolean\n}\n\nconst PlayButton = ({\n  playing,\n  onPlayingChange,\n  className,\n  onClick,\n  loading,\n  ...otherProps\n}: PlayButtonProps) => {\n  return (\n    <Button\n      {...otherProps}\n      onClick={(e) => {\n        onPlayingChange(!playing)\n        onClick?.(e)\n      }}\n      className={cn(\"relative\", className)}\n      aria-label={playing ? \"Pause\" : \"Play\"}\n      type=\"button\"\n    >\n      {playing ? (\n        <PauseIcon\n          className={cn(\"size-4\", loading && \"opacity-0\")}\n          aria-hidden=\"true\"\n        />\n      ) : (\n        <PlayIcon\n          className={cn(\"size-4\", loading && \"opacity-0\")}\n          aria-hidden=\"true\"\n        />\n      )}\n      {loading && (\n        <div className=\"absolute inset-0 flex items-center justify-center rounded-[inherit] backdrop-blur-xs\">\n          <Spinner />\n        </div>\n      )}\n    </Button>\n  )\n}\n\nexport interface AudioPlayerButtonProps<TData = unknown>\n  extends React.ComponentProps<typeof Button> {\n  item?: AudioPlayerItem<TData>\n}\n\nexport function AudioPlayerButton<TData = unknown>({\n  item,\n  ...otherProps\n}: AudioPlayerButtonProps<TData>) {\n  const player = useAudioPlayer<TData>()\n\n  if (!item) {\n    return (\n      <PlayButton\n        {...otherProps}\n        playing={player.isPlaying}\n        onPlayingChange={(shouldPlay) => {\n          if (shouldPlay) {\n            player.play()\n          } else {\n            player.pause()\n          }\n        }}\n        loading={player.isBuffering && player.isPlaying}\n      />\n    )\n  }\n\n  return (\n    <PlayButton\n      {...otherProps}\n      playing={player.isItemActive(item.id) && player.isPlaying}\n      onPlayingChange={(shouldPlay) => {\n        if (shouldPlay) {\n          player.play(item)\n        } else {\n          player.pause()\n        }\n      }}\n      loading={\n        player.isItemActive(item.id) && player.isBuffering && player.isPlaying\n      }\n    />\n  )\n}\n\ntype Callback = (delta: number) => void\n\nfunction useAnimationFrame(callback: Callback) {\n  const requestRef = useRef<number | null>(null)\n  const previousTimeRef = useRef<number | null>(null)\n  const callbackRef = useRef<Callback>(callback)\n\n  useEffect(() => {\n    callbackRef.current = callback\n  }, [callback])\n\n  useEffect(() => {\n    const animate = (time: number) => {\n      if (previousTimeRef.current !== null) {\n        const delta = time - previousTimeRef.current\n        callbackRef.current(delta)\n      }\n      previousTimeRef.current = time\n      requestRef.current = requestAnimationFrame(animate)\n    }\n\n    requestRef.current = requestAnimationFrame(animate)\n\n    return () => {\n      if (requestRef.current) cancelAnimationFrame(requestRef.current)\n      previousTimeRef.current = null\n    }\n  }, [])\n}\n\nexport const exampleTracks = [\n  {\n    id: \"0\",\n    name: \"II - 00\",\n    url: \"https://storage.googleapis.com/eleven-public-cdn/audio/ui-elevenlabs-io/00.mp3\",\n  },\n  {\n    id: \"1\",\n    name: \"II - 01\",\n    url: \"https://storage.googleapis.com/eleven-public-cdn/audio/ui-elevenlabs-io/01.mp3\",\n  },\n  {\n    id: \"2\",\n    name: \"II - 02\",\n    url: \"https://storage.googleapis.com/eleven-public-cdn/audio/ui-elevenlabs-io/02.mp3\",\n  },\n  {\n    id: \"3\",\n    name: \"II - 03\",\n    url: \"https://storage.googleapis.com/eleven-public-cdn/audio/ui-elevenlabs-io/03.mp3\",\n  },\n  {\n    id: \"4\",\n    name: \"II - 04\",\n    url: \"https://storage.googleapis.com/eleven-public-cdn/audio/ui-elevenlabs-io/04.mp3\",\n  },\n  {\n    id: \"5\",\n    name: \"II - 05\",\n    url: \"https://storage.googleapis.com/eleven-public-cdn/audio/ui-elevenlabs-io/05.mp3\",\n  },\n  {\n    id: \"6\",\n    name: \"II - 06\",\n    url: \"https://storage.googleapis.com/eleven-public-cdn/audio/ui-elevenlabs-io/06.mp3\",\n  },\n  {\n    id: \"7\",\n    name: \"II - 07\",\n    url: \"https://storage.googleapis.com/eleven-public-cdn/audio/ui-elevenlabs-io/07.mp3\",\n  },\n  {\n    id: \"8\",\n    name: \"II - 08\",\n    url: \"https://storage.googleapis.com/eleven-public-cdn/audio/ui-elevenlabs-io/08.mp3\",\n  },\n  {\n    id: \"9\",\n    name: \"II - 09\",\n    url: \"https://storage.googleapis.com/eleven-public-cdn/audio/ui-elevenlabs-io/09.mp3\",\n  },\n]\n"
    },
    {
      "path": "components/ui/message.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "import type { ComponentProps, HTMLAttributes } from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport {\n  Avatar,\n  AvatarFallback,\n  AvatarImage,\n} from \"@/components/ui/avatar\"\n\nexport type MessageProps = HTMLAttributes<HTMLDivElement> & {\n  from: \"user\" | \"assistant\"\n}\n\nexport const Message = ({ className, from, ...props }: MessageProps) => (\n  <div\n    className={cn(\n      \"group flex w-full items-end justify-end gap-2 py-4\",\n      from === \"user\" ? \"is-user\" : \"is-assistant flex-row-reverse justify-end\",\n      className\n    )}\n    {...props}\n  />\n)\n\nconst messageContentVariants = cva(\n  \"is-user:dark flex flex-col gap-2 overflow-hidden rounded-lg text-sm\",\n  {\n    variants: {\n      variant: {\n        contained: [\n          \"max-w-[80%] px-4 py-3\",\n          \"group-[.is-user]:bg-primary group-[.is-user]:text-primary-foreground\",\n          \"group-[.is-assistant]:bg-secondary group-[.is-assistant]:text-foreground\",\n        ],\n        flat: [\n          \"group-[.is-user]:max-w-[80%] group-[.is-user]:bg-secondary group-[.is-user]:px-4 group-[.is-user]:py-3 group-[.is-user]:text-foreground\",\n          \"group-[.is-assistant]:text-foreground\",\n        ],\n      },\n    },\n    defaultVariants: {\n      variant: \"contained\",\n    },\n  }\n)\n\nexport type MessageContentProps = HTMLAttributes<HTMLDivElement> &\n  VariantProps<typeof messageContentVariants>\n\nexport const MessageContent = ({\n  children,\n  className,\n  variant,\n  ...props\n}: MessageContentProps) => (\n  <div\n    className={cn(messageContentVariants({ variant, className }))}\n    {...props}\n  >\n    {children}\n  </div>\n)\n\nexport type MessageAvatarProps = ComponentProps<typeof Avatar> & {\n  src: string\n  name?: string\n}\n\nexport const MessageAvatar = ({\n  src,\n  name,\n  className,\n  ...props\n}: MessageAvatarProps) => (\n  <Avatar className={cn(\"ring-border size-8 ring-1\", className)} {...props}>\n    <AvatarImage alt=\"\" className=\"mt-0 mb-0\" src={src} />\n    <AvatarFallback>{name?.slice(0, 2) || \"ME\"}</AvatarFallback>\n  </Avatar>\n)\n"
    },
    {
      "path": "components/ui/conversation.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport type { ComponentProps } from \"react\"\nimport { useCallback } from \"react\"\nimport { ArrowDownIcon } from \"lucide-react\"\nimport { StickToBottom, useStickToBottomContext } from \"use-stick-to-bottom\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\nexport type ConversationProps = ComponentProps<typeof StickToBottom>\n\nexport const Conversation = ({ className, ...props }: ConversationProps) => (\n  <StickToBottom\n    className={cn(\"relative flex-1 overflow-y-auto\", className)}\n    initial=\"smooth\"\n    resize=\"smooth\"\n    role=\"log\"\n    {...props}\n  />\n)\n\nexport type ConversationContentProps = ComponentProps<\n  typeof StickToBottom.Content\n>\n\nexport const ConversationContent = ({\n  className,\n  ...props\n}: ConversationContentProps) => (\n  <StickToBottom.Content className={cn(\"p-4\", className)} {...props} />\n)\n\nexport type ConversationEmptyStateProps = Omit<\n  ComponentProps<\"div\">,\n  \"title\"\n> & {\n  title?: React.ReactNode\n  description?: React.ReactNode\n  icon?: React.ReactNode\n}\n\nexport const ConversationEmptyState = ({\n  className,\n  title = \"No messages yet\",\n  description = \"Start a conversation to see messages here\",\n  icon,\n  children,\n  ...props\n}: ConversationEmptyStateProps) => (\n  <div\n    className={cn(\n      \"flex size-full flex-col items-center justify-center gap-3 p-8 text-center\",\n      className\n    )}\n    {...props}\n  >\n    {children ?? (\n      <>\n        {icon && <div className=\"text-muted-foreground\">{icon}</div>}\n        <div className=\"space-y-1\">\n          <h3 className=\"text-sm font-medium\">{title}</h3>\n          {description && (\n            <p className=\"text-muted-foreground text-sm\">{description}</p>\n          )}\n        </div>\n      </>\n    )}\n  </div>\n)\n\nexport type ConversationScrollButtonProps = ComponentProps<typeof Button>\n\nexport const ConversationScrollButton = ({\n  className,\n  ...props\n}: ConversationScrollButtonProps) => {\n  const { isAtBottom, scrollToBottom } = useStickToBottomContext()\n\n  const handleScrollToBottom = useCallback(() => {\n    scrollToBottom()\n  }, [scrollToBottom])\n\n  return (\n    !isAtBottom && (\n      <Button\n        className={cn(\n          \"bg-background dark:bg-background absolute bottom-4 left-[50%] translate-x-[-50%] rounded-full shadow-md\",\n          className\n        )}\n        onClick={handleScrollToBottom}\n        size=\"icon\"\n        type=\"button\"\n        variant=\"outline\"\n        {...props}\n      >\n        <ArrowDownIcon className=\"size-4\" />\n      </Button>\n    )\n  )\n}\n"
    },
    {
      "path": "components/ui/response.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport { memo, type ComponentProps } from \"react\"\nimport { Streamdown } from \"streamdown\"\n\nimport { cn } from \"@/lib/utils\"\n\ntype ResponseProps = ComponentProps<typeof Streamdown>\n\nexport const Response = memo(\n  ({ className, ...props }: ResponseProps) => (\n    <Streamdown\n      className={cn(\n        \"size-full [&>*:first-child]:mt-0 [&>*:last-child]:mb-0\",\n        className\n      )}\n      {...props}\n    />\n  ),\n  (prevProps, nextProps) => prevProps.children === nextProps.children\n)\n\nResponse.displayName = \"Response\"\n"
    },
    {
      "path": "components/ui/bar-visualizer.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { useEffect, useMemo, useRef, useState } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface AudioAnalyserOptions {\n  fftSize?: number\n  smoothingTimeConstant?: number\n  minDecibels?: number\n  maxDecibels?: number\n}\n\nfunction createAudioAnalyser(\n  mediaStream: MediaStream,\n  options: AudioAnalyserOptions = {}\n) {\n  const audioContext = new (window.AudioContext ||\n    (window as unknown as { webkitAudioContext: typeof AudioContext })\n      .webkitAudioContext)()\n  const source = audioContext.createMediaStreamSource(mediaStream)\n  const analyser = audioContext.createAnalyser()\n\n  if (options.fftSize) analyser.fftSize = options.fftSize\n  if (options.smoothingTimeConstant !== undefined) {\n    analyser.smoothingTimeConstant = options.smoothingTimeConstant\n  }\n  if (options.minDecibels !== undefined)\n    analyser.minDecibels = options.minDecibels\n  if (options.maxDecibels !== undefined)\n    analyser.maxDecibels = options.maxDecibels\n\n  source.connect(analyser)\n\n  const cleanup = () => {\n    source.disconnect()\n    audioContext.close()\n  }\n\n  return { analyser, audioContext, cleanup }\n}\n\n/**\n * Hook for tracking the volume of an audio stream using the Web Audio API.\n * @param mediaStream - The MediaStream to analyze\n * @param options - Audio analyser options\n * @returns The current volume level (0-1)\n */\nexport function useAudioVolume(\n  mediaStream?: MediaStream | null,\n  options: AudioAnalyserOptions = { fftSize: 32, smoothingTimeConstant: 0 }\n) {\n  const [volume, setVolume] = useState(0)\n  const volumeRef = useRef(0)\n  const frameId = useRef<number | undefined>(undefined)\n\n  // Memoize options to prevent unnecessary re-renders\n  const memoizedOptions = useMemo(\n    () => options,\n    [\n      options.fftSize,\n      options.smoothingTimeConstant,\n      options.minDecibels,\n      options.maxDecibels,\n    ]\n  )\n\n  useEffect(() => {\n    if (!mediaStream) {\n      setVolume(0)\n      volumeRef.current = 0\n      return\n    }\n\n    const { analyser, cleanup } = createAudioAnalyser(\n      mediaStream,\n      memoizedOptions\n    )\n\n    const bufferLength = analyser.frequencyBinCount\n    const dataArray = new Uint8Array(bufferLength)\n    let lastUpdate = 0\n    const updateInterval = 1000 / 30 // 30 FPS\n\n    const updateVolume = (timestamp: number) => {\n      if (timestamp - lastUpdate >= updateInterval) {\n        analyser.getByteFrequencyData(dataArray)\n        let sum = 0\n        for (let i = 0; i < dataArray.length; i++) {\n          const a = dataArray[i]\n          sum += a * a\n        }\n        const newVolume = Math.sqrt(sum / dataArray.length) / 255\n\n        // Only update state if volume changed significantly\n        if (Math.abs(newVolume - volumeRef.current) > 0.01) {\n          volumeRef.current = newVolume\n          setVolume(newVolume)\n        }\n        lastUpdate = timestamp\n      }\n      frameId.current = requestAnimationFrame(updateVolume)\n    }\n\n    frameId.current = requestAnimationFrame(updateVolume)\n\n    return () => {\n      cleanup()\n      if (frameId.current) {\n        cancelAnimationFrame(frameId.current)\n      }\n    }\n  }, [mediaStream, memoizedOptions])\n\n  return volume\n}\n\nexport interface MultiBandVolumeOptions {\n  bands?: number\n  loPass?: number // Low frequency cutoff\n  hiPass?: number // High frequency cutoff\n  updateInterval?: number // Update interval in ms\n  analyserOptions?: AudioAnalyserOptions\n}\n\nconst multibandDefaults: MultiBandVolumeOptions = {\n  bands: 5,\n  loPass: 100,\n  hiPass: 600,\n  updateInterval: 32,\n  analyserOptions: { fftSize: 2048 },\n}\n\n// Memoized normalization function to avoid recreating on each render\nconst normalizeDb = (value: number) => {\n  if (value === -Infinity) return 0\n  const minDb = -100\n  const maxDb = -10\n  const db = 1 - (Math.max(minDb, Math.min(maxDb, value)) * -1) / 100\n  return Math.sqrt(db)\n}\n\n/**\n * Hook for tracking volume across multiple frequency bands\n * @param mediaStream - The MediaStream to analyze\n * @param options - Multiband options\n * @returns Array of volume levels for each frequency band\n */\nexport function useMultibandVolume(\n  mediaStream?: MediaStream | null,\n  options: MultiBandVolumeOptions = {}\n) {\n  const opts = useMemo(\n    () => ({ ...multibandDefaults, ...options }),\n    [\n      options.bands,\n      options.loPass,\n      options.hiPass,\n      options.updateInterval,\n      options.analyserOptions?.fftSize,\n      options.analyserOptions?.smoothingTimeConstant,\n      options.analyserOptions?.minDecibels,\n      options.analyserOptions?.maxDecibels,\n    ]\n  )\n\n  const [frequencyBands, setFrequencyBands] = useState<number[]>(() =>\n    new Array(opts.bands).fill(0)\n  )\n  const bandsRef = useRef<number[]>(new Array(opts.bands).fill(0))\n  const frameId = useRef<number | undefined>(undefined)\n\n  useEffect(() => {\n    if (!mediaStream) {\n      const emptyBands = new Array(opts.bands).fill(0)\n      setFrequencyBands(emptyBands)\n      bandsRef.current = emptyBands\n      return\n    }\n\n    const { analyser, cleanup } = createAudioAnalyser(\n      mediaStream,\n      opts.analyserOptions\n    )\n\n    const bufferLength = analyser.frequencyBinCount\n    const dataArray = new Float32Array(bufferLength)\n    const sliceStart = opts.loPass!\n    const sliceEnd = opts.hiPass!\n    const sliceLength = sliceEnd - sliceStart\n    const chunkSize = Math.ceil(sliceLength / opts.bands!)\n\n    let lastUpdate = 0\n    const updateInterval = opts.updateInterval!\n\n    const updateVolume = (timestamp: number) => {\n      if (timestamp - lastUpdate >= updateInterval) {\n        analyser.getFloatFrequencyData(dataArray)\n\n        // Process directly without creating intermediate arrays\n        const chunks = new Array(opts.bands!)\n\n        for (let i = 0; i < opts.bands!; i++) {\n          let sum = 0\n          let count = 0\n          const startIdx = sliceStart + i * chunkSize\n          const endIdx = Math.min(sliceStart + (i + 1) * chunkSize, sliceEnd)\n\n          for (let j = startIdx; j < endIdx; j++) {\n            sum += normalizeDb(dataArray[j])\n            count++\n          }\n\n          chunks[i] = count > 0 ? sum / count : 0\n        }\n\n        // Only update state if bands changed significantly\n        let hasChanged = false\n        for (let i = 0; i < chunks.length; i++) {\n          if (Math.abs(chunks[i] - bandsRef.current[i]) > 0.01) {\n            hasChanged = true\n            break\n          }\n        }\n\n        if (hasChanged) {\n          bandsRef.current = chunks\n          setFrequencyBands(chunks)\n        }\n\n        lastUpdate = timestamp\n      }\n\n      frameId.current = requestAnimationFrame(updateVolume)\n    }\n\n    frameId.current = requestAnimationFrame(updateVolume)\n\n    return () => {\n      cleanup()\n      if (frameId.current) {\n        cancelAnimationFrame(frameId.current)\n      }\n    }\n  }, [mediaStream, opts])\n\n  return frequencyBands\n}\n\ntype AnimationState =\n  | \"connecting\"\n  | \"initializing\"\n  | \"listening\"\n  | \"speaking\"\n  | \"thinking\"\n  | undefined\n\nexport const useBarAnimator = (\n  state: AnimationState,\n  columns: number,\n  interval: number\n): number[] => {\n  const indexRef = useRef(0)\n  const [currentFrame, setCurrentFrame] = useState<number[]>([])\n  const animationFrameId = useRef<number | null>(null)\n\n  // Memoize sequence generation\n  const sequence = useMemo(() => {\n    if (state === \"thinking\" || state === \"listening\") {\n      return generateListeningSequenceBar(columns)\n    } else if (state === \"connecting\" || state === \"initializing\") {\n      return generateConnectingSequenceBar(columns)\n    } else if (state === undefined || state === \"speaking\") {\n      return [new Array(columns).fill(0).map((_, idx) => idx)]\n    } else {\n      return [[]]\n    }\n  }, [state, columns])\n\n  useEffect(() => {\n    indexRef.current = 0\n    setCurrentFrame(sequence[0] || [])\n  }, [sequence])\n\n  useEffect(() => {\n    let startTime = performance.now()\n\n    const animate = (time: DOMHighResTimeStamp) => {\n      const timeElapsed = time - startTime\n\n      if (timeElapsed >= interval) {\n        indexRef.current = (indexRef.current + 1) % sequence.length\n        setCurrentFrame(sequence[indexRef.current] || [])\n        startTime = time\n      }\n\n      animationFrameId.current = requestAnimationFrame(animate)\n    }\n\n    animationFrameId.current = requestAnimationFrame(animate)\n\n    return () => {\n      if (animationFrameId.current !== null) {\n        cancelAnimationFrame(animationFrameId.current)\n      }\n    }\n  }, [interval, sequence])\n\n  return currentFrame\n}\n\n// Memoize sequence generators\nconst generateConnectingSequenceBar = (columns: number): number[][] => {\n  const seq = []\n  for (let x = 0; x < columns; x++) {\n    seq.push([x, columns - 1 - x])\n  }\n  return seq\n}\n\nconst generateListeningSequenceBar = (columns: number): number[][] => {\n  const center = Math.floor(columns / 2)\n  const noIndex = -1\n  return [[center], [noIndex]]\n}\n\nexport type AgentState =\n  | \"connecting\"\n  | \"initializing\"\n  | \"listening\"\n  | \"speaking\"\n  | \"thinking\"\n\nexport interface BarVisualizerProps\n  extends React.HTMLAttributes<HTMLDivElement> {\n  /** Voice assistant state */\n  state?: AgentState\n  /** Number of bars to display */\n  barCount?: number\n  /** Audio source */\n  mediaStream?: MediaStream | null\n  /** Min/max height as percentage */\n  minHeight?: number\n  maxHeight?: number\n  /** Enable demo mode with fake audio data */\n  demo?: boolean\n  /** Align bars from center instead of bottom */\n  centerAlign?: boolean\n}\n\nconst BarVisualizerComponent = React.forwardRef<\n  HTMLDivElement,\n  BarVisualizerProps\n>(\n  (\n    {\n      state,\n      barCount = 15,\n      mediaStream,\n      minHeight = 20,\n      maxHeight = 100,\n      demo = false,\n      centerAlign = false,\n      className,\n      style,\n      ...props\n    },\n    ref\n  ) => {\n    // Audio processing\n    const realVolumeBands = useMultibandVolume(mediaStream, {\n      bands: barCount,\n      loPass: 100,\n      hiPass: 200,\n    })\n\n    // Generate fake volume data for demo mode using refs to avoid state updates\n    const fakeVolumeBandsRef = useRef<number[]>(new Array(barCount).fill(0.2))\n    const [fakeVolumeBands, setFakeVolumeBands] = useState<number[]>(() =>\n      new Array(barCount).fill(0.2)\n    )\n    const fakeAnimationRef = useRef<number | undefined>(undefined)\n\n    // Animate fake volume bands for speaking and listening states\n    useEffect(() => {\n      if (!demo) return\n\n      if (state !== \"speaking\" && state !== \"listening\") {\n        const bands = new Array(barCount).fill(0.2)\n        fakeVolumeBandsRef.current = bands\n        setFakeVolumeBands(bands)\n        return\n      }\n\n      let lastUpdate = 0\n      const updateInterval = 50\n      const startTime = Date.now() / 1000\n\n      const updateFakeVolume = (timestamp: number) => {\n        if (timestamp - lastUpdate >= updateInterval) {\n          const time = Date.now() / 1000 - startTime\n          const newBands = new Array(barCount)\n\n          for (let i = 0; i < barCount; i++) {\n            const waveOffset = i * 0.5\n            const baseVolume = Math.sin(time * 2 + waveOffset) * 0.3 + 0.5\n            const randomNoise = Math.random() * 0.2\n            newBands[i] = Math.max(0.1, Math.min(1, baseVolume + randomNoise))\n          }\n\n          // Only update if values changed significantly\n          let hasChanged = false\n          for (let i = 0; i < barCount; i++) {\n            if (Math.abs(newBands[i] - fakeVolumeBandsRef.current[i]) > 0.05) {\n              hasChanged = true\n              break\n            }\n          }\n\n          if (hasChanged) {\n            fakeVolumeBandsRef.current = newBands\n            setFakeVolumeBands(newBands)\n          }\n\n          lastUpdate = timestamp\n        }\n\n        fakeAnimationRef.current = requestAnimationFrame(updateFakeVolume)\n      }\n\n      fakeAnimationRef.current = requestAnimationFrame(updateFakeVolume)\n\n      return () => {\n        if (fakeAnimationRef.current) {\n          cancelAnimationFrame(fakeAnimationRef.current)\n        }\n      }\n    }, [demo, state, barCount])\n\n    // Use fake or real volume data based on demo mode\n    const volumeBands = useMemo(\n      () => (demo ? fakeVolumeBands : realVolumeBands),\n      [demo, fakeVolumeBands, realVolumeBands]\n    )\n\n    // Animation sequencing\n    const highlightedIndices = useBarAnimator(\n      state,\n      barCount,\n      state === \"connecting\"\n        ? 2000 / barCount\n        : state === \"thinking\"\n          ? 150\n          : state === \"listening\"\n            ? 500\n            : 1000\n    )\n\n    return (\n      <div\n        ref={ref}\n        data-state={state}\n        className={cn(\n          \"relative flex justify-center gap-1.5\",\n          centerAlign ? \"items-center\" : \"items-end\",\n          \"bg-muted h-32 w-full overflow-hidden rounded-lg p-4\",\n          className\n        )}\n        style={{\n          ...style,\n        }}\n        {...props}\n      >\n        {volumeBands.map((volume, index) => {\n          const heightPct = Math.min(\n            maxHeight,\n            Math.max(minHeight, volume * 100 + 5)\n          )\n          const isHighlighted = highlightedIndices?.includes(index) ?? false\n\n          return (\n            <Bar\n              key={index}\n              heightPct={heightPct}\n              isHighlighted={isHighlighted}\n              state={state}\n            />\n          )\n        })}\n      </div>\n    )\n  }\n)\n\n// Memoized Bar component to prevent unnecessary re-renders\nconst Bar = React.memo<{\n  heightPct: number\n  isHighlighted: boolean\n  state?: AgentState\n}>(({ heightPct, isHighlighted, state }) => (\n  <div\n    data-highlighted={isHighlighted}\n    className={cn(\n      \"max-w-[12px] min-w-[8px] flex-1 transition-all duration-150\",\n      \"rounded-full\",\n      \"bg-border data-[highlighted=true]:bg-primary\",\n      state === \"speaking\" && \"bg-primary\",\n      state === \"thinking\" && isHighlighted && \"animate-pulse\"\n    )}\n    style={{\n      height: `${heightPct}%`,\n      animationDuration: state === \"thinking\" ? \"300ms\" : undefined,\n    }}\n  />\n))\n\nBar.displayName = \"Bar\"\n\n// Wrap the main component with React.memo for prop comparison optimization\nconst BarVisualizer = React.memo(\n  BarVisualizerComponent,\n  (prevProps, nextProps) => {\n    return (\n      prevProps.state === nextProps.state &&\n      prevProps.barCount === nextProps.barCount &&\n      prevProps.mediaStream === nextProps.mediaStream &&\n      prevProps.minHeight === nextProps.minHeight &&\n      prevProps.maxHeight === nextProps.maxHeight &&\n      prevProps.demo === nextProps.demo &&\n      prevProps.centerAlign === nextProps.centerAlign &&\n      prevProps.className === nextProps.className &&\n      JSON.stringify(prevProps.style) === JSON.stringify(nextProps.style)\n    )\n  }\n)\n\nBarVisualizerComponent.displayName = \"BarVisualizerComponent\"\nBarVisualizer.displayName = \"BarVisualizer\"\n\nexport { BarVisualizer }\n"
    },
    {
      "path": "components/ui/voice-picker.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport type { ElevenLabs } from \"@elevenlabs/elevenlabs-js\"\nimport { Check, ChevronsUpDown, Pause, Play } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport {\n  AudioPlayerProvider,\n  useAudioPlayer,\n} from \"@/components/ui/audio-player\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/components/ui/command\"\nimport { Orb } from \"@/components/ui/orb\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\n\ninterface VoicePickerProps {\n  voices: ElevenLabs.Voice[]\n  value?: string\n  onValueChange?: (value: string) => void\n  placeholder?: string\n  className?: string\n  open?: boolean\n  onOpenChange?: (open: boolean) => void\n}\n\nfunction VoicePicker({\n  voices,\n  value,\n  onValueChange,\n  placeholder = \"Select a voice...\",\n  className,\n  open,\n  onOpenChange,\n}: VoicePickerProps) {\n  const [internalOpen, setInternalOpen] = React.useState(false)\n  const isControlled = open !== undefined\n  const isOpen = isControlled ? open : internalOpen\n  const setIsOpen = isControlled ? onOpenChange : setInternalOpen\n\n  const selectedVoice = voices.find((v) => v.voiceId === value)\n\n  return (\n    <AudioPlayerProvider>\n      <Popover open={isOpen} onOpenChange={setIsOpen}>\n        <PopoverTrigger asChild>\n          <Button\n            variant=\"outline\"\n            role=\"combobox\"\n            aria-expanded={isOpen}\n            className={cn(\"w-full justify-between\", className)}\n          >\n            {selectedVoice ? (\n              <div className=\"flex items-center gap-2 overflow-hidden\">\n                <div className=\"relative size-6 shrink-0 overflow-visible\">\n                  <Orb agentState=\"thinking\" className=\"absolute inset-0\" />\n                </div>\n                <span className=\"truncate\">{selectedVoice.name}</span>\n              </div>\n            ) : (\n              placeholder\n            )}\n            <ChevronsUpDown className=\"ml-2 size-4 shrink-0 opacity-50\" />\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent className=\"w-[var(--radix-popover-trigger-width)] p-0\">\n          <Command>\n            <CommandInput placeholder=\"Search voices...\" />\n            <CommandList>\n              <CommandEmpty>No voice found.</CommandEmpty>\n              <CommandGroup>\n                {voices.map((voice) => (\n                  <VoicePickerItem\n                    key={voice.voiceId}\n                    voice={voice}\n                    isSelected={value === voice.voiceId}\n                    onSelect={() => {\n                      onValueChange?.(voice.voiceId!)\n                    }}\n                  />\n                ))}\n              </CommandGroup>\n            </CommandList>\n          </Command>\n        </PopoverContent>\n      </Popover>\n    </AudioPlayerProvider>\n  )\n}\n\ninterface VoicePickerItemProps {\n  voice: ElevenLabs.Voice\n  isSelected: boolean\n  onSelect: () => void\n}\n\nfunction VoicePickerItem({\n  voice,\n  isSelected,\n  onSelect,\n}: VoicePickerItemProps) {\n  const [isHovered, setIsHovered] = React.useState(false)\n  const player = useAudioPlayer()\n\n  const preview = voice.previewUrl\n  const audioItem = React.useMemo(\n    () => (preview ? { id: voice.voiceId!, src: preview, data: voice } : null),\n    [preview, voice]\n  )\n\n  const isPlaying =\n    audioItem && player.isItemActive(audioItem.id) && player.isPlaying\n\n  const handlePreview = React.useCallback(\n    async (e: React.MouseEvent) => {\n      e.preventDefault()\n      e.stopPropagation()\n\n      if (!audioItem) return\n\n      if (isPlaying) {\n        player.pause()\n      } else {\n        player.play(audioItem)\n      }\n    },\n    [audioItem, isPlaying, player]\n  )\n\n  return (\n    <CommandItem\n      value={voice.voiceId!}\n      onSelect={onSelect}\n      className=\"flex items-center gap-3\"\n    >\n      <div\n        className=\"relative z-10 size-8 shrink-0 cursor-pointer overflow-visible\"\n        onMouseEnter={() => setIsHovered(true)}\n        onMouseLeave={() => setIsHovered(false)}\n        onClick={handlePreview}\n      >\n        <Orb\n          agentState={isPlaying ? \"talking\" : undefined}\n          className=\"pointer-events-none absolute inset-0\"\n        />\n        {preview && isHovered && (\n          <div className=\"pointer-events-none absolute inset-0 flex size-8 shrink-0 items-center justify-center rounded-full bg-black/40 backdrop-blur-sm transition-opacity hover:bg-black/50\">\n            {isPlaying ? (\n              <Pause className=\"size-3 text-white\" />\n            ) : (\n              <Play className=\"size-3 text-white\" />\n            )}\n          </div>\n        )}\n      </div>\n\n      <div className=\"flex flex-1 flex-col gap-0.5\">\n        <span className=\"font-medium\">{voice.name}</span>\n        {voice.labels && (\n          <div className=\"text-muted-foreground flex items-center gap-1.5 text-xs\">\n            {voice.labels.accent && <span>{voice.labels.accent}</span>}\n            {voice.labels.gender && <span>•</span>}\n            {voice.labels.gender && (\n              <span className=\"capitalize\">{voice.labels.gender}</span>\n            )}\n            {voice.labels.age && <span>•</span>}\n            {voice.labels.age && (\n              <span className=\"capitalize\">{voice.labels.age}</span>\n            )}\n          </div>\n        )}\n      </div>\n\n      <Check\n        className={cn(\n          \"ml-auto size-4 shrink-0\",\n          isSelected ? \"opacity-100\" : \"opacity-0\"\n        )}\n      />\n    </CommandItem>\n  )\n}\n\nexport { VoicePicker, VoicePickerItem }\n"
    },
    {
      "path": "components/ui/voice-button.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { CheckIcon, XIcon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { LiveWaveform } from \"@/components/ui/live-waveform\"\n\nexport type VoiceButtonState =\n  | \"idle\"\n  | \"recording\"\n  | \"processing\"\n  | \"success\"\n  | \"error\"\n\nexport interface VoiceButtonProps\n  extends Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, \"onError\"> {\n  /**\n   * Current state of the voice button\n   * @default \"idle\"\n   */\n  state?: VoiceButtonState\n\n  /**\n   * Callback when button is clicked\n   */\n  onPress?: () => void\n\n  /**\n   * Content to display on the left side (label)\n   * Can be a string or ReactNode for custom components\n   */\n  label?: React.ReactNode\n\n  /**\n   * Content to display on the right side (e.g., keyboard shortcut)\n   * Can be a string or ReactNode for custom components\n   * @example \"⌥Space\" or <kbd>⌘K</kbd>\n   */\n  trailing?: React.ReactNode\n\n  /**\n   * Icon to display in the center when idle (for icon size buttons)\n   */\n  icon?: React.ReactNode\n\n  /**\n   * Custom variant for the button\n   * @default \"outline\"\n   */\n  variant?:\n    | \"default\"\n    | \"destructive\"\n    | \"outline\"\n    | \"secondary\"\n    | \"ghost\"\n    | \"link\"\n\n  /**\n   * Size of the button\n   * @default \"default\"\n   */\n  size?: \"default\" | \"sm\" | \"lg\" | \"icon\"\n\n  /**\n   * Custom className for the button\n   */\n  className?: string\n\n  /**\n   * Custom className for the waveform container\n   */\n  waveformClassName?: string\n\n  /**\n   * Duration in ms to show success/error states\n   * @default 1500\n   */\n  feedbackDuration?: number\n\n  /**\n   * Disable the button\n   */\n  disabled?: boolean\n}\n\nexport const VoiceButton = React.forwardRef<\n  HTMLButtonElement,\n  VoiceButtonProps\n>(\n  (\n    {\n      state = \"idle\",\n      onPress,\n      label,\n      trailing,\n      icon,\n      variant = \"outline\",\n      size = \"default\",\n      className,\n      waveformClassName,\n      feedbackDuration = 1500,\n      disabled,\n      onClick,\n      ...props\n    },\n    ref\n  ) => {\n    const [showFeedback, setShowFeedback] = React.useState(false)\n\n    React.useEffect(() => {\n      if (state === \"success\" || state === \"error\") {\n        setShowFeedback(true)\n        const timeout = setTimeout(\n          () => setShowFeedback(false),\n          feedbackDuration\n        )\n        return () => clearTimeout(timeout)\n      } else {\n        // Reset feedback when state changes away from success/error\n        setShowFeedback(false)\n      }\n    }, [state, feedbackDuration])\n\n    const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n      onClick?.(e)\n      onPress?.()\n    }\n\n    const isRecording = state === \"recording\"\n    const isProcessing = state === \"processing\"\n    const isSuccess = state === \"success\"\n    const isError = state === \"error\"\n\n    const buttonVariant = variant\n    const isDisabled = disabled || isProcessing\n\n    const displayLabel = label\n\n    const shouldShowWaveform = isRecording || isProcessing || showFeedback\n    const shouldShowTrailing = !shouldShowWaveform && trailing\n\n    return (\n      <Button\n        ref={ref}\n        type=\"button\"\n        variant={buttonVariant}\n        size={size}\n        onClick={handleClick}\n        disabled={isDisabled}\n        className={cn(\n          \"gap-2 transition-all duration-200\",\n          size === \"icon\" && \"relative\",\n          className\n        )}\n        aria-label={\"Voice Button\"}\n        {...props}\n      >\n        {size !== \"icon\" && displayLabel && (\n          <span className=\"inline-flex shrink-0 items-center justify-start\">\n            {displayLabel}\n          </span>\n        )}\n\n        <div\n          className={cn(\n            \"relative flex shrink-0 items-center justify-center overflow-hidden transition-all duration-300\",\n            size === \"icon\"\n              ? \"absolute inset-0 rounded-sm border-0\"\n              : \"h-5 w-24 rounded-sm border\",\n            isRecording\n              ? \"bg-primary/10 dark:bg-primary/5\"\n              : size === \"icon\"\n                ? \"bg-muted/50 border-0\"\n                : \"border-border bg-muted/50\",\n            waveformClassName\n          )}\n        >\n          {shouldShowWaveform && (\n            <LiveWaveform\n              active={isRecording}\n              processing={isProcessing || isSuccess}\n              barWidth={2}\n              barGap={1}\n              barRadius={4}\n              fadeEdges={false}\n              sensitivity={1.8}\n              smoothingTimeConstant={0.85}\n              height={20}\n              mode=\"static\"\n              className=\"animate-in fade-in absolute inset-0 h-full w-full duration-300\"\n            />\n          )}\n\n          {shouldShowTrailing && (\n            <div className=\"animate-in fade-in absolute inset-0 flex items-center justify-center duration-300\">\n              {typeof trailing === \"string\" ? (\n                <span className=\"text-muted-foreground px-1.5 font-mono text-[10px] font-medium select-none\">\n                  {trailing}\n                </span>\n              ) : (\n                trailing\n              )}\n            </div>\n          )}\n\n          {!shouldShowWaveform &&\n            !shouldShowTrailing &&\n            icon &&\n            size === \"icon\" && (\n              <div className=\"animate-in fade-in absolute inset-0 flex items-center justify-center duration-300\">\n                {icon}\n              </div>\n            )}\n\n          {isSuccess && showFeedback && (\n            <div className=\"animate-in fade-in bg-background/80 absolute inset-0 flex items-center justify-center duration-300\">\n              <span className=\"text-primary text-[10px] font-medium\">\n                <CheckIcon className=\"size-3.5\" />\n              </span>\n            </div>\n          )}\n\n          {/* Error Icon */}\n          {isError && showFeedback && (\n            <div className=\"animate-in fade-in bg-background/80 absolute inset-0 flex items-center justify-center duration-300\">\n              <span className=\"text-destructive text-[10px] font-medium\">\n                <XIcon className=\"size-3.5\" />\n              </span>\n            </div>\n          )}\n        </div>\n      </Button>\n    )\n  }\n)\n\nVoiceButton.displayName = \"VoiceButton\"\n"
    },
    {
      "path": "components/ui/conversation-bar.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { useConversation } from \"@elevenlabs/react\"\nimport {\n  ArrowUpIcon,\n  ChevronDown,\n  Keyboard,\n  Mic,\n  MicOff,\n  PhoneIcon,\n  XIcon,\n} from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { Card } from \"@/components/ui/card\"\nimport { LiveWaveform } from \"@/components/ui/live-waveform\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { Textarea } from \"@/components/ui/textarea\"\n\nexport interface ConversationBarProps {\n  /**\n   * ElevenLabs Agent ID to connect to\n   */\n  agentId: string\n\n  /**\n   * Custom className for the container\n   */\n  className?: string\n\n  /**\n   * Custom className for the waveform\n   */\n  waveformClassName?: string\n\n  /**\n   * Callback when conversation connects\n   */\n  onConnect?: () => void\n\n  /**\n   * Callback when conversation disconnects\n   */\n  onDisconnect?: () => void\n\n  /**\n   * Callback when an error occurs\n   */\n  onError?: (error: Error) => void\n\n  /**\n   * Callback when a message is received\n   */\n  onMessage?: (message: { source: \"user\" | \"ai\"; message: string }) => void\n\n  /**\n   * Callback when user sends a message\n   */\n  onSendMessage?: (message: string) => void\n}\n\nexport const ConversationBar = React.forwardRef<\n  HTMLDivElement,\n  ConversationBarProps\n>(\n  (\n    {\n      agentId,\n      className,\n      waveformClassName,\n      onConnect,\n      onDisconnect,\n      onError,\n      onMessage,\n      onSendMessage,\n    },\n    ref\n  ) => {\n    const [isMuted, setIsMuted] = React.useState(false)\n    const [agentState, setAgentState] = React.useState<\n      \"disconnected\" | \"connecting\" | \"connected\" | \"disconnecting\" | null\n    >(\"disconnected\")\n    const [keyboardOpen, setKeyboardOpen] = React.useState(false)\n    const [textInput, setTextInput] = React.useState(\"\")\n    const mediaStreamRef = React.useRef<MediaStream | null>(null)\n\n    const conversation = useConversation({\n      onConnect: () => {\n        onConnect?.()\n      },\n      onDisconnect: () => {\n        setAgentState(\"disconnected\")\n        onDisconnect?.()\n        setKeyboardOpen(false)\n      },\n      onMessage: (message) => {\n        onMessage?.(message)\n      },\n      micMuted: isMuted,\n      onError: (error: unknown) => {\n        console.error(\"Error:\", error)\n        setAgentState(\"disconnected\")\n        const errorObj =\n          error instanceof Error\n            ? error\n            : new Error(\n                typeof error === \"string\" ? error : JSON.stringify(error)\n              )\n        onError?.(errorObj)\n      },\n    })\n\n    const getMicStream = React.useCallback(async () => {\n      if (mediaStreamRef.current) return mediaStreamRef.current\n\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true })\n      mediaStreamRef.current = stream\n\n      return stream\n    }, [])\n\n    const startConversation = React.useCallback(async () => {\n      try {\n        setAgentState(\"connecting\")\n\n        await getMicStream()\n\n        await conversation.startSession({\n          agentId,\n          connectionType: \"webrtc\",\n          onStatusChange: (status) => setAgentState(status.status),\n        })\n      } catch (error) {\n        console.error(\"Error starting conversation:\", error)\n        setAgentState(\"disconnected\")\n        onError?.(error as Error)\n      }\n    }, [conversation, getMicStream, agentId, onError])\n\n    const handleEndSession = React.useCallback(() => {\n      conversation.endSession()\n      setAgentState(\"disconnected\")\n\n      if (mediaStreamRef.current) {\n        mediaStreamRef.current.getTracks().forEach((t) => t.stop())\n        mediaStreamRef.current = null\n      }\n    }, [conversation])\n\n    const toggleMute = React.useCallback(() => {\n      setIsMuted((prev) => !prev)\n    }, [])\n\n    const handleStartOrEnd = React.useCallback(() => {\n      if (agentState === \"connected\" || agentState === \"connecting\") {\n        handleEndSession()\n      } else if (agentState === \"disconnected\") {\n        startConversation()\n      }\n    }, [agentState, handleEndSession, startConversation])\n\n    const handleSendText = React.useCallback(() => {\n      if (!textInput.trim()) return\n\n      const messageToSend = textInput\n      conversation.sendUserMessage(messageToSend)\n      setTextInput(\"\")\n      onSendMessage?.(messageToSend)\n    }, [conversation, textInput, onSendMessage])\n\n    const isConnected = agentState === \"connected\"\n\n    const handleTextChange = React.useCallback(\n      (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n        const value = e.target.value\n        setTextInput(value)\n\n        if (value.trim() && isConnected) {\n          conversation.sendContextualUpdate(value)\n        }\n      },\n      [conversation, isConnected]\n    )\n\n    const handleKeyDown = React.useCallback(\n      (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n        if (e.key === \"Enter\" && !e.shiftKey) {\n          e.preventDefault()\n          handleSendText()\n        }\n      },\n      [handleSendText]\n    )\n\n    React.useEffect(() => {\n      return () => {\n        if (mediaStreamRef.current) {\n          mediaStreamRef.current.getTracks().forEach((t) => t.stop())\n        }\n      }\n    }, [])\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\"flex w-full items-end justify-center p-4\", className)}\n      >\n        <Card className=\"m-0 w-full gap-0 border p-0 shadow-lg\">\n          <div className=\"flex flex-col-reverse\">\n            <div>\n              {keyboardOpen && <Separator />}\n              <div className=\"flex items-center justify-between gap-2 p-2\">\n                <div className=\"h-8 w-[120px] md:h-10\">\n                  <div\n                    className={cn(\n                      \"flex h-full items-center gap-2 rounded-md py-1\",\n                      \"bg-foreground/5 text-foreground/70\"\n                    )}\n                  >\n                    <div className=\"h-full flex-1\">\n                      <div\n                        className={cn(\n                          \"relative flex h-full w-full shrink-0 items-center justify-center overflow-hidden rounded-sm\",\n                          waveformClassName\n                        )}\n                      >\n                        <LiveWaveform\n                          key={\n                            agentState === \"disconnected\" ? \"idle\" : \"active\"\n                          }\n                          active={isConnected && !isMuted}\n                          processing={agentState === \"connecting\"}\n                          barWidth={3}\n                          barGap={1}\n                          barRadius={4}\n                          fadeEdges={true}\n                          fadeWidth={24}\n                          sensitivity={1.8}\n                          smoothingTimeConstant={0.85}\n                          height={20}\n                          mode=\"static\"\n                          className={cn(\n                            \"h-full w-full transition-opacity duration-300\",\n                            agentState === \"disconnected\" && \"opacity-0\"\n                          )}\n                        />\n                        {agentState === \"disconnected\" && (\n                          <div className=\"absolute inset-0 flex items-center justify-center\">\n                            <span className=\"text-foreground/50 text-[10px] font-medium\">\n                              Customer Support\n                            </span>\n                          </div>\n                        )}\n                      </div>\n                    </div>\n                  </div>\n                </div>\n                <div className=\"flex items-center\">\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={toggleMute}\n                    aria-pressed={isMuted}\n                    className={cn(isMuted ? \"bg-foreground/5\" : \"\")}\n                    disabled={!isConnected}\n                  >\n                    {isMuted ? <MicOff /> : <Mic />}\n                  </Button>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={() => setKeyboardOpen((v) => !v)}\n                    aria-pressed={keyboardOpen}\n                    className=\"relative\"\n                    disabled={!isConnected}\n                  >\n                    <Keyboard\n                      className={\n                        \"h-5 w-5 transform-gpu transition-all duration-200 ease-[cubic-bezier(0.22,1,0.36,1)] \" +\n                        (keyboardOpen\n                          ? \"scale-75 opacity-0\"\n                          : \"scale-100 opacity-100\")\n                      }\n                    />\n                    <ChevronDown\n                      className={\n                        \"absolute inset-0 m-auto h-5 w-5 transform-gpu transition-all delay-50 duration-200 ease-[cubic-bezier(0.34,1.56,0.64,1)] \" +\n                        (keyboardOpen\n                          ? \"scale-100 opacity-100\"\n                          : \"scale-75 opacity-0\")\n                      }\n                    />\n                  </Button>\n                  <Separator orientation=\"vertical\" className=\"mx-1 -my-2.5\" />\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={handleStartOrEnd}\n                    disabled={agentState === \"disconnecting\"}\n                  >\n                    {isConnected || agentState === \"connecting\" ? (\n                      <XIcon className=\"h-5 w-5\" />\n                    ) : (\n                      <PhoneIcon className=\"h-5 w-5\" />\n                    )}\n                  </Button>\n                </div>\n              </div>\n            </div>\n\n            <div\n              className={cn(\n                \"overflow-hidden transition-all duration-300 ease-out\",\n                keyboardOpen ? \"max-h-[120px]\" : \"max-h-0\"\n              )}\n            >\n              <div className=\"relative px-2 pt-2 pb-2\">\n                <Textarea\n                  value={textInput}\n                  onChange={handleTextChange}\n                  onKeyDown={handleKeyDown}\n                  placeholder=\"Enter your message...\"\n                  className=\"min-h-[100px] resize-none border-0 pr-12 shadow-none focus-visible:ring-0\"\n                  disabled={!isConnected}\n                />\n                <Button\n                  size=\"icon\"\n                  variant=\"ghost\"\n                  onClick={handleSendText}\n                  disabled={!textInput.trim() || !isConnected}\n                  className=\"absolute right-3 bottom-3 h-8 w-8\"\n                >\n                  <ArrowUpIcon className=\"h-4 w-4\" />\n                </Button>\n              </div>\n            </div>\n          </div>\n        </Card>\n      </div>\n    )\n  }\n)\n\nConversationBar.displayName = \"ConversationBar\"\n"
    },
    {
      "path": "components/ui/x-scrollable.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport { useEffect, useRef, useState, type ReactNode } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface XScrollableProps {\n  children: ReactNode\n  className?: string\n  showScrollbar?: boolean\n  scrollbarTrackClassName?: string\n  scrollbarThumbClassName?: string\n  onScroll?: (\n    scrollLeft: number,\n    scrollWidth: number,\n    clientWidth: number\n  ) => void\n}\n\nexport function XScrollable({\n  children,\n  className,\n  showScrollbar = false,\n  scrollbarTrackClassName,\n  scrollbarThumbClassName,\n  onScroll,\n}: XScrollableProps) {\n  const scrollContainerRef = useRef<HTMLDivElement>(null)\n  const [showLeftShadow, setShowLeftShadow] = useState(false)\n  const [showRightShadow, setShowRightShadow] = useState(false)\n\n  useEffect(() => {\n    const scrollContainer = scrollContainerRef.current\n    if (!scrollContainer) return\n\n    const handleScroll = () => {\n      const { scrollLeft, scrollWidth, clientWidth } = scrollContainer\n      setShowLeftShadow(scrollLeft > 0)\n      setShowRightShadow(scrollLeft < scrollWidth - clientWidth)\n      onScroll?.(scrollLeft, scrollWidth, clientWidth)\n    }\n\n    handleScroll() // Initial check\n    scrollContainer.addEventListener(\"scroll\", handleScroll)\n\n    return () => {\n      scrollContainer.removeEventListener(\"scroll\", handleScroll)\n    }\n  }, [onScroll])\n\n  return (\n    <div className=\"relative\">\n      <div\n        ref={scrollContainerRef}\n        className={cn(\n          \"overflow-x-auto overflow-y-hidden\",\n          showScrollbar\n            ? \"scrollbar-thin scrollbar-track-transparent scrollbar-thumb-gray-300 hover:scrollbar-thumb-gray-400\"\n            : \"scrollbar-hide\",\n          className\n        )}\n      >\n        {children}\n      </div>\n      {showLeftShadow && (\n        <div className=\"from-background pointer-events-none absolute top-0 bottom-0 left-0 w-8 bg-gradient-to-r to-transparent\" />\n      )}\n      {showRightShadow && (\n        <div className=\"from-background pointer-events-none absolute top-0 right-0 bottom-0 w-8 bg-gradient-to-l to-transparent\" />\n      )}\n      {showScrollbar && (\n        <div\n          className={cn(\n            \"mt-1 h-1 rounded-full bg-gray-200\",\n            scrollbarTrackClassName\n          )}\n        >\n          <div\n            className={cn(\n              \"h-full rounded-full bg-gray-400\",\n              scrollbarThumbClassName\n            )}\n            style={{\n              width: scrollContainerRef.current\n                ? `${(scrollContainerRef.current.clientWidth / scrollContainerRef.current.scrollWidth) * 100}%`\n                : \"0%\",\n              transform: scrollContainerRef.current\n                ? `translateX(${(scrollContainerRef.current.scrollLeft / scrollContainerRef.current.clientWidth) * 100}%)`\n                : \"translateX(0%)\",\n            }}\n          />\n        </div>\n      )}\n    </div>\n  )\n}\n"
    },
    {
      "path": "components/ui/tabs.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport React, {\n  forwardRef,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  type ReactNode,\n} from \"react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { XScrollable } from \"@/components/ui/x-scrollable\"\n\n// Base Tabs component (Root)\nconst Tabs = forwardRef<\n  HTMLDivElement,\n  {\n    defaultValue?: string\n    value?: string\n    onValueChange?: (value: string) => void\n    className?: string\n    children?: ReactNode\n  }\n>(\n  (\n    { defaultValue, value, onValueChange, className, children, ...props },\n    ref\n  ) => {\n    const [activeValue, setActiveValue] = useState(value || defaultValue || \"\")\n\n    useEffect(() => {\n      if (value !== undefined) {\n        setActiveValue(value)\n      }\n    }, [value])\n\n    const handleValueChange = useCallback(\n      (newValue: string) => {\n        if (value === undefined) {\n          setActiveValue(newValue)\n        }\n        onValueChange?.(newValue)\n      },\n      [onValueChange, value]\n    )\n\n    return (\n      <div ref={ref} className={cn(\"tabs-container\", className)} {...props}>\n        {React.Children.map(children, (child) => {\n          if (!React.isValidElement(child)) return child\n\n          // Only pass tab-related props to tab components\n          const childType = child.type\n          const isTabComponent =\n            childType === TabsList ||\n            childType === TabsTrigger ||\n            childType === TabsContent ||\n            (typeof childType === \"function\" &&\n              ((childType as any).displayName === \"TabsList\" ||\n                (childType as any).displayName === \"TabsTrigger\" ||\n                (childType as any).displayName === \"TabsContent\"))\n\n          if (isTabComponent) {\n            return React.cloneElement(\n              child as React.ReactElement<{\n                activeValue?: string\n                onValueChange?: (value: string) => void\n                className?: string\n                children?: ReactNode\n                [key: string]: any\n              }>,\n              {\n                activeValue,\n                onValueChange: handleValueChange,\n              }\n            )\n          }\n\n          return child\n        })}\n      </div>\n    )\n  }\n)\nTabs.displayName = \"Tabs\"\n\n// TabsList component\nconst TabsList = forwardRef<\n  HTMLDivElement,\n  {\n    className?: string\n    activeValue?: string\n    onValueChange?: (value: string) => void\n    children?: ReactNode\n    showHoverEffect?: boolean\n    showActiveIndicator?: boolean\n    activeIndicatorPosition?: \"top\" | \"bottom\"\n    activeIndicatorOffset?: number\n    size?: \"sm\" | \"md\" | \"lg\"\n    variant?: \"default\" | \"pills\" | \"underlined\"\n    stretch?: boolean\n    ariaLabel?: string\n    showBottomBorder?: boolean\n    bottomBorderClassName?: string\n    activeIndicatorClassName?: string\n    hoverIndicatorClassName?: string\n  }\n>(\n  (\n    {\n      className,\n      activeValue,\n      onValueChange,\n      children,\n      showHoverEffect = true,\n      showActiveIndicator = true,\n      activeIndicatorPosition = \"bottom\",\n      activeIndicatorOffset = 0,\n      size = \"sm\",\n      variant = \"default\",\n      stretch = false,\n      ariaLabel = \"Tabs\",\n      showBottomBorder = false,\n      bottomBorderClassName,\n      activeIndicatorClassName,\n      hoverIndicatorClassName,\n      ...props\n    },\n    ref\n  ) => {\n    const [hoveredIndex, setHoveredIndex] = useState<number | null>(null)\n    const [hoverStyle, setHoverStyle] = useState({})\n    const [activeStyle, setActiveStyle] = useState({\n      left: \"0px\",\n      width: \"0px\",\n    })\n    const tabRefs = useRef<(HTMLDivElement | null)[]>([])\n    const scrollContainerRef = useRef<HTMLDivElement | null>(null)\n\n    // Find active tab index based on value\n    const activeIndex = React.Children.toArray(children).findIndex(\n      (child) =>\n        React.isValidElement(child) &&\n        (child as React.ReactElement<{ value: string }>).props.value ===\n          activeValue\n    )\n\n    // Update hover indicator position\n    useEffect(() => {\n      if (hoveredIndex !== null && showHoverEffect) {\n        const hoveredElement = tabRefs.current[hoveredIndex]\n        if (hoveredElement) {\n          const { offsetLeft, offsetWidth } = hoveredElement\n          setHoverStyle({\n            left: `${offsetLeft}px`,\n            width: `${offsetWidth}px`,\n          })\n        }\n      }\n    }, [hoveredIndex, showHoverEffect])\n\n    // Update active indicator position\n    const updateActiveIndicator = useCallback(() => {\n      if (showActiveIndicator && activeIndex >= 0) {\n        const activeElement = tabRefs.current[activeIndex]\n        if (activeElement) {\n          const { offsetLeft, offsetWidth } = activeElement\n          setActiveStyle({\n            left: `${offsetLeft}px`,\n            width: `${offsetWidth}px`,\n          })\n        }\n      }\n    }, [activeIndex, showActiveIndicator])\n\n    // Update active indicator on active tab change\n    useEffect(() => {\n      updateActiveIndicator()\n    }, [activeIndex, updateActiveIndicator])\n\n    // Initialize active indicator position\n    useEffect(() => {\n      requestAnimationFrame(updateActiveIndicator)\n    }, [updateActiveIndicator])\n\n    // Function to scroll tab to center\n    const scrollTabToCenter = (index: number) => {\n      const tabElement = tabRefs.current[index]\n      const scrollContainer = scrollContainerRef.current\n\n      if (tabElement && scrollContainer) {\n        const containerWidth = scrollContainer.offsetWidth\n        const tabWidth = tabElement.offsetWidth\n        const tabLeft = tabElement.offsetLeft\n\n        // Calculate position to center the tab\n        const scrollTarget = tabLeft - containerWidth / 2 + tabWidth / 2\n\n        // Smooth scroll to the target position\n        scrollContainer.scrollTo({\n          left: scrollTarget,\n          behavior: \"smooth\",\n        })\n      }\n    }\n\n    // Size classes\n    const sizeClasses = {\n      sm: \"h-[32px] text-sm\",\n      md: \"h-[40px] text-base\",\n      lg: \"h-[48px] text-lg\",\n    }\n\n    // Variant classes\n    const variantClasses = {\n      default: \"\",\n      pills: \"rounded-full\",\n      underlined: \"\",\n    }\n\n    // Active indicator classes\n    const activeIndicatorClasses = {\n      default: \"h-[4px] bg-primary dark:bg-primary\",\n      pills: \"hidden\",\n      underlined: \"h-[4px] bg-primary dark:bg-primary\",\n    }\n\n    // Hover indicator classes\n    const hoverIndicatorClasses = {\n      default: \"bg-muted dark:bg-muted rounded-[6px]\",\n      pills: \"bg-muted dark:bg-muted rounded-full\",\n      underlined: \"bg-muted dark:bg-muted rounded-[6px]\",\n    }\n\n    // Create a proper ref callback function\n    const setTabRef = useCallback(\n      (el: HTMLDivElement | null, index: number) => {\n        tabRefs.current[index] = el\n      },\n      []\n    )\n\n    // Save a reference to the scroll container when it's mounted\n    const handleScrollableRef = useCallback((node: HTMLDivElement | null) => {\n      if (node) {\n        // Find the actual scrollable div inside XScrollable\n        const scrollableDiv = node.querySelector(\n          'div[class*=\"overflow-x-auto\"]'\n        )\n        if (scrollableDiv) {\n          scrollContainerRef.current = scrollableDiv as HTMLDivElement\n        }\n      }\n    }, [])\n\n    // Center the active tab on initial render only\n    useEffect(() => {\n      if (activeIndex >= 0) {\n        // Use a small timeout to ensure the tabs are properly rendered\n        const timer = setTimeout(() => {\n          scrollTabToCenter(activeIndex)\n        }, 100)\n\n        return () => clearTimeout(timer)\n      }\n    }, []) // Empty dependency array means this only runs once on mount\n\n    return (\n      <div\n        ref={handleScrollableRef}\n        className={cn(\"relative\", className)}\n        role=\"tablist\"\n        aria-label={ariaLabel}\n        {...props}\n      >\n        <XScrollable showScrollbar={false}>\n          <div className={cn(\"relative\", showBottomBorder && \"pb-px\")}>\n            {/* Bottom border for the entire tab list */}\n            {showBottomBorder && (\n              <div\n                className={cn(\n                  \"bg-border dark:bg-border absolute right-0 bottom-0 left-0 h-px\",\n                  bottomBorderClassName\n                )}\n              />\n            )}\n\n            {/* Hover Indicator */}\n            {showHoverEffect && (\n              <div\n                className={cn(\n                  \"absolute z-0 flex items-center transition-all duration-300 ease-out\",\n                  sizeClasses[size],\n                  hoverIndicatorClasses[variant],\n                  hoverIndicatorClassName\n                )}\n                style={{\n                  ...hoverStyle,\n                  opacity: hoveredIndex !== null ? 1 : 0,\n                  transition: \"all 300ms ease-out\",\n                }}\n                aria-hidden=\"true\"\n              />\n            )}\n\n            {/* Tabs */}\n            <div\n              ref={ref}\n              className={cn(\n                \"relative flex items-center\",\n                stretch ? \"w-full\" : \"\",\n                variant === \"default\" ? \"space-x-[6px]\" : \"space-x-[2px]\"\n              )}\n            >\n              {React.Children.map(children, (child, index) => {\n                if (!React.isValidElement(child)) return child\n\n                const props = (\n                  child as React.ReactElement<{\n                    value: string\n                    disabled?: boolean\n                    label?: string\n                    className?: string\n                    activeClassName?: string\n                    inactiveClassName?: string\n                    disabledClassName?: string\n                  }>\n                ).props\n\n                const { value, disabled } = props\n                const isActive = value === activeValue\n\n                return (\n                  <div\n                    key={value}\n                    ref={(el) => setTabRef(el, index)}\n                    className={cn(\n                      \"mb-2 cursor-pointer px-3 py-2 transition-colors duration-300 sm:mb-1.5\",\n                      sizeClasses[size],\n                      variant === \"pills\" && isActive\n                        ? \"rounded-full bg-[#0e0f1114] dark:bg-[#ffffff1a]\"\n                        : \"\",\n                      disabled ? \"cursor-not-allowed opacity-50\" : \"\",\n                      stretch ? \"flex-1 text-center\" : \"\",\n                      isActive\n                        ? props.activeClassName ||\n                            \"text-foreground dark:text-foreground\"\n                        : props.inactiveClassName ||\n                            \"text-muted-foreground dark:text-muted-foreground\",\n                      disabled && props.disabledClassName,\n                      variantClasses[variant],\n                      props.className\n                    )}\n                    onMouseEnter={() => !disabled && setHoveredIndex(index)}\n                    onMouseLeave={() => setHoveredIndex(null)}\n                    onClick={() => {\n                      if (!disabled) {\n                        onValueChange?.(value)\n                        scrollTabToCenter(index)\n                      }\n                    }}\n                    role=\"tab\"\n                    aria-selected={isActive}\n                    aria-disabled={disabled}\n                    aria-controls={`tabpanel-${value}`}\n                    id={`tab-${value}`}\n                    tabIndex={isActive ? 0 : -1}\n                  >\n                    <div className=\"flex h-full items-center justify-center whitespace-nowrap\">\n                      {child}\n                    </div>\n                  </div>\n                )\n              })}\n            </div>\n\n            {/* Active Indicator */}\n            {showActiveIndicator && variant !== \"pills\" && activeIndex >= 0 && (\n              <div\n                className={cn(\n                  \"absolute z-10 transition-all duration-300 ease-out\",\n                  activeIndicatorClasses[variant],\n                  activeIndicatorPosition === \"top\"\n                    ? \"top-[-1px]\"\n                    : \"bottom-[-1px]\",\n                  activeIndicatorClassName\n                )}\n                style={{\n                  ...activeStyle,\n                  transition: \"all 300ms ease-out z-50\",\n                  [activeIndicatorPosition]: `${activeIndicatorOffset}px`,\n                }}\n                aria-hidden=\"true\"\n              />\n            )}\n          </div>\n        </XScrollable>\n      </div>\n    )\n  }\n)\nTabsList.displayName = \"TabsList\"\n\n// TabsTrigger component\nconst TabsTrigger = forwardRef<\n  HTMLDivElement,\n  {\n    value: string\n    disabled?: boolean\n    label?: string\n    className?: string\n    activeClassName?: string\n    inactiveClassName?: string\n    disabledClassName?: string\n    activeValue?: string\n    onValueChange?: (value: string) => void\n    children?: ReactNode\n  }\n>(\n  (\n    {\n      value,\n      disabled = false,\n      label,\n      className,\n      activeClassName,\n      inactiveClassName,\n      disabledClassName,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    return (\n      <div ref={ref} className={className} {...props}>\n        {label || children}\n      </div>\n    )\n  }\n)\n\nTabsTrigger.displayName = \"TabsTrigger\"\n\n// TabsContent component\nconst TabsContent = forwardRef<\n  HTMLDivElement,\n  {\n    value: string\n    className?: string\n    activeValue?: string\n    onValueChange?: (value: string) => void\n    children: ReactNode\n  }\n>(\n  (\n    {\n      value,\n      className,\n      activeValue,\n      onValueChange, // Destructure this prop to prevent it from being passed to the div\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    if (value !== activeValue) return null\n\n    return (\n      <div\n        ref={ref}\n        role=\"tabpanel\"\n        id={`tabpanel-${value}`}\n        aria-labelledby={`tab-${value}`}\n        className={className}\n        {...props}\n      >\n        {children}\n      </div>\n    )\n  }\n)\nTabsContent.displayName = \"TabsContent\"\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n"
    }
  ]
}