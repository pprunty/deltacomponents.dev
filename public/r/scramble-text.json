{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "scramble-text",
  "type": "registry:component",
  "files": [
    {
      "path": "registry/animations/scramble-text.tsx",
      "content": "'use client';\n\nimport { forwardRef, useImperativeHandle, useRef, useEffect } from 'react';\nimport { useScramble } from 'use-scramble';\nimport { cn } from '@/lib/utils';\n\ninterface ScrambleTextProps {\n  text: string;\n  scrambleSpeed?: number;\n  scrambledLetterCount?: number;\n  characters?: string;\n  className?: string;\n  scrambledClassName?: string;\n  autoStart?: boolean;\n  useIntersectionObserver?: boolean;\n  retriggerOnIntersection?: boolean;\n  intersectionThreshold?: number;\n  intersectionRootMargin?: string;\n  onStart?: () => void;\n  onComplete?: () => void;\n}\n\nexport interface ScrambleTextHandle {\n  start: () => void;\n  reset: () => void;\n}\n\nconst ScrambleText = forwardRef<ScrambleTextHandle, ScrambleTextProps>(\n  (\n    {\n      text,\n      scrambleSpeed = 80,\n      scrambledLetterCount = 2,\n      characters = 'abcdefghijklmnopqrstuvwxyz!@#$%^&*()_+',\n      className = '',\n      scrambledClassName = '',\n      autoStart = true,\n      useIntersectionObserver = false,\n      retriggerOnIntersection = false,\n      intersectionThreshold = 0.3,\n      intersectionRootMargin = '0px',\n      onStart,\n      onComplete,\n    },\n    ref,\n  ) => {\n    const containerRef = useRef<HTMLSpanElement>(null);\n    const hasCompletedOnce = useRef(false);\n\n    const { ref: scrambleRef, replay } = useScramble({\n      text,\n      speed: scrambleSpeed / 100, // Convert to 0-1 range\n      tick: scrambledLetterCount,\n      step: 1,\n      range: [65, 125], // Use default range (A-Z, a-z, and some special chars)\n      scramble: scrambledLetterCount,\n      playOnMount: autoStart && !useIntersectionObserver,\n      onAnimationStart: onStart,\n      onAnimationEnd: () => {\n        hasCompletedOnce.current = true;\n        onComplete?.();\n      },\n      overdrive: false, // Disable underscore characters\n    });\n\n    useImperativeHandle(ref, () => ({\n      start: () => replay(),\n      reset: () => {\n        // Reset internal state\n        hasCompletedOnce.current = false;\n        // Replay the animation\n        replay();\n      },\n    }));\n\n    // Handle Intersection Observer\n    useEffect(() => {\n      if (!useIntersectionObserver || !containerRef.current) return;\n\n      const observerOptions = {\n        root: null,\n        rootMargin: intersectionRootMargin,\n        threshold: intersectionThreshold,\n      };\n\n      const handleIntersection = (entries: IntersectionObserverEntry[]) => {\n        entries.forEach((entry) => {\n          if (entry.isIntersecting) {\n            if (!hasCompletedOnce.current || retriggerOnIntersection) {\n              replay();\n            }\n\n            // If not set to retrigger, unobserve after first animation\n            if (!retriggerOnIntersection) {\n              observer.unobserve(entry.target);\n            }\n          }\n        });\n      };\n\n      const observer = new IntersectionObserver(\n        handleIntersection,\n        observerOptions,\n      );\n      observer.observe(containerRef.current);\n\n      return () => {\n        if (containerRef.current) {\n          observer.unobserve(containerRef.current);\n        }\n      };\n    }, [\n      useIntersectionObserver,\n      retriggerOnIntersection,\n      intersectionThreshold,\n      intersectionRootMargin,\n      replay,\n    ]);\n\n    return (\n      <>\n        <span className=\"sr-only\">{text}</span>\n        <span\n          ref={containerRef}\n          className={cn(\"inline-block whitespace-pre-wrap\", className)}\n          aria-hidden=\"true\"\n        >\n          <span ref={scrambleRef} className={scrambledClassName} />\n        </span>\n      </>\n    );\n  },\n);\n\nScrambleText.displayName = 'ScrambleText';\nexport default ScrambleText;\n",
      "type": "registry:component"
    }
  ]
}