{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "scramble-text",
  "type": "registry:component",
  "author": "patrick prunty <https://www.patrickprunty.com>",
  "dependencies": [
    "use-scramble"
  ],
  "files": [
    {
      "path": "registry/animations/scramble-text.tsx",
      "content": "\"use client\"\n\nimport { forwardRef, useEffect, useImperativeHandle, useRef } from \"react\"\nimport { useScramble } from \"use-scramble\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface ScrambleTextProps {\n  /** The text that will be scrambled and displayed */\n  text: string\n  /** Speed of the scrambling effect (higher is faster) */\n  speed?: number\n  /** Optional custom CSS class for the container */\n  className?: string\n  /** Whether to start the animation automatically when mounted */\n  autoStart?: boolean\n  /** Callback function when animation completes */\n  onComplete?: () => void\n  /** Whether to use intersection observer to trigger animation when visible */\n  useIntersectionObserver?: boolean\n  /** Whether to retrigger animation when element comes into view again */\n  retriggerOnIntersection?: boolean\n  /** Threshold for intersection observer (0-1) */\n  intersectionThreshold?: number\n  /** Root margin for intersection observer */\n  intersectionRootMargin?: string\n  /** Whether to scramble text on hover */\n  scrambleOnHover?: boolean\n}\n\nexport interface ScrambleTextHandle {\n  start: () => void\n  reset: () => void\n}\n\nconst ScrambleText = forwardRef<ScrambleTextHandle, ScrambleTextProps>(\n  (\n    {\n      text,\n      speed = 80,\n      className = \"\",\n      autoStart = true,\n      onComplete,\n      useIntersectionObserver = false,\n      retriggerOnIntersection = false,\n      intersectionThreshold = 0.3,\n      intersectionRootMargin = \"0px\",\n      scrambleOnHover = false,\n    },\n    ref\n  ) => {\n    const containerRef = useRef<HTMLSpanElement>(null)\n    const hasCompletedOnce = useRef(false)\n\n    const { ref: scrambleRef, replay } = useScramble({\n      text,\n      speed: speed / 100, // Convert to 0-1 range\n      tick: 2,\n      step: 1,\n      range: [65, 125], // Use default range (A-Z, a-z, and some special chars)\n      scramble: 2,\n      playOnMount: autoStart && !useIntersectionObserver,\n      onAnimationEnd: () => {\n        hasCompletedOnce.current = true\n        onComplete?.()\n      },\n      overdrive: false, // Disable underscore characters\n    })\n\n    useImperativeHandle(ref, () => ({\n      start: () => replay(),\n      reset: () => {\n        // Reset internal state\n        hasCompletedOnce.current = false\n        // Replay the animation\n        replay()\n      },\n    }))\n\n    // Handle Intersection Observer\n    useEffect(() => {\n      if (!useIntersectionObserver || !containerRef.current) return\n\n      const observerOptions = {\n        root: null,\n        rootMargin: intersectionRootMargin,\n        threshold: intersectionThreshold,\n      }\n\n      const handleIntersection = (entries: IntersectionObserverEntry[]) => {\n        entries.forEach((entry) => {\n          if (entry.isIntersecting) {\n            if (!hasCompletedOnce.current || retriggerOnIntersection) {\n              replay()\n            }\n\n            // If not set to retrigger, unobserve after first animation\n            if (!retriggerOnIntersection) {\n              observer.unobserve(entry.target)\n            }\n          }\n        })\n      }\n\n      const observer = new IntersectionObserver(\n        handleIntersection,\n        observerOptions\n      )\n      observer.observe(containerRef.current)\n\n      return () => {\n        if (containerRef.current) {\n          observer.unobserve(containerRef.current)\n        }\n      }\n    }, [\n      useIntersectionObserver,\n      retriggerOnIntersection,\n      intersectionThreshold,\n      intersectionRootMargin,\n      replay,\n    ])\n\n    const handleMouseEnter = () => {\n      if (scrambleOnHover) {\n        replay()\n      }\n    }\n\n    return (\n      <>\n        <span className=\"sr-only\">{text}</span>\n        <span\n          ref={containerRef}\n          className={cn(\"inline-block whitespace-pre-wrap\", className)}\n          aria-hidden=\"true\"\n          onMouseEnter={scrambleOnHover ? handleMouseEnter : undefined}\n        >\n          <span ref={scrambleRef} />\n        </span>\n      </>\n    )\n  }\n)\n\nScrambleText.displayName = \"ScrambleText\"\nexport default ScrambleText\n",
      "type": "registry:component",
      "target": "components/delta/scramble-text.tsx"
    }
  ]
}