{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "marquee",
  "type": "registry:component",
  "author": "patrick prunty <https://www.patrickprunty.com>",
  "files": [
    {
      "path": "registry/components/marquee.tsx",
      "content": "\"use client\"\n\nimport { RefObject, useRef } from \"react\"\nimport {\n  motion,\n  SpringOptions,\n  useAnimationFrame,\n  useMotionValue,\n  useScroll,\n  useSpring,\n  useTransform,\n  useVelocity,\n} from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Custom wrap function\nconst wrap = (min: number, max: number, value: number): number => {\n  const range = max - min\n  return ((((value - min) % range) + range) % range) + min\n}\n\ninterface MarqueeProps {\n  children: React.ReactNode // The elements to be scrolled\n  className?: string // Additional CSS classes for the container\n  direction?: \"left\" | \"right\" | \"up\" | \"down\" // The direction of the marquee\n  baseVelocity?: number // The base velocity of the marquee in pixels per second\n  easing?: (value: number) => number // The easing function for the animation\n  slowdownOnHover?: boolean // Whether to slow down the animation on hover\n  slowDownFactor?: number // The factor to slow down the animation on hover\n  slowDownSpringConfig?: SpringOptions // The spring config for the slow down animation\n  useScrollVelocity?: boolean // Whether to use the scroll velocity to control the marquee speed\n  scrollAwareDirection?: boolean // Whether to adjust the direction based on the scroll direction\n  scrollSpringConfig?: SpringOptions // The spring config for the scroll velocity-based direction adjustment\n  scrollContainer?: RefObject<HTMLElement> | HTMLElement | null // The container to use for the scroll velocity\n  repeat?: number // The number of times to repeat the children.\n  draggable?: boolean // Whether to allow dragging of the marquee\n  dragSensitivity?: number // The sensitivity of the drag movement\n  dragVelocityDecay?: number // The decay of the drag velocity. This means how fast the velocity will gradually reduce to baseVelocity when we release the drag\n  dragAwareDirection?: boolean // Whether to adjust the direction based on the drag velocity\n  dragAngle?: number // The angle of the drag movement in degrees. This is useful if you eg. rotating your marquee by 45 degrees\n  grabCursor?: boolean // Whether to change the cursor to grabbing when dragging\n}\n\nfunction Marquee({\n  children,\n  className,\n  direction = \"right\",\n  baseVelocity = 5,\n  slowdownOnHover = false,\n  slowDownFactor = 0.3,\n  slowDownSpringConfig = { damping: 50, stiffness: 400 },\n  useScrollVelocity = false,\n  scrollAwareDirection = false,\n  scrollSpringConfig = { damping: 50, stiffness: 400 },\n  scrollContainer,\n  repeat = 3,\n  draggable = false,\n  dragSensitivity = 0.2,\n  dragVelocityDecay = 0.96,\n  dragAwareDirection = false,\n  dragAngle = 0,\n  grabCursor = false,\n  easing,\n}: MarqueeProps) {\n  const innerContainer = useRef<HTMLDivElement>(null)\n  const baseX = useMotionValue(0)\n  const baseY = useMotionValue(0)\n\n  const { scrollY } = useScroll({\n    container:\n      (scrollContainer as RefObject<HTMLDivElement>) || innerContainer.current,\n  })\n\n  const scrollVelocity = useVelocity(scrollY)\n  const smoothVelocity = useSpring(scrollVelocity, scrollSpringConfig)\n\n  const hoverFactorValue = useMotionValue(1)\n  const defaultVelocity = useMotionValue(1)\n\n  // Track if user is currently dragging\n  const isDragging = useRef(false)\n\n  // Store drag velocity\n  const dragVelocity = useRef(0)\n\n  const smoothHoverFactor = useSpring(hoverFactorValue, slowDownSpringConfig)\n\n  // Transform scroll velocity into a factor that affects marquee speed\n  const velocityFactor = useTransform(\n    useScrollVelocity ? smoothVelocity : defaultVelocity,\n    [0, 1000],\n    [0, 5],\n    {\n      clamp: false,\n    }\n  )\n\n  // Determine if movement is horizontal or vertical.\n  const isHorizontal = direction === \"left\" || direction === \"right\"\n\n  // Convert baseVelocity to the correct direction\n  const actualBaseVelocity =\n    direction === \"left\" || direction === \"up\" ? -baseVelocity : baseVelocity\n\n  // Reference to track if mouse is hovering\n  const isHovered = useRef(false)\n\n  // Direction factor for changing direction based on scroll or drag\n  const directionFactor = useRef(1)\n\n  // Transform baseX/baseY into a percentage for the transform\n  // The wrap function ensures the value stays between 0 and -100\n  const x = useTransform(baseX, (v) => {\n    // Apply easing if provided, otherwise use linear (v directly)\n    const wrappedValue = wrap(0, -100, v)\n    return `${easing ? easing(wrappedValue / -100) * -100 : wrappedValue}%`\n  })\n  const y = useTransform(baseY, (v) => {\n    // Apply easing if provided, otherwise use linear (v directly)\n    const wrappedValue = wrap(0, -100, v)\n    return `${easing ? easing(wrappedValue / -100) * -100 : wrappedValue}%`\n  })\n\n  useAnimationFrame((t, delta) => {\n    if (isDragging.current && draggable) {\n      if (isHorizontal) {\n        baseX.set(baseX.get() + dragVelocity.current)\n      } else {\n        baseY.set(baseY.get() + dragVelocity.current)\n      }\n\n      // Add decay to dragVelocity when not moving\n      // This will gradually reduce the velocity to zero when the pointer isn't moving\n      dragVelocity.current *= 0.9\n\n      // Stop completely if velocity is very small\n      if (Math.abs(dragVelocity.current) < 0.01) {\n        dragVelocity.current = 0\n      }\n\n      return\n    }\n\n    // Update hover factor\n    if (isHovered.current) {\n      hoverFactorValue.set(slowdownOnHover ? slowDownFactor : 1)\n    } else {\n      hoverFactorValue.set(1)\n    }\n\n    // Calculate regular movement\n    let moveBy =\n      directionFactor.current *\n      actualBaseVelocity *\n      (delta / 1000) *\n      smoothHoverFactor.get()\n\n    // Adjust movement based on scroll velocity if scrollAwareDirection is enabled\n    if (scrollAwareDirection && !isDragging.current) {\n      if (velocityFactor.get() < 0) {\n        directionFactor.current = -1\n      } else if (velocityFactor.get() > 0) {\n        directionFactor.current = 1\n      }\n    }\n\n    moveBy += directionFactor.current * moveBy * velocityFactor.get()\n\n    if (draggable) {\n      moveBy += dragVelocity.current\n\n      // Update direction based on drag direction if dragAwareDirection is true\n      if (dragAwareDirection && Math.abs(dragVelocity.current) > 0.1) {\n        // If dragging in negative direction, set directionFactor to -1\n        // If dragging in positive direction, set directionFactor to 1\n        directionFactor.current = Math.sign(dragVelocity.current)\n      }\n\n      // Gradually decay drag velocity back to zero\n      if (!isDragging.current && Math.abs(dragVelocity.current) > 0.01) {\n        dragVelocity.current *= dragVelocityDecay\n      } else if (!isDragging.current) {\n        dragVelocity.current = 0\n      }\n    }\n\n    if (isHorizontal) {\n      baseX.set(baseX.get() + moveBy)\n    } else {\n      baseY.set(baseY.get() + moveBy)\n    }\n  })\n\n  const lastPointerPosition = useRef({ x: 0, y: 0 })\n\n  const handlePointerDown = (e: React.PointerEvent) => {\n    if (!draggable)\n      return // Capture the pointer to receive events even when pointer moves outside\n    ;(e.currentTarget as HTMLElement).setPointerCapture(e.pointerId)\n\n    if (grabCursor) {\n      ;(e.currentTarget as HTMLElement).style.cursor = \"grabbing\"\n    }\n\n    isDragging.current = true\n    lastPointerPosition.current = { x: e.clientX, y: e.clientY }\n\n    // Pause automatic animation by setting velocity to 0\n    dragVelocity.current = 0\n  }\n\n  const handlePointerMove = (e: React.PointerEvent) => {\n    if (!draggable || !isDragging.current) return\n\n    const currentPosition = { x: e.clientX, y: e.clientY }\n\n    // Calculate delta from last position\n    const deltaX = currentPosition.x - lastPointerPosition.current.x\n    const deltaY = currentPosition.y - lastPointerPosition.current.y\n\n    // Convert dragAngle from degrees to radians\n    const angleInRadians = (dragAngle * Math.PI) / 180\n\n    // Calculate the projection of the movement along the angle direction\n    // Using the dot product of the movement vector and the direction vector\n    const directionX = Math.cos(angleInRadians)\n    const directionY = Math.sin(angleInRadians)\n\n    // Project the movement onto the angle direction\n    const projectedDelta = deltaX * directionX + deltaY * directionY\n\n    // Update drag velocity based on the projected movement\n    dragVelocity.current = projectedDelta * dragSensitivity\n\n    // Update last position\n    lastPointerPosition.current = currentPosition\n  }\n\n  const handlePointerUp = (e: React.PointerEvent) => {\n    if (!draggable) return // Release pointer capture\n    ;(e.currentTarget as HTMLElement).releasePointerCapture(e.pointerId)\n\n    isDragging.current = false\n  }\n\n  return (\n    <motion.div\n      className={cn(\"flex\", isHorizontal ? \"flex-row\" : \"flex-col\", className)}\n      onHoverStart={() => (isHovered.current = true)}\n      onHoverEnd={() => (isHovered.current = false)}\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n      onPointerCancel={handlePointerUp}\n      ref={innerContainer}\n    >\n      {Array.from({ length: repeat }, (_, i) => i).map((i) => (\n        <motion.div\n          key={i}\n          className={cn(\n            \"shrink-0\",\n            isHorizontal && \"flex\",\n            draggable && grabCursor && \"cursor-grab\"\n          )}\n          style={isHorizontal ? { x } : { y }}\n          aria-hidden={i > 0}\n        >\n          {children}\n        </motion.div>\n      ))}\n    </motion.div>\n  )\n}\n\nexport { Marquee }\nexport default Marquee\n",
      "type": "registry:component",
      "target": "/delta/marquee.tsx"
    }
  ]
}
