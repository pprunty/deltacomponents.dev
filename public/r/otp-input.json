{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "otp-input",
  "type": "registry:component",
  "author": "patrick prunty <https://www.patrickprunty.com>",
  "dependencies": ["zod"],
  "files": [
    {
      "path": "registry/inputs/otp-input.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { motion } from \"framer-motion\"\nimport type { z } from \"zod\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport type OtpInputType = \"numeric\" | \"alphabetic\" | \"alphanumeric\"\n\nexport interface OtpInputProps {\n  /** The label for the OTP input field */\n  label: string\n  /** The name of the OTP input field (used for form submission) */\n  name: string\n  /** Optional description text to display below the label */\n  description?: string\n  /** Optional hint text to display below the OTP input */\n  hint?: string\n  /** Error message to display (typically from Zod validation) */\n  error?: string\n  /** Whether the field is required */\n  required?: boolean\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean\n  /** Default value for the OTP input */\n  defaultValue?: string\n  /** Controlled value */\n  value?: string\n  /** Container className for the entire component */\n  containerClassName?: string\n  /** Label className for customizing the label */\n  labelClassName?: string\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: \"default\" | \"muted\"\n  /** Input variant - 'default' or 'pill' */\n  variant?: \"default\" | \"pill\"\n  /** Whether to show a colored border (only applies to pill variant) */\n  coloredBorder?: boolean\n  /** Input type validation - numeric, alphabetic, or alphanumeric */\n  inputType?: OtpInputType\n  /** Whether the OTP is in a success state (shows green border) */\n  success?: boolean\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<string>\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, value: string, error?: string) => void\n  /** Callback when OTP value changes */\n  onChange?: (value: string) => void\n  /** Callback when OTP is completed */\n  onComplete?: (value: string) => void\n  /** ID for the OTP input */\n  id?: string\n  /** Whether the OTP input is disabled */\n  disabled?: boolean\n  /** Length of the OTP code */\n  length?: number\n  /** Character to display when input is masked */\n  maskChar?: string\n  /** Whether to mask the input (like a password) */\n  mask?: boolean\n  /** Whether to auto-focus the first input on mount */\n  autoFocus?: boolean\n  /** Whether to render with a separator between groups */\n  separator?: boolean\n  /** Size of each group of digits */\n  groupSize?: number\n  /** Whether to automatically submit the form when OTP is completed */\n  autoSubmit?: boolean\n}\n\n/**\n * OtpInput component that integrates with Zod validation\n */\nexport function OtpInput({\n  label,\n  name,\n  description,\n  hint,\n  error,\n  required = false,\n  pending = false,\n  defaultValue = \"\",\n  value,\n  containerClassName,\n  labelClassName,\n  labelVariant = \"default\",\n  variant = \"default\",\n  coloredBorder = false,\n  inputType = \"alphanumeric\",\n  success = false,\n  schema,\n  onValidate,\n  onChange,\n  onComplete,\n  id = name,\n  disabled = false,\n  length = 6,\n  maskChar = \"â€¢\",\n  mask = false,\n  autoFocus = false,\n  separator = false,\n  groupSize = 3,\n  autoSubmit = false,\n}: OtpInputProps) {\n  const [localError, setLocalError] = React.useState<string | undefined>(error)\n  const [otpValue, setOtpValue] = React.useState<string[]>(\n    (value || defaultValue || \"\")\n      .split(\"\")\n      .slice(0, length)\n      .concat(Array(length).fill(\"\"))\n      .slice(0, length)\n  )\n  const [errorIndexes, setErrorIndexes] = React.useState<Set<number>>(new Set())\n  const [shakeAnimation, setShakeAnimation] = React.useState(false)\n  const inputRefs = React.useRef<(HTMLInputElement | null)[]>([])\n  const hasError = !!localError || !!error\n  const errorId = `error-${id}`\n  const hintId = `hint-${id}`\n  const formRef = React.useRef<HTMLFormElement | null>(null)\n\n  // Determine if component is controlled or uncontrolled\n  const isControlled = value !== undefined\n\n  // Update local error when prop changes\n  React.useEffect(() => {\n    setLocalError(error)\n  }, [error])\n\n  // Update OTP value when controlled value changes\n  React.useEffect(() => {\n    if (isControlled && value !== undefined) {\n      setOtpValue(\n        value\n          .split(\"\")\n          .slice(0, length)\n          .concat(Array(length).fill(\"\"))\n          .slice(0, length)\n      )\n    }\n  }, [isControlled, value, length])\n\n  // Find the closest form element\n  React.useEffect(() => {\n    if (autoSubmit) {\n      const input = inputRefs.current[0]\n      if (input) {\n        let element: HTMLElement | null = input\n        while (element && element.tagName !== \"FORM\") {\n          element = element.parentElement\n        }\n        formRef.current = element as HTMLFormElement\n      }\n    }\n  }, [autoSubmit])\n\n  // Input type validation function\n  const isValidInputType = (char: string): boolean => {\n    if (!inputType) return true\n\n    switch (inputType) {\n      case \"numeric\":\n        return /^\\d$/.test(char)\n      case \"alphabetic\":\n        return /^[a-zA-Z]$/.test(char)\n      case \"alphanumeric\":\n        return /^[a-zA-Z0-9]$/.test(char)\n      default:\n        return true\n    }\n  }\n\n  // Trigger error animation\n  const triggerErrorAnimation = (index: number) => {\n    setErrorIndexes((prev) => new Set(prev.add(index)))\n    setShakeAnimation(true)\n\n    // Clear only the shake animation after it completes, but keep the error border\n    setTimeout(() => {\n      setShakeAnimation(false)\n    }, 500)\n  }\n\n  // Handle validation with the provided schema\n  const validateOTP = React.useCallback(\n    (value: string) => {\n      if (!schema) return\n\n      // Only validate if all digits are entered or if the form has been submitted\n      if (value.length === length) {\n        const result = schema.safeParse(value)\n        if (!result.success) {\n          const errorMessage = result.error.errors[0]?.message || \"Invalid code\"\n          setLocalError(errorMessage)\n          onValidate?.(false, value, errorMessage)\n        } else {\n          setLocalError(undefined)\n          onValidate?.(true, value)\n        }\n      } else {\n        // Clear error while user is still typing\n        setLocalError(undefined)\n      }\n    },\n    [schema, onValidate, length]\n  )\n\n  // Handle input change\n  const handleChange = (\n    index: number,\n    e: React.ChangeEvent<HTMLInputElement>\n  ) => {\n    const value = e.target.value\n\n    // Handle paste event (detected by multiple characters)\n    if (value.length > 1) {\n      handlePaste(index, value)\n      return\n    }\n\n    // Check if the character meets the input type requirements\n    if (value && !isValidInputType(value)) {\n      triggerErrorAnimation(index)\n      return\n    }\n\n    // Clear error state for this index if valid input is entered\n    if (value && isValidInputType(value)) {\n      setErrorIndexes((prev) => {\n        const newSet = new Set(prev)\n        newSet.delete(index)\n        return newSet\n      })\n    }\n\n    // Update the OTP value\n    const newOtpValue = [...otpValue]\n    newOtpValue[index] = value\n    setOtpValue(newOtpValue)\n\n    // Move focus to the next input if a value was entered\n    if (value && index < length - 1) {\n      inputRefs.current[index + 1]?.focus()\n    }\n\n    // Call onChange with the new value - ensure it's a clean string\n    const newValue = newOtpValue.join(\"\")\n    onChange?.(newValue)\n\n    // Check if OTP is complete\n    if (newOtpValue.filter(Boolean).length === length) {\n      onComplete?.(newValue)\n\n      // Validate the complete OTP\n      if (schema) {\n        validateOTP(newValue)\n      }\n\n      // Auto-submit the form if enabled\n      if (autoSubmit && formRef.current) {\n        setTimeout(() => {\n          formRef.current?.requestSubmit()\n        }, 100)\n      }\n    }\n  }\n\n  // Handle paste event with dedicated handler\n  const handlePasteEvent = (\n    index: number,\n    e: React.ClipboardEvent<HTMLInputElement>\n  ) => {\n    e.preventDefault()\n    const pastedData = e.clipboardData.getData(\"text/plain\")\n    \n    if (pastedData) {\n      handlePaste(index, pastedData)\n    }\n  }\n\n  // Handle paste event\n  const handlePaste = (startIndex: number, pastedValue: string) => {\n    // Clean the pasted value - remove all whitespace and non-printable characters\n    let cleanedValue = pastedValue.replace(/\\s/g, \"\").trim()\n\n    // Filter characters based on input type\n    if (inputType) {\n      cleanedValue = cleanedValue\n        .split(\"\")\n        .filter((char) => isValidInputType(char))\n        .join(\"\")\n    }\n\n    // If no valid characters after filtering, trigger error animation\n    if (\n      cleanedValue.length === 0 &&\n      pastedValue.replace(/\\s/g, \"\").length > 0\n    ) {\n      triggerErrorAnimation(startIndex)\n      return\n    }\n\n    // Create a new OTP value array - clear existing values first for better UX\n    const newOtpValue = Array(length).fill(\"\")\n\n    // Fill in the OTP value with the pasted characters from the beginning\n    // This provides better UX when pasting a complete code\n    const charactersToFill = Math.min(cleanedValue.length, length)\n    for (let i = 0; i < charactersToFill; i++) {\n      newOtpValue[i] = cleanedValue[i]\n    }\n\n    setOtpValue(newOtpValue)\n\n    // Clear any previous error states since we're filling with new data\n    setErrorIndexes(new Set())\n\n    // Focus the appropriate input after pasting\n    if (charactersToFill === length) {\n      // If we filled all inputs, focus the last one\n      inputRefs.current[length - 1]?.focus()\n    } else {\n      // Focus the next empty input\n      inputRefs.current[charactersToFill]?.focus()\n    }\n\n    // Call onChange with the new value\n    const newValue = newOtpValue.join(\"\")\n    onChange?.(newValue)\n\n    // Check if OTP is complete and trigger onComplete\n    if (charactersToFill === length) {\n      onComplete?.(newValue)\n\n      // Validate the complete OTP\n      if (schema) {\n        validateOTP(newValue)\n      }\n\n      // Auto-submit the form if enabled\n      if (autoSubmit && formRef.current) {\n        setTimeout(() => {\n          formRef.current?.requestSubmit()\n        }, 100)\n      }\n    } else if (schema) {\n      // Validate partial input if schema exists\n      validateOTP(newValue)\n    }\n  }\n\n  // Handle key down event\n  const handleKeyDown = (\n    index: number,\n    e: React.KeyboardEvent<HTMLInputElement>\n  ) => {\n    // Move focus to the previous input on backspace if the current input is empty\n    if (e.key === \"Backspace\") {\n      if (!otpValue[index] && index > 0) {\n        inputRefs.current[index - 1]?.focus()\n\n        // Clear the previous input\n        const newOtpValue = [...otpValue]\n        newOtpValue[index - 1] = \"\"\n        setOtpValue(newOtpValue)\n\n        // Call onChange with the new value\n        onChange?.(newOtpValue.join(\"\"))\n      }\n\n      // Don't prevent default for backspace when there's content to delete\n      if (!otpValue[index]) {\n        e.preventDefault()\n      }\n    }\n\n    // Prevent arrow key navigation\n    else if (\n      e.key === \"ArrowRight\" ||\n      e.key === \"ArrowLeft\" ||\n      e.key === \"ArrowUp\" ||\n      e.key === \"ArrowDown\"\n    ) {\n      e.preventDefault()\n    }\n  }\n\n  // Handle focus event\n  const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {\n    // Select the input content on focus\n    e.target.select()\n  }\n\n  // Create input groups based on groupSize\n  const inputGroups = []\n  for (let i = 0; i < length; i += groupSize) {\n    const group = []\n    for (let j = 0; j < groupSize && i + j < length; j++) {\n      group.push(i + j)\n    }\n    inputGroups.push(group)\n  }\n\n  return (\n    <div\n      className={cn(\"group/field grid gap-2\", containerClassName)}\n      data-invalid={hasError}\n    >\n      <label\n        htmlFor={`${id}-0`}\n        className={cn(\n          \"text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive\",\n          labelVariant === \"muted\" && \"text-muted-foreground\",\n          labelClassName\n        )}\n      >\n        {label}\n        {required && <span aria-hidden=\"true\"> *</span>}\n      </label>\n\n      {description && (\n        <p className=\"text-sm text-muted-foreground\">{description}</p>\n      )}\n\n      <div className=\"flex items-center justify-center space-x-1.5 sm:space-x-2\">\n        {inputGroups.map((group, groupIndex) => (\n          <React.Fragment key={`group-${groupIndex}`}>\n            <div className=\"flex items-center space-x-1.5 sm:space-x-2\">\n              {group.map((index) => (\n                <div key={`input-${index}`} className=\"relative\">\n                  <motion.input\n                    ref={(el: HTMLInputElement | null) => {\n                      if (inputRefs.current) {\n                        inputRefs.current[index] = el\n                      }\n                    }}\n                    id={index === 0 ? `${id}-0` : `${id}-${index}`}\n                    name={index === 0 ? name : `${name}-${index}`}\n                    type=\"text\"\n                    inputMode={inputType === \"numeric\" ? \"tel\" : \"text\"}\n                    pattern={inputType === \"numeric\" ? \"[0-9]*\" : undefined}\n                    maxLength={1}\n                    autoComplete=\"off\"\n                    value={mask && otpValue[index] ? maskChar : otpValue[index]}\n                    onChange={(e) => handleChange(index, e)}\n                    onKeyDown={(e) => handleKeyDown(index, e)}\n                    onPaste={(e) => handlePasteEvent(index, e)}\n                    onFocus={handleFocus}\n                    disabled={pending || disabled}\n                    aria-invalid={hasError}\n                    aria-errormessage={hasError ? errorId : undefined}\n                    aria-describedby={hint ? hintId : undefined}\n                    aria-required={required}\n                    autoFocus={autoFocus && index === 0}\n                    animate={{\n                      x:\n                        errorIndexes.has(index) && shakeAnimation\n                          ? [-2, 2, -2, 2, 0]\n                          : 0,\n                      borderColor: success\n                        ? \"rgb(34 197 94)\" // green-500\n                        : errorIndexes.has(index)\n                          ? \"rgb(239 68 68)\" // red-500\n                          : undefined,\n                      scale: success ? [1, 1.02, 1] : 1,\n                    }}\n                    transition={{\n                      x:\n                        errorIndexes.has(index) && shakeAnimation\n                          ? { duration: 0.4, type: \"tween\" }\n                          : { duration: 0.4, type: \"spring\", stiffness: 300 },\n                      borderColor: { duration: 0.3 },\n                      scale: success\n                        ? { duration: 0.6, delay: 0 }\n                        : { duration: 0.6, delay: 0.1 },\n                    }}\n                    className={cn(\n                      \"w-11 h-12 sm:w-10 sm:h-12 bg-background text-center text-base sm:text-xl font-medium transition-colors\",\n                      \"focus:outline-none focus:ring-2 focus:ring-primary dark:ring-offset-black ring-offset-white\",\n                      // Default variant styling\n                      variant === \"default\" &&\n                        \"border border-input rounded-md shadow-[0px_2px_2px_rgba(0,0,0,0.03),_0px_4px_7px_rgba(0,0,0,0.02)]\",\n                      // Pill variant styling\n                      variant === \"pill\" &&\n                        \"bg-muted border-0 rounded-lg focus:ring-offset-2\",\n                      variant === \"pill\" &&\n                        coloredBorder &&\n                        \"border-2 border-primary\",\n                      // Success styling - remove focus ring for consistent appearance\n                      success &&\n                        \"border-2 border-green-500 focus:ring-0 focus:ring-transparent\",\n                      // Error styling for individual inputs\n                      errorIndexes.has(index) &&\n                        \"border-destructive focus:ring-destructive\",\n                      // Global error styling\n                      \"group-data-[invalid=true]/field:border-destructive focus-visible:group-data-[invalid=true]/field:ring-destructive\"\n                    )}\n                  />\n                </div>\n              ))}\n            </div>\n            {separator && groupIndex < inputGroups.length - 1 && (\n              <div className=\"text-muted-foreground text-base sm:text-lg font-medium\">\n                -\n              </div>\n            )}\n          </React.Fragment>\n        ))}\n      </div>\n\n      {/* Hidden input for form submission with the complete value */}\n      <input\n        type=\"hidden\"\n        name={name}\n        value={otpValue.join(\"\")}\n        data-testid={`${id}-hidden`}\n      />\n\n      {hint && !hasError && (\n        <p id={hintId} className=\"text-xs text-muted-foreground mt-1\">\n          {hint}\n        </p>\n      )}\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-sm\">\n          {localError || error}\n        </p>\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "/components/delta/inputs/otp-input.tsx"
    }
  ]
}
