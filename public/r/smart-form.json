{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "smart-form",
  "type": "registry:block",
  "dependencies": [
    "zod",
    "utils"
  ],
  "registryDependencies": [
    "text-input",
    "checkbox-input",
    "select-input",
    "radio-input",
    "switch-input",
    "textarea-input",
    "date-input",
    "file-input",
    "otp-input",
    "tags-input"
  ],
  "files": [
    {
      "path": "registry/blocks/smart-form.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { z } from 'zod';\nimport { Button } from '@/components/ui/button';\nimport { TextInput } from '@/registry/inputs/text-input';\nimport { CheckboxInput } from '@/registry/inputs/checkbox-input';\nimport { SelectInput } from '@/registry/inputs/select-input';\nimport { RadioInput } from '@/registry/inputs/radio-input';\nimport { SwitchInput } from '@/registry/inputs/switch-input';\nimport { TextareaInput } from '@/registry/inputs/textarea-input';\nimport { DateInput } from '@/registry/inputs/date-input';\nimport { FileInput } from '@/registry/inputs/file-input';\nimport { OtpInput } from '@/registry/inputs/otp-input';\nimport { TagsInput } from '@/registry/inputs/tags-input';\nimport { cn } from '@/lib/utils';\n\n// Field types\nexport type FieldType =\n  | 'text'\n  | 'email'\n  | 'password'\n  | 'number'\n  | 'tel'\n  | 'url'\n  | 'checkbox'\n  | 'select'\n  | 'radio'\n  | 'switch'\n  | 'textarea'\n  | 'date'\n  | 'file'\n  | 'otp'\n  | 'tags'\n  | 'custom';\n\n// Variant types for different inputs\ntype DefaultVariant = 'default' | 'pill';\ntype SwitchVariant = 'pill' | 'rectangular';\n\n// Base field definition\ninterface BaseFieldDefinition {\n  name: string;\n  label: string;\n  type: FieldType;\n  required?: boolean;\n  disabled?: boolean;\n  description?: string;\n  hint?: string;\n  labelVariant?: 'default' | 'muted';\n  className?: string;\n  hidden?: boolean | ((values: Record<string, any>) => boolean);\n  // New properties for field grouping and layout\n  group?: string;\n  width?: string | number;\n}\n\n// Text field definition\ninterface TextFieldDefinition extends BaseFieldDefinition {\n  type: 'text' | 'email' | 'password' | 'number' | 'tel' | 'url';\n  placeholder?: string;\n  defaultValue?: string;\n  variant?: DefaultVariant;\n}\n\n// Checkbox field definition\ninterface CheckboxFieldDefinition extends BaseFieldDefinition {\n  type: 'checkbox';\n  defaultChecked?: boolean;\n  variant?: DefaultVariant;\n}\n\n// Select field definition\ninterface SelectFieldDefinition extends BaseFieldDefinition {\n  type: 'select';\n  options: { value: string; label: string; disabled?: boolean }[];\n  placeholder?: string;\n  defaultValue?: string;\n  variant?: DefaultVariant;\n}\n\n// Radio field definition\ninterface RadioFieldDefinition extends BaseFieldDefinition {\n  type: 'radio';\n  options: {\n    value: string;\n    label: string;\n    description?: string;\n    disabled?: boolean;\n  }[];\n  orientation?: 'vertical' | 'horizontal';\n  defaultValue?: string;\n  variant?: DefaultVariant;\n}\n\n// Switch field definition\ninterface SwitchFieldDefinition extends BaseFieldDefinition {\n  type: 'switch';\n  defaultChecked?: boolean;\n  variant?: SwitchVariant;\n}\n\n// Textarea field definition\ninterface TextareaFieldDefinition extends BaseFieldDefinition {\n  type: 'textarea';\n  placeholder?: string;\n  rows?: number;\n  defaultValue?: string;\n  variant?: DefaultVariant;\n  size?: 'sm' | 'md' | 'lg';\n}\n\n// Date field definition\ninterface DateFieldDefinition extends BaseFieldDefinition {\n  type: 'date';\n  placeholder?: string;\n  defaultValue?: Date;\n  minDate?: Date;\n  maxDate?: Date;\n  dateFormat?: string;\n  variant?: DefaultVariant;\n}\n\n// File field definition\ninterface FileFieldDefinition extends BaseFieldDefinition {\n  type: 'file';\n  accept?: string;\n  multiple?: boolean;\n  maxSize?: number;\n  maxFiles?: number;\n  showPreviews?: boolean;\n  showIcons?: boolean;\n  variant?: DefaultVariant;\n}\n\n// OTP field definition\nexport interface OtpFieldDefinition extends BaseFieldDefinition {\n  type: 'otp';\n  length?: number;\n  maskChar?: string;\n  mask?: boolean;\n  autoFocus?: boolean;\n  separator?: boolean;\n  groupSize?: number;\n  autoSubmit?: boolean;\n  placeholder?: string;\n  onComplete?: (value: string) => void;\n  variant?: DefaultVariant;\n}\n\n// Tags field definition\ninterface TagsFieldDefinition extends BaseFieldDefinition {\n  type: 'tags';\n  defaultValue?: string[];\n  variant?: DefaultVariant;\n  triggerKey?: 'Enter' | 'Space' | 'Comma';\n}\n\n// Custom field definition\ninterface CustomFieldDefinition extends BaseFieldDefinition {\n  type: 'custom';\n  variant?: DefaultVariant;\n}\n\n// Union of all field definitions\nexport type FieldDefinition =\n  | TextFieldDefinition\n  | CheckboxFieldDefinition\n  | SelectFieldDefinition\n  | RadioFieldDefinition\n  | SwitchFieldDefinition\n  | TextareaFieldDefinition\n  | DateFieldDefinition\n  | FileFieldDefinition\n  | OtpFieldDefinition\n  | TagsFieldDefinition\n  | CustomFieldDefinition;\n\n// Form props\nexport interface SmartFormProps {\n  fields: FieldDefinition[];\n  schema: z.ZodSchema<any>;\n  onSubmit: (data: any) => Promise<void> | void;\n  submitText?: string;\n  cancelText?: string;\n  onCancel?: () => void;\n  className?: string;\n  fieldClassName?: string;\n  submitClassName?: string;\n  cancelClassName?: string;\n  layout?: 'vertical' | 'horizontal' | 'grid';\n  columns?: number;\n  gap?: number;\n  loading?: boolean;\n  defaultValues?: Record<string, any>;\n  successMessage?: string;\n  errorMessage?: string;\n  resetOnSuccess?: boolean;\n  id?: string;\n  hideSubmitButton?: boolean;\n  // Add this new prop for custom field rendering\n  renderCustomField?: (\n    field: FieldDefinition,\n    formState: any,\n    handleChange: (name: string, value: any) => void,\n  ) => React.ReactNode;\n}\n\nexport function SmartForm({\n  fields,\n  schema,\n  onSubmit,\n  submitText = 'Submit',\n  cancelText = 'Cancel',\n  onCancel,\n  className,\n  fieldClassName,\n  submitClassName,\n  cancelClassName,\n  layout = 'vertical',\n  columns = 1,\n  gap = 6,\n  loading = false,\n  defaultValues = {},\n  successMessage,\n  errorMessage,\n  resetOnSuccess = false,\n  id,\n  hideSubmitButton = false,\n  renderCustomField,\n}: SmartFormProps) {\n  // Use a ref to store the initial defaultValues to prevent re-renders\n  const initialDefaultValuesRef = React.useRef(defaultValues);\n  // Use a ref to track submission in progress to prevent duplicate submissions\n  const isSubmittingRef = React.useRef(false);\n  // Reference to the form element\n  const formRef = React.useRef<HTMLFormElement>(null);\n\n  const [formState, setFormState] = React.useState<{\n    values: Record<string, any>;\n    errors: Record<string, string>;\n    touched: Record<string, boolean>;\n    isSubmitting: boolean;\n    isSubmitted: boolean;\n    isSuccess: boolean;\n    isError: boolean;\n    errorMessage?: string;\n    successMessage?: string;\n  }>({\n    values: { ...initialDefaultValuesRef.current },\n    errors: {},\n    touched: {},\n    isSubmitting: false,\n    isSubmitted: false,\n    isSuccess: false,\n    isError: false,\n  });\n\n  // Only update values from defaultValues on mount or when explicitly reset\n  const resetForm = React.useCallback(\n    (newValues = initialDefaultValuesRef.current) => {\n      setFormState((prev) => ({\n        ...prev,\n        values: { ...newValues },\n        errors: {},\n        touched: {},\n        isSubmitted: false,\n        isSuccess: false,\n        isError: false,\n        errorMessage: undefined,\n        successMessage: undefined,\n      }));\n    },\n    [],\n  );\n\n  // Handle form submission\n  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n\n    // Prevent duplicate submissions\n    if (isSubmittingRef.current) {\n      return;\n    }\n\n    setFormState((prev) => ({\n      ...prev,\n      isSubmitting: true,\n      isSubmitted: true,\n      isSuccess: false,\n      isError: false,\n    }));\n\n    // Set the ref to true to block any parallel submissions\n    isSubmittingRef.current = true;\n\n    try {\n      // Validate form data against schema\n      const result = schema.safeParse(formState.values);\n\n      if (!result.success) {\n        // Format errors\n        const formattedErrors: Record<string, string> = {};\n        const formattedError = result.error.format() as unknown as {\n          [key: string]: { _errors: string[] };\n        };\n\n        // Extract error messages for each field\n        Object.keys(formattedError).forEach((key) => {\n          if (key !== '_errors' && formattedError[key]?._errors?.length) {\n            formattedErrors[key] = formattedError[key]._errors[0];\n          }\n        });\n\n        setFormState((prev) => ({\n          ...prev,\n          errors: formattedErrors,\n          isSubmitting: false,\n          isError: true,\n          errorMessage: errorMessage || 'Please fix the errors in the form',\n        }));\n\n        // Reset the submitting ref\n        isSubmittingRef.current = false;\n        return;\n      }\n\n      // Call onSubmit with validated data\n      await onSubmit(result.data);\n\n      // Update form state on success\n      setFormState((prev) => ({\n        ...prev,\n        isSubmitting: false,\n        isSuccess: true,\n        isError: false,\n        successMessage: successMessage || 'Form submitted successfully',\n      }));\n\n      // Reset form if needed\n      if (resetOnSuccess) {\n        resetForm();\n      }\n    } catch (error) {\n      // Handle submission errors\n      setFormState((prev) => ({\n        ...prev,\n        isSubmitting: false,\n        isError: true,\n        errorMessage:\n          errorMessage || 'An error occurred while submitting the form',\n      }));\n    } finally {\n      // Always reset the submitting ref to ensure future submissions are possible\n      isSubmittingRef.current = false;\n    }\n  };\n\n  // Handle field change - use a memoized callback to prevent recreating on every render\n  const handleChange = React.useCallback((name: string, value: any) => {\n    setFormState((prev) => {\n      // Only update if the value has actually changed\n      if (prev.values[name] === value) {\n        return prev;\n      }\n\n      return {\n        ...prev,\n        values: {\n          ...prev.values,\n          [name]: value,\n        },\n        touched: {\n          ...prev.touched,\n          [name]: true,\n        },\n      };\n    });\n  }, []);\n\n  // Validate a single field - memoized to prevent recreating on every render\n  const validateField = React.useCallback(\n    (name: string, value: any) => {\n      try {\n        // Create a partial schema for just this field\n        const fieldSchema = z.object({\n          [name]: (schema as any).shape?.[name] || z.any(),\n        });\n\n        // Validate the field\n        const result = fieldSchema.safeParse({ [name]: value });\n\n        if (!result.success) {\n          const error = result.error.format()[name]?._errors[0];\n          setFormState((prev) => ({\n            ...prev,\n            errors: {\n              ...prev.errors,\n              [name]: error || 'Invalid value',\n            },\n          }));\n        } else {\n          // Clear error if validation passes\n          setFormState((prev) => {\n            // Only update if there was an error before\n            if (!prev.errors[name]) {\n              return prev;\n            }\n\n            const newErrors = { ...prev.errors };\n            delete newErrors[name];\n\n            return {\n              ...prev,\n              errors: newErrors,\n            };\n          });\n        }\n      } catch (error) {\n        // If there's an error in validation, don't update the error state\n        console.error('Error validating field:', error);\n      }\n    },\n    [schema],\n  );\n\n  // Render form layout\n  const getFormLayoutClassName = () => {\n    switch (layout) {\n      case 'horizontal':\n        return 'flex flex-wrap items-start';\n      case 'grid':\n        return `grid grid-cols-1 md:grid-cols-${columns} gap-${gap}`;\n      case 'vertical':\n      default:\n        return 'flex flex-col space-y-8';\n    }\n  };\n\n  // Handle OTP specific logic by patching autoSubmit\n  const patchedFields = React.useMemo(() => {\n    return fields.map((field) => {\n      if (field.type === 'otp' && field.autoSubmit) {\n        // Create a safe deep clone of the field\n        const otpField = { ...field } as OtpFieldDefinition;\n\n        // Store the original onComplete handler\n        const originalOnComplete = otpField.onComplete;\n\n        // Create a new onComplete handler that safely submits the form\n        otpField.onComplete = (value: string) => {\n          // Call the original handler if it exists\n          if (originalOnComplete) {\n            originalOnComplete(value);\n          }\n\n          // Only submit if not already submitting\n          if (!isSubmittingRef.current && formRef.current) {\n            // Use a short delay to allow React to process state updates\n            setTimeout(() => {\n              formRef.current?.requestSubmit();\n            }, 10);\n          }\n        };\n\n        return otpField;\n      }\n      return field;\n    });\n  }, [fields]);\n\n  // Memoize the visible fields to prevent unnecessary re-renders\n  const visibleFields = React.useMemo(() => {\n    return patchedFields.filter((field) => {\n      if (typeof field.hidden === 'function') {\n        return !field.hidden(formState.values);\n      }\n      return !field.hidden;\n    });\n  }, [patchedFields, formState.values]);\n\n  // Group fields by their group property\n  const groupedFields = React.useMemo(() => {\n    const groups: Record<string, FieldDefinition[]> = {};\n    const ungroupedFields: FieldDefinition[] = [];\n\n    visibleFields.forEach((field) => {\n      if (field.group) {\n        if (!groups[field.group]) {\n          groups[field.group] = [];\n        }\n        groups[field.group].push(field);\n      } else {\n        ungroupedFields.push(field);\n      }\n    });\n\n    return { groups, ungroupedFields };\n  }, [visibleFields]);\n\n  // Render form fields - memoized to prevent recreating on every render\n  const renderField = React.useCallback(\n    (field: FieldDefinition) => {\n      // Handle custom field rendering if provided\n      if (field.type === 'custom' && renderCustomField) {\n        return renderCustomField(\n          field,\n          { values: formState.values, errors: formState.errors },\n          handleChange,\n        );\n      }\n\n      const commonProps = {\n        label: field.label,\n        name: field.name,\n        required: field.required,\n        disabled: field.disabled || loading || formState.isSubmitting,\n        description: field.description,\n        hint: field.hint,\n        labelVariant: field.labelVariant,\n        error: formState.errors[field.name],\n        className: cn(fieldClassName, field.className),\n      };\n\n      // Handle variant prop separately for each component type\n      switch (field.type) {\n        case 'text':\n        case 'email':\n        case 'password':\n        case 'number':\n        case 'tel':\n        case 'url':\n          return (\n            <TextInput\n              {...commonProps}\n              type={field.type}\n              placeholder={field.placeholder}\n              defaultValue={formState.values[field.name] || ''}\n              onChange={(e) => handleChange(field.name, e.target.value)}\n              variant={field.variant as 'default' | 'pill'}\n            />\n          );\n        case 'checkbox':\n          return (\n            <CheckboxInput\n              {...commonProps}\n              defaultChecked={formState.values[field.name] || false}\n              onCheckedChange={(checked) => handleChange(field.name, checked)}\n            />\n          );\n        case 'select':\n          return (\n            <SelectInput\n              {...commonProps}\n              options={field.options}\n              placeholder={field.placeholder}\n              defaultValue={formState.values[field.name] || ''}\n              onValueChange={(value) => handleChange(field.name, value)}\n              variant={field.variant as 'default' | 'pill'}\n            />\n          );\n        case 'radio':\n          return (\n            <RadioInput\n              {...commonProps}\n              options={field.options}\n              orientation={field.orientation}\n              defaultValue={formState.values[field.name] || ''}\n              onValueChange={(value) => handleChange(field.name, value)}\n            />\n          );\n        case 'switch':\n          const switchVariant: 'pill' | 'rectangular' =\n            field.variant === 'pill' ? 'pill' : 'rectangular';\n          return (\n            <SwitchInput\n              {...commonProps}\n              defaultChecked={formState.values[field.name] || false}\n              onCheckedChange={(checked) => handleChange(field.name, checked)}\n              variant={switchVariant}\n            />\n          );\n        case 'textarea':\n          return (\n            <TextareaInput\n              {...commonProps}\n              placeholder={field.placeholder}\n              rows={field.rows}\n              defaultValue={formState.values[field.name] || ''}\n              onChange={(e) => handleChange(field.name, e.target.value)}\n              variant={field.variant as 'default' | 'pill'}\n            />\n          );\n        case 'date':\n          return (\n            <DateInput\n              {...commonProps}\n              placeholder={field.placeholder}\n              defaultValue={formState.values[field.name]}\n              minDate={field.minDate}\n              maxDate={field.maxDate}\n              dateFormat={field.dateFormat}\n              onValueChange={(date) => handleChange(field.name, date)}\n              variant={field.variant as 'default' | 'pill'}\n            />\n          );\n        case 'file':\n          return (\n            <FileInput\n              {...commonProps}\n              accept={field.accept}\n              multiple={field.multiple}\n              maxSize={field.maxSize}\n              maxFiles={field.maxFiles}\n              showPreviews={field.showPreviews}\n              showIcons={field.showIcons}\n              onFilesSelected={(files) =>\n                handleChange(field.name, field.multiple ? files : files[0])\n              }\n              variant={field.variant as 'default' | 'pill'}\n            />\n          );\n        case 'otp':\n          return (\n            <OtpInput\n              {...commonProps}\n              value={formState.values[field.name] || ''}\n              length={field.length ?? 6}\n              maskChar={field.maskChar}\n              mask={field.mask}\n              autoFocus={field.autoFocus}\n              separator={field.separator}\n              groupSize={field.groupSize ?? 3}\n              autoSubmit={false}\n              onChange={(value) => handleChange(field.name, value)}\n              onComplete={(value) => {\n                handleChange(field.name, value);\n                if (field.onComplete) {\n                  field.onComplete(value);\n                }\n              }}\n              variant={field.variant as 'default' | 'pill'}\n            />\n          );\n        case 'tags':\n          return (\n            <TagsInput\n              {...commonProps}\n              value={formState.values[field.name] || []}\n              onChange={(tags) => handleChange(field.name, tags)}\n              variant={field.variant as 'default' | 'pill'}\n              triggerKey={field.triggerKey}\n            />\n          );\n        default:\n          return null;\n      }\n    },\n    [\n      fieldClassName,\n      formState.errors,\n      formState.isSubmitting,\n      formState.values,\n      handleChange,\n      loading,\n      renderCustomField,\n    ],\n  );\n\n  return (\n    <form\n      id={id}\n      onSubmit={handleSubmit}\n      className={cn('w-full', className)}\n      noValidate\n      ref={formRef}\n    >\n      {/* Form status messages */}\n      {formState.isSuccess && formState.successMessage && (\n        <div className=\"mb-6 p-4 bg-green-50 border border-green-200 text-green-700 rounded-md dark:bg-green-900/20 dark:border-green-800 dark:text-green-400\">\n          {formState.successMessage}\n        </div>\n      )}\n\n      {formState.isError && formState.errorMessage && (\n        <div className=\"mb-6 p-4 bg-red-50 border border-red-200 text-red-700 rounded-md dark:bg-red-900/20 dark:border-red-800 dark:text-red-400\">\n          {formState.errorMessage}\n        </div>\n      )}\n\n      {/* Form fields */}\n      <div className={getFormLayoutClassName()}>\n        {/* Render ungrouped fields */}\n        {groupedFields.ungroupedFields.map((field) => (\n          <div\n            key={field.name}\n            className={cn(\n              layout === 'horizontal' && 'mr-4 mb-4',\n              layout === 'vertical' && 'mb-0',\n              layout === 'grid' && 'mb-0',\n            )}\n            style={\n              field.width\n                ? {\n                    width:\n                      typeof field.width === 'number'\n                        ? `${field.width}px`\n                        : field.width,\n                  }\n                : undefined\n            }\n          >\n            {renderField(field)}\n          </div>\n        ))}\n\n        {/* Render grouped fields */}\n        {Object.entries(groupedFields.groups).map(([groupName, fields]) => (\n          <div key={groupName} className=\"w-full mb-6\">\n            <div className=\"flex flex-row gap-4\">\n              {fields.map((field) => (\n                <div\n                  key={field.name}\n                  className={cn(\n                    'flex-1',\n                    layout === 'horizontal' && 'mr-4 mb-4',\n                    layout === 'vertical' && 'mb-0',\n                    layout === 'grid' && 'mb-0',\n                  )}\n                  style={\n                    field.width\n                      ? {\n                          width:\n                            typeof field.width === 'number'\n                              ? `${field.width}px`\n                              : field.width,\n                        }\n                      : undefined\n                  }\n                >\n                  {renderField(field)}\n                </div>\n              ))}\n            </div>\n          </div>\n        ))}\n      </div>\n\n      {/* Form actions */}\n      <div className=\"mt-6 flex items-center justify-end space-x-4\">\n        {onCancel && (\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            onClick={onCancel}\n            disabled={loading || formState.isSubmitting}\n            className={cancelClassName}\n          >\n            {cancelText}\n          </Button>\n        )}\n        {!hideSubmitButton && (\n          <Button\n            type=\"submit\"\n            disabled={loading || formState.isSubmitting}\n            className={submitClassName}\n          >\n            {formState.isSubmitting ? 'Submitting...' : submitText}\n          </Button>\n        )}\n      </div>\n    </form>\n  );\n}\n",
      "type": "registry:block"
    }
  ]
}