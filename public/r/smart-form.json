{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "smart-form",
  "type": "registry:component",
  "title": "Smart Form",
  "description": "A powerful abstraction for creating forms with minimal code. Supports various input types, layouts, validation, and conditional fields.",
  "dependencies": [
    "zod",
    "date-fns",
    "lucide-react",
    "@phosphor-icons/react"
  ],
  "registryDependencies": [
    "button",
    "input",
    "checkbox",
    "select",
    "radio-group",
    "switch",
    "textarea",
    "calendar",
    "popover",
    "card"
  ],
  "files": [
    {
      "path": "delta/forms/smart-form.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { z } from 'zod';\nimport { Button } from '@/components/ui/button';\nimport { TextInput } from '@/delta/inputs/text-input';\nimport { CheckboxInput } from '@/delta/inputs/checkbox-input';\nimport { SelectInput } from '@/delta/inputs/select-input';\nimport { RadioInput } from '@/delta/inputs/radio-input';\nimport { SwitchInput } from '@/delta/inputs/switch-input';\nimport { TextareaInput } from '@/delta/inputs/textarea-input';\nimport { DateInput } from '@/delta/inputs/date-input';\nimport { FileInput } from '@/delta/inputs/file-input';\nimport { OTPInput } from '@/delta/inputs/otp-input';\nimport { cn } from '@/lib/utils';\n\n// Field types\nexport type FieldType =\n  | 'text'\n  | 'email'\n  | 'password'\n  | 'number'\n  | 'tel'\n  | 'url'\n  | 'checkbox'\n  | 'select'\n  | 'radio'\n  | 'switch'\n  | 'textarea'\n  | 'date'\n  | 'file'\n  | 'otp'\n  | 'custom';\n\n// Variant types for different inputs\ntype DefaultVariant = 'default' | 'pill';\ntype SwitchVariant = 'pill' | 'rectangular';\n\n// Base field definition\ninterface BaseFieldDefinition {\n  name: string;\n  label: string;\n  type: FieldType;\n  required?: boolean;\n  disabled?: boolean;\n  description?: string;\n  hint?: string;\n  labelVariant?: 'default' | 'muted';\n  className?: string;\n  hidden?: boolean | ((values: Record<string, any>) => boolean);\n  // New properties for field grouping and layout\n  group?: string;\n  width?: string | number;\n}\n\n// Text field definition\ninterface TextFieldDefinition extends BaseFieldDefinition {\n  type: 'text' | 'email' | 'password' | 'number' | 'tel' | 'url';\n  placeholder?: string;\n  defaultValue?: string;\n  variant?: DefaultVariant;\n}\n\n// Checkbox field definition\ninterface CheckboxFieldDefinition extends BaseFieldDefinition {\n  type: 'checkbox';\n  defaultChecked?: boolean;\n  variant?: DefaultVariant;\n}\n\n// Select field definition\ninterface SelectFieldDefinition extends BaseFieldDefinition {\n  type: 'select';\n  options: { value: string; label: string; disabled?: boolean }[];\n  placeholder?: string;\n  defaultValue?: string;\n  variant?: DefaultVariant;\n}\n\n// Radio field definition\ninterface RadioFieldDefinition extends BaseFieldDefinition {\n  type: 'radio';\n  options: {\n    value: string;\n    label: string;\n    description?: string;\n    disabled?: boolean;\n  }[];\n  orientation?: 'vertical' | 'horizontal';\n  defaultValue?: string;\n  variant?: DefaultVariant;\n}\n\n// Switch field definition\ninterface SwitchFieldDefinition extends BaseFieldDefinition {\n  type: 'switch';\n  defaultChecked?: boolean;\n  variant?: SwitchVariant;\n}\n\n// Textarea field definition\ninterface TextareaFieldDefinition extends BaseFieldDefinition {\n  type: 'textarea';\n  placeholder?: string;\n  rows?: number;\n  defaultValue?: string;\n  variant?: DefaultVariant;\n}\n\n// Date field definition\ninterface DateFieldDefinition extends BaseFieldDefinition {\n  type: 'date';\n  placeholder?: string;\n  defaultValue?: Date;\n  minDate?: Date;\n  maxDate?: Date;\n  dateFormat?: string;\n  variant?: DefaultVariant;\n}\n\n// File field definition\ninterface FileFieldDefinition extends BaseFieldDefinition {\n  type: 'file';\n  accept?: string;\n  multiple?: boolean;\n  maxSize?: number;\n  maxFiles?: number;\n  showPreviews?: boolean;\n  showIcons?: boolean;\n  variant?: DefaultVariant;\n}\n\n// OTP field definition\nexport interface OTPFieldDefinition extends BaseFieldDefinition {\n  type: 'otp';\n  length?: number;\n  maskChar?: string;\n  mask?: boolean;\n  autoFocus?: boolean;\n  separator?: boolean;\n  groupSize?: number;\n  autoSubmit?: boolean;\n  placeholder?: string;\n  onComplete?: (value: string) => void;\n  variant?: DefaultVariant;\n}\n\n// Custom field definition\ninterface CustomFieldDefinition extends BaseFieldDefinition {\n  type: 'custom';\n  variant?: DefaultVariant;\n}\n\n// Union of all field definitions\nexport type FieldDefinition =\n  | TextFieldDefinition\n  | CheckboxFieldDefinition\n  | SelectFieldDefinition\n  | RadioFieldDefinition\n  | SwitchFieldDefinition\n  | TextareaFieldDefinition\n  | DateFieldDefinition\n  | FileFieldDefinition\n  | OTPFieldDefinition\n  | CustomFieldDefinition;\n\n// Form props\nexport interface SmartFormProps {\n  fields: FieldDefinition[];\n  schema: z.ZodSchema<any>;\n  onSubmit: (data: any) => Promise<void> | void;\n  submitText?: string;\n  cancelText?: string;\n  onCancel?: () => void;\n  className?: string;\n  fieldClassName?: string;\n  submitClassName?: string;\n  cancelClassName?: string;\n  layout?: 'vertical' | 'horizontal' | 'grid';\n  columns?: number;\n  gap?: number;\n  loading?: boolean;\n  defaultValues?: Record<string, any>;\n  successMessage?: string;\n  errorMessage?: string;\n  resetOnSuccess?: boolean;\n  id?: string;\n  hideSubmitButton?: boolean;\n  // Add this new prop for custom field rendering\n  renderCustomField?: (\n    field: FieldDefinition,\n    formState: any,\n    handleChange: (name: string, value: any) => void,\n  ) => React.ReactNode;\n}\n\nexport function SmartForm({\n  fields,\n  schema,\n  onSubmit,\n  submitText = 'Submit',\n  cancelText = 'Cancel',\n  onCancel,\n  className,\n  fieldClassName,\n  submitClassName,\n  cancelClassName,\n  layout = 'vertical',\n  columns = 1,\n  gap = 6,\n  loading = false,\n  defaultValues = {},\n  successMessage,\n  errorMessage,\n  resetOnSuccess = false,\n  id,\n  hideSubmitButton = false,\n  renderCustomField,\n}: SmartFormProps) {\n  // Use a ref to store the initial defaultValues to prevent re-renders\n  const initialDefaultValuesRef = React.useRef(defaultValues);\n  // Use a ref to track submission in progress to prevent duplicate submissions\n  const isSubmittingRef = React.useRef(false);\n  // Reference to the form element\n  const formRef = React.useRef<HTMLFormElement>(null);\n\n  const [formState, setFormState] = React.useState<{\n    values: Record<string, any>;\n    errors: Record<string, string>;\n    touched: Record<string, boolean>;\n    isSubmitting: boolean;\n    isSubmitted: boolean;\n    isSuccess: boolean;\n    isError: boolean;\n    errorMessage?: string;\n    successMessage?: string;\n  }>({\n    values: { ...initialDefaultValuesRef.current },\n    errors: {},\n    touched: {},\n    isSubmitting: false,\n    isSubmitted: false,\n    isSuccess: false,\n    isError: false,\n  });\n\n  // Only update values from defaultValues on mount or when explicitly reset\n  const resetForm = React.useCallback(\n    (newValues = initialDefaultValuesRef.current) => {\n      setFormState((prev) => ({\n        ...prev,\n        values: { ...newValues },\n        errors: {},\n        touched: {},\n        isSubmitted: false,\n        isSuccess: false,\n        isError: false,\n        errorMessage: undefined,\n        successMessage: undefined,\n      }));\n    },\n    [],\n  );\n\n  // Handle form submission\n  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n\n    // Prevent duplicate submissions\n    if (isSubmittingRef.current) {\n      return;\n    }\n\n    setFormState((prev) => ({\n      ...prev,\n      isSubmitting: true,\n      isSubmitted: true,\n      isSuccess: false,\n      isError: false,\n    }));\n\n    // Set the ref to true to block any parallel submissions\n    isSubmittingRef.current = true;\n\n    try {\n      // Validate form data against schema\n      const result = schema.safeParse(formState.values);\n\n      if (!result.success) {\n        // Format errors\n        const formattedErrors: Record<string, string> = {};\n        const formattedError = result.error.format() as unknown as {\n          [key: string]: { _errors: string[] };\n        };\n\n        // Extract error messages for each field\n        Object.keys(formattedError).forEach((key) => {\n          if (key !== '_errors' && formattedError[key]?._errors?.length) {\n            formattedErrors[key] = formattedError[key]._errors[0];\n          }\n        });\n\n        setFormState((prev) => ({\n          ...prev,\n          errors: formattedErrors,\n          isSubmitting: false,\n          isError: true,\n          errorMessage: errorMessage || 'Please fix the errors in the form',\n        }));\n\n        // Reset the submitting ref\n        isSubmittingRef.current = false;\n        return;\n      }\n\n      // Call onSubmit with validated data\n      await onSubmit(result.data);\n\n      // Update form state on success\n      setFormState((prev) => ({\n        ...prev,\n        isSubmitting: false,\n        isSuccess: true,\n        isError: false,\n        successMessage: successMessage || 'Form submitted successfully',\n      }));\n\n      // Reset form if needed\n      if (resetOnSuccess) {\n        resetForm();\n      }\n    } catch (error) {\n      // Handle submission errors\n      setFormState((prev) => ({\n        ...prev,\n        isSubmitting: false,\n        isError: true,\n        errorMessage:\n          errorMessage || 'An error occurred while submitting the form',\n      }));\n    } finally {\n      // Always reset the submitting ref to ensure future submissions are possible\n      isSubmittingRef.current = false;\n    }\n  };\n\n  // Handle field change - use a memoized callback to prevent recreating on every render\n  const handleChange = React.useCallback((name: string, value: any) => {\n    setFormState((prev) => {\n      // Only update if the value has actually changed\n      if (prev.values[name] === value) {\n        return prev;\n      }\n\n      return {\n        ...prev,\n        values: {\n          ...prev.values,\n          [name]: value,\n        },\n        touched: {\n          ...prev.touched,\n          [name]: true,\n        },\n      };\n    });\n  }, []);\n\n  // Validate a single field - memoized to prevent recreating on every render\n  const validateField = React.useCallback(\n    (name: string, value: any) => {\n      try {\n        // Create a partial schema for just this field\n        const fieldSchema = z.object({\n          [name]: (schema as any).shape?.[name] || z.any(),\n        });\n\n        // Validate the field\n        const result = fieldSchema.safeParse({ [name]: value });\n\n        if (!result.success) {\n          const error = result.error.format()[name]?._errors[0];\n          setFormState((prev) => ({\n            ...prev,\n            errors: {\n              ...prev.errors,\n              [name]: error || 'Invalid value',\n            },\n          }));\n        } else {\n          // Clear error if validation passes\n          setFormState((prev) => {\n            // Only update if there was an error before\n            if (!prev.errors[name]) {\n              return prev;\n            }\n\n            const newErrors = { ...prev.errors };\n            delete newErrors[name];\n\n            return {\n              ...prev,\n              errors: newErrors,\n            };\n          });\n        }\n      } catch (error) {\n        // If there's an error in validation, don't update the error state\n        console.error('Error validating field:', error);\n      }\n    },\n    [schema],\n  );\n\n  // Render form layout\n  const getFormLayoutClassName = () => {\n    switch (layout) {\n      case 'horizontal':\n        return 'flex flex-wrap items-start';\n      case 'grid':\n        return `grid grid-cols-1 md:grid-cols-${columns} gap-${gap}`;\n      case 'vertical':\n      default:\n        return 'flex flex-col space-y-6';\n    }\n  };\n\n  // Handle OTP specific logic by patching autoSubmit\n  const patchedFields = React.useMemo(() => {\n    return fields.map((field) => {\n      if (field.type === 'otp' && field.autoSubmit) {\n        // Create a safe deep clone of the field\n        const otpField = { ...field } as OTPFieldDefinition;\n\n        // Store the original onComplete handler\n        const originalOnComplete = otpField.onComplete;\n\n        // Create a new onComplete handler that safely submits the form\n        otpField.onComplete = (value: string) => {\n          // Call the original handler if it exists\n          if (originalOnComplete) {\n            originalOnComplete(value);\n          }\n\n          // Only submit if not already submitting\n          if (!isSubmittingRef.current && formRef.current) {\n            // Use a short delay to allow React to process state updates\n            setTimeout(() => {\n              formRef.current?.requestSubmit();\n            }, 10);\n          }\n        };\n\n        return otpField;\n      }\n      return field;\n    });\n  }, [fields]);\n\n  // Memoize the visible fields to prevent unnecessary re-renders\n  const visibleFields = React.useMemo(() => {\n    return patchedFields.filter((field) => {\n      if (typeof field.hidden === 'function') {\n        return !field.hidden(formState.values);\n      }\n      return !field.hidden;\n    });\n  }, [patchedFields, formState.values]);\n\n  // Group fields by their group property\n  const groupedFields = React.useMemo(() => {\n    const groups: Record<string, FieldDefinition[]> = {};\n    const ungroupedFields: FieldDefinition[] = [];\n\n    visibleFields.forEach((field) => {\n      if (field.group) {\n        if (!groups[field.group]) {\n          groups[field.group] = [];\n        }\n        groups[field.group].push(field);\n      } else {\n        ungroupedFields.push(field);\n      }\n    });\n\n    return { groups, ungroupedFields };\n  }, [visibleFields]);\n\n  // Render form fields - memoized to prevent recreating on every render\n  const renderField = React.useCallback(\n    (field: FieldDefinition) => {\n      // Handle custom field rendering if provided\n      if (field.type === 'custom' && renderCustomField) {\n        return renderCustomField(\n          field,\n          { values: formState.values, errors: formState.errors },\n          handleChange,\n        );\n      }\n\n      const commonProps = {\n        label: field.label,\n        name: field.name,\n        required: field.required,\n        disabled: field.disabled || loading || formState.isSubmitting,\n        description: field.description,\n        hint: field.hint,\n        labelVariant: field.labelVariant,\n        error: formState.errors[field.name],\n        className: cn(fieldClassName, field.className),\n      };\n\n      // Handle variant prop separately for each component type\n      switch (field.type) {\n        case 'text':\n        case 'email':\n        case 'password':\n        case 'number':\n        case 'tel':\n        case 'url':\n          return (\n            <TextInput\n              {...commonProps}\n              type={field.type}\n              placeholder={field.placeholder}\n              defaultValue={formState.values[field.name] || ''}\n              onChange={(e) => handleChange(field.name, e.target.value)}\n              variant={field.variant as 'default' | 'pill'}\n            />\n          );\n        case 'checkbox':\n          return (\n            <CheckboxInput\n              {...commonProps}\n              defaultChecked={formState.values[field.name] || false}\n              onCheckedChange={(checked) => handleChange(field.name, checked)}\n            />\n          );\n        case 'select':\n          return (\n            <SelectInput\n              {...commonProps}\n              options={field.options}\n              placeholder={field.placeholder}\n              defaultValue={formState.values[field.name] || ''}\n              onValueChange={(value) => handleChange(field.name, value)}\n              variant={field.variant as 'default' | 'pill'}\n            />\n          );\n        case 'radio':\n          return (\n            <RadioInput\n              {...commonProps}\n              options={field.options}\n              orientation={field.orientation}\n              defaultValue={formState.values[field.name] || ''}\n              onValueChange={(value) => handleChange(field.name, value)}\n            />\n          );\n        case 'switch':\n          const switchVariant: 'pill' | 'rectangular' =\n            field.variant === 'pill' ? 'pill' : 'rectangular';\n          return (\n            <SwitchInput\n              {...commonProps}\n              defaultChecked={formState.values[field.name] || false}\n              onCheckedChange={(checked) => handleChange(field.name, checked)}\n              variant={switchVariant}\n            />\n          );\n        case 'textarea':\n          return (\n            <TextareaInput\n              {...commonProps}\n              placeholder={field.placeholder}\n              rows={field.rows}\n              defaultValue={formState.values[field.name] || ''}\n              onChange={(e) => handleChange(field.name, e.target.value)}\n              variant={field.variant as 'default' | 'pill'}\n            />\n          );\n        case 'date':\n          return (\n            <DateInput\n              {...commonProps}\n              placeholder={field.placeholder}\n              defaultValue={formState.values[field.name]}\n              minDate={field.minDate}\n              maxDate={field.maxDate}\n              dateFormat={field.dateFormat}\n              onValueChange={(date) => handleChange(field.name, date)}\n              variant={field.variant as 'default' | 'pill'}\n            />\n          );\n        case 'file':\n          return (\n            <FileInput\n              {...commonProps}\n              accept={field.accept}\n              multiple={field.multiple}\n              maxSize={field.maxSize}\n              maxFiles={field.maxFiles}\n              showPreviews={field.showPreviews}\n              showIcons={field.showIcons}\n              onFilesSelected={(files) =>\n                handleChange(field.name, field.multiple ? files : files[0])\n              }\n              variant={field.variant as 'default' | 'pill'}\n            />\n          );\n        case 'otp':\n          return (\n            <OTPInput\n              {...commonProps}\n              value={formState.values[field.name] || ''}\n              length={field.length ?? 6}\n              maskChar={field.maskChar}\n              mask={field.mask}\n              autoFocus={field.autoFocus}\n              separator={field.separator}\n              groupSize={field.groupSize ?? 3}\n              autoSubmit={false}\n              onChange={(value) => handleChange(field.name, value)}\n              onComplete={(value) => {\n                handleChange(field.name, value);\n                if (field.onComplete) {\n                  field.onComplete(value);\n                }\n              }}\n              variant={field.variant as 'default' | 'pill'}\n            />\n          );\n        default:\n          return null;\n      }\n    },\n    [\n      fieldClassName,\n      formState.errors,\n      formState.isSubmitting,\n      formState.values,\n      handleChange,\n      loading,\n      renderCustomField,\n    ],\n  );\n\n  return (\n    <form\n      id={id}\n      onSubmit={handleSubmit}\n      className={cn('w-full', className)}\n      noValidate\n      ref={formRef}\n    >\n      {/* Form status messages */}\n      {formState.isSuccess && formState.successMessage && (\n        <div className=\"mb-6 p-4 bg-green-50 border border-green-200 text-green-700 rounded-md dark:bg-green-900/20 dark:border-green-800 dark:text-green-400\">\n          {formState.successMessage}\n        </div>\n      )}\n\n      {formState.isError && formState.errorMessage && (\n        <div className=\"mb-6 p-4 bg-red-50 border border-red-200 text-red-700 rounded-md dark:bg-red-900/20 dark:border-red-800 dark:text-red-400\">\n          {formState.errorMessage}\n        </div>\n      )}\n\n      {/* Form fields */}\n      <div className={getFormLayoutClassName()}>\n        {/* Render ungrouped fields */}\n        {groupedFields.ungroupedFields.map((field) => (\n          <div\n            key={field.name}\n            className={cn(\n              layout === 'horizontal' && 'mr-4 mb-4',\n              layout === 'vertical' && 'mb-0',\n              layout === 'grid' && 'mb-0',\n            )}\n            style={\n              field.width\n                ? {\n                    width:\n                      typeof field.width === 'number'\n                        ? `${field.width}px`\n                        : field.width,\n                  }\n                : undefined\n            }\n          >\n            {renderField(field)}\n          </div>\n        ))}\n\n        {/* Render grouped fields */}\n        {Object.entries(groupedFields.groups).map(([groupName, fields]) => (\n          <div key={groupName} className=\"w-full mb-6\">\n            <div className=\"grid grid-cols-12 gap-4\">\n              {fields.map((field) => (\n                <div\n                  key={field.name}\n                  className={cn(\n                    'col-span-12',\n                    field.width\n                      ? ''\n                      : `sm:col-span-${Math.floor(12 / fields.length)}`,\n                  )}\n                  style={\n                    field.width\n                      ? {\n                          width:\n                            typeof field.width === 'number'\n                              ? `${field.width}px`\n                              : field.width,\n                        }\n                      : undefined\n                  }\n                >\n                  {renderField(field)}\n                </div>\n              ))}\n            </div>\n          </div>\n        ))}\n      </div>\n\n      {/* Form actions */}\n      <div className=\"mt-6 flex items-center justify-end space-x-4\">\n        {onCancel && (\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            onClick={onCancel}\n            disabled={loading || formState.isSubmitting}\n            className={cancelClassName}\n          >\n            {cancelText}\n          </Button>\n        )}\n        {!hideSubmitButton && (\n          <Button\n            type=\"submit\"\n            disabled={loading || formState.isSubmitting}\n            className={submitClassName}\n          >\n            {formState.isSubmitting ? 'Submitting...' : submitText}\n          </Button>\n        )}\n      </div>\n    </form>\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/forms/smart-form.tsx"
    },
    {
      "path": "delta/forms/smart-form-demo.tsx",
      "content": "'use client';\nimport React from 'react';\nimport { z } from 'zod';\nimport {\n  Card,\n  CardTitle,\n  CardHeader,\n  CardDescription,\n  CardContent,\n} from '@/components/ui/card';\nimport {\n  SmartForm,\n  FieldDefinition,\n  OTPFieldDefinition,\n} from '@/delta/forms/smart-form';\nimport { addDays } from 'date-fns';\n\nexport default function SmartFormDemo() {\n  return (\n    <div className=\"container mx-auto max-w-7xl px-4 py-8 space-y-16\">\n      <div className=\"space-y-4\">\n        <h2 className=\"text-2xl font-bold\">Job Application Form</h2>\n        <p className=\"text-muted-foreground\">\n          A comprehensive job application form showcasing various input types\n          with pill variant.\n        </p>\n        <JobApplicationFormExample />\n      </div>\n\n      <div className=\"space-y-4\">\n        <h2 className=\"text-2xl font-bold\">Basic Contact Form</h2>\n        <p className=\"text-muted-foreground\">\n          A simple contact form with various input types in a vertical layout.\n        </p>\n        <ContactFormExample />\n      </div>\n\n      <div className=\"space-y-4\">\n        <h2 className=\"text-2xl font-bold\">\n          Registration Form with Grid Layout\n        </h2>\n        <p className=\"text-muted-foreground\">\n          A user registration form with a responsive grid layout and validation.\n        </p>\n        <RegistrationFormExample />\n      </div>\n\n      <div className=\"space-y-4\">\n        <h2 className=\"text-2xl font-bold\">Payment Form with Grouped Fields</h2>\n        <p className=\"text-muted-foreground\">\n          A payment form with pill-style inputs and horizontally grouped fields.\n        </p>\n        <PaymentFormExample />\n      </div>\n\n      <div className=\"space-y-4\">\n        <h2 className=\"text-2xl font-bold\">Conditional Fields Example</h2>\n        <p className=\"text-muted-foreground\">\n          A form that shows or hides fields based on user selections.\n        </p>\n        <ConditionalFieldsExample />\n      </div>\n\n      <div className=\"space-y-4\">\n        <h2 className=\"text-2xl font-bold\">Two-Factor Authentication</h2>\n        <p className=\"text-muted-foreground\">\n          A two-factor authentication form with OTP input.\n        </p>\n        <TwoFactorAuthExample />\n      </div>\n    </div>\n  );\n}\n\n// Contact Form Example\nfunction ContactFormExample() {\n  // Define the form schema\n  const contactFormSchema = z.object({\n    name: z.string().min(1, 'Name is required'),\n    email: z.string().email('Please enter a valid email address'),\n    subject: z.string().min(1, 'Subject is required'),\n    message: z.string().min(10, 'Message must be at least 10 characters'),\n    priority: z.string().min(1, 'Please select a priority'),\n    contactDate: z.date().optional(),\n    subscribe: z.boolean().optional(),\n  });\n\n  // Define the form fields\n  const contactFormFields = [\n    {\n      name: 'name',\n      label: 'Name',\n      type: 'text' as const,\n      required: true,\n      placeholder: 'Your name',\n    },\n    {\n      name: 'email',\n      label: 'Email',\n      type: 'email' as const,\n      required: true,\n      placeholder: 'your@email.com',\n    },\n    {\n      name: 'subject',\n      label: 'Subject',\n      type: 'text' as const,\n      required: true,\n      placeholder: 'What is this regarding?',\n    },\n    {\n      name: 'priority',\n      label: 'Priority',\n      type: 'select' as const,\n      required: true,\n      options: [\n        { value: 'low', label: 'Low' },\n        { value: 'medium', label: 'Medium' },\n        { value: 'high', label: 'High' },\n      ],\n      placeholder: 'Select priority',\n    },\n    {\n      name: 'message',\n      label: 'Message',\n      type: 'textarea' as const,\n      required: true,\n      placeholder: 'Your message here...',\n      rows: 4,\n    },\n    {\n      name: 'contactDate',\n      label: 'Preferred Contact Date',\n      type: 'date' as const,\n      placeholder: 'Select a date',\n      hint: 'When would you prefer us to contact you?',\n      minDate: new Date(),\n      maxDate: addDays(new Date(), 30),\n    },\n    {\n      name: 'subscribe',\n      label: 'Subscribe to newsletter',\n      type: 'checkbox' as const,\n      description: 'Receive updates and news from us',\n    },\n  ];\n\n  const handleSubmit = async (data: z.infer<typeof contactFormSchema>) => {\n    // Mock API call\n    console.log('Form data:', data);\n    alert('Contact form submitted: ' + JSON.stringify(data, null, 2));\n    return Promise.resolve();\n  };\n\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader>\n        <CardTitle>Contact Us</CardTitle>\n        <CardDescription>\n          Fill out the form below to get in touch with our team.\n        </CardDescription>\n      </CardHeader>\n      <CardContent>\n        <SmartForm\n          fields={contactFormFields}\n          schema={contactFormSchema}\n          onSubmit={handleSubmit}\n          submitText=\"Send Message\"\n          layout=\"vertical\"\n          successMessage=\"Your message has been sent! We'll get back to you soon.\"\n        />\n      </CardContent>\n    </Card>\n  );\n}\n\n// Registration Form Example\nfunction RegistrationFormExample() {\n  // Define the form schema with password confirmation\n  const registrationSchema = z\n    .object({\n      firstName: z.string().min(1, 'First name is required'),\n      lastName: z.string().min(1, 'Last name is required'),\n      email: z.string().email('Please enter a valid email address'),\n      password: z.string().min(8, 'Password must be at least 8 characters'),\n      confirmPassword: z.string().min(1, 'Please confirm your password'),\n      role: z.string().min(1, 'Please select a role'),\n      agreeToTerms: z.literal(true, {\n        errorMap: () => ({\n          message: 'You must agree to the terms and conditions',\n        }),\n      }),\n      receiveUpdates: z.boolean().optional(),\n    })\n    .refine((data) => data.password === data.confirmPassword, {\n      message: 'Passwords do not match',\n      path: ['confirmPassword'],\n    });\n\n  // Define the form fields\n  const registrationFields = [\n    {\n      name: 'firstName',\n      label: 'First Name',\n      type: 'text' as const,\n      required: true,\n      placeholder: 'John',\n    },\n    {\n      name: 'lastName',\n      label: 'Last Name',\n      type: 'text' as const,\n      required: true,\n      placeholder: 'Doe',\n    },\n    {\n      name: 'email',\n      label: 'Email',\n      type: 'email' as const,\n      required: true,\n      placeholder: 'john@example.com',\n    },\n    {\n      name: 'password',\n      label: 'Password',\n      type: 'password' as const,\n      required: true,\n      placeholder: '••••••••',\n      hint: 'Must be at least 8 characters',\n    },\n    {\n      name: 'confirmPassword',\n      label: 'Confirm Password',\n      type: 'password' as const,\n      required: true,\n      placeholder: '••••••••',\n    },\n    {\n      name: 'role',\n      label: 'Role',\n      type: 'radio' as const,\n      required: true,\n      options: [\n        {\n          value: 'developer',\n          label: 'Developer',\n          description: 'Software developer or engineer',\n        },\n        {\n          value: 'designer',\n          label: 'Designer',\n          description: 'UI/UX or graphic designer',\n        },\n        {\n          value: 'manager',\n          label: 'Manager',\n          description: 'Project or product manager',\n        },\n      ],\n    },\n    {\n      name: 'agreeToTerms',\n      label: 'I agree to the terms and conditions',\n      type: 'checkbox' as const,\n      required: true,\n    },\n    {\n      name: 'receiveUpdates',\n      label: 'Receive product updates and news',\n      type: 'checkbox' as const,\n      description: \"We'll never spam you or sell your information\",\n    },\n  ];\n\n  const handleSubmit = async (data: z.infer<typeof registrationSchema>) => {\n    // Mock API call\n    console.log('Registration data:', data);\n    alert('Registration form submitted: ' + JSON.stringify(data, null, 2));\n    return Promise.resolve();\n  };\n\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader>\n        <CardTitle>Create an Account</CardTitle>\n        <CardDescription>\n          Sign up to get started with our platform.\n        </CardDescription>\n      </CardHeader>\n      <CardContent>\n        <SmartForm\n          fields={registrationFields}\n          schema={registrationSchema}\n          onSubmit={handleSubmit}\n          submitText=\"Create Account\"\n          layout=\"grid\"\n          columns={2}\n          gap={4}\n          successMessage=\"Account created successfully! Check your email for verification.\"\n          resetOnSuccess={true}\n        />\n      </CardContent>\n    </Card>\n  );\n}\n\n// Payment Form Example\nfunction PaymentFormExample() {\n  // Define the form schema\n  const paymentFormSchema = z.object({\n    cardName: z.string().min(1, 'Name on card is required'),\n    cardNumber: z\n      .string()\n      .min(1, 'Card number is required')\n      .regex(/^[0-9]{16}$/, 'Card number must be 16 digits'),\n    expiryDate: z\n      .string()\n      .min(1, 'Expiry date is required')\n      .regex(\n        /^(0[1-9]|1[0-2])\\/([0-9]{2})$/,\n        'Expiry date must be in MM/YY format',\n      ),\n    cvc: z\n      .string()\n      .min(1, 'CVC is required')\n      .regex(/^[0-9]{3,4}$/, 'CVC must be 3 or 4 digits'),\n    country: z.string().min(1, 'Country is required'),\n    saveCard: z.boolean().optional(),\n  });\n\n  // Define the form fields\n  const paymentFormFields = [\n    {\n      name: 'cardName',\n      label: 'Name on Card',\n      type: 'text' as const,\n      required: true,\n      placeholder: 'John Doe',\n      variant: 'pill' as const,\n    },\n    {\n      name: 'cardNumber',\n      label: 'Card Number',\n      type: 'text' as const,\n      required: true,\n      placeholder: '1234567890123456',\n      variant: 'pill' as const,\n      hint: '16-digit number without spaces',\n    },\n    // Group expiry date and CVC fields to display them side by side\n    {\n      name: 'expiryDate',\n      label: 'Expiry Date',\n      type: 'text' as const,\n      required: true,\n      placeholder: 'MM/YY',\n      variant: 'pill' as const,\n      group: 'card-details', // Group name to link related fields\n    },\n    {\n      name: 'cvc',\n      label: 'CVC',\n      type: 'text' as const,\n      required: true,\n      placeholder: '123',\n      variant: 'pill' as const,\n      hint: '3 or 4 digits on the back of your card',\n      group: 'card-details', // Same group name to link related fields\n    },\n    {\n      name: 'country',\n      label: 'Country',\n      type: 'select' as const,\n      required: true,\n      options: [\n        { value: 'us', label: 'United States' },\n        { value: 'ca', label: 'Canada' },\n        { value: 'uk', label: 'United Kingdom' },\n        { value: 'au', label: 'Australia' },\n      ],\n      placeholder: 'Select your country',\n      variant: 'pill' as const,\n    },\n    {\n      name: 'saveCard',\n      label: 'Save card for future payments',\n      type: 'checkbox' as const,\n    },\n  ];\n\n  const handleSubmit = async (data: z.infer<typeof paymentFormSchema>) => {\n    // Mock API call\n    console.log('Payment data:', data);\n    alert('Payment form submitted: ' + JSON.stringify(data, null, 2));\n    return Promise.resolve();\n  };\n\n  return (\n    <Card className=\"w-full max-w-md mx-auto\">\n      <CardHeader>\n        <CardTitle>Payment Information</CardTitle>\n        <CardDescription>\n          Enter your card details to complete your purchase.\n        </CardDescription>\n      </CardHeader>\n      <CardContent>\n        <SmartForm\n          fields={paymentFormFields}\n          schema={paymentFormSchema}\n          onSubmit={handleSubmit}\n          submitText=\"Pay $49.99\"\n          layout=\"vertical\"\n          successMessage=\"Payment successful! Thank you for your purchase.\"\n        />\n      </CardContent>\n    </Card>\n  );\n}\n\n// Conditional Fields Example\nfunction ConditionalFieldsExample() {\n  // Define the form schema\n  const shippingFormSchema = z\n    .object({\n      fullName: z.string().min(1, 'Full name is required'),\n      email: z.string().email('Please enter a valid email address'),\n      shippingMethod: z.enum(['standard', 'express', 'pickup']),\n      address: z.string().optional(),\n      city: z.string().optional(),\n      state: z.string().optional(),\n      zipCode: z.string().optional(),\n      pickupLocation: z.string().optional(),\n      pickupDate: z.date().optional(),\n      specialInstructions: z.string().optional(),\n    })\n    .refine(\n      (data) => {\n        // If shipping method is pickup, require pickup location and date\n        if (data.shippingMethod === 'pickup') {\n          return !!data.pickupLocation && !!data.pickupDate;\n        }\n\n        // If shipping method is standard or express, require address fields\n        if (\n          data.shippingMethod === 'standard' ||\n          data.shippingMethod === 'express'\n        ) {\n          return (\n            !!data.address && !!data.city && !!data.state && !!data.zipCode\n          );\n        }\n\n        return true;\n      },\n      {\n        message:\n          'Please fill in all required fields for your selected shipping method',\n        path: ['shippingMethod'],\n      },\n    );\n\n  // Define the form fields\n  const shippingFormFields = [\n    {\n      name: 'fullName',\n      label: 'Full Name',\n      type: 'text' as const,\n      required: true,\n      placeholder: 'John Doe',\n    },\n    {\n      name: 'email',\n      label: 'Email',\n      type: 'email' as const,\n      required: true,\n      placeholder: 'john@example.com',\n    },\n    {\n      name: 'shippingMethod',\n      label: 'Shipping Method',\n      type: 'radio' as const,\n      required: true,\n      options: [\n        {\n          value: 'standard',\n          label: 'Standard Shipping',\n          description: '3-5 business days',\n        },\n        {\n          value: 'express',\n          label: 'Express Shipping',\n          description: '1-2 business days',\n        },\n        {\n          value: 'pickup',\n          label: 'Store Pickup',\n          description: 'Pick up at your convenience',\n        },\n      ],\n    },\n    // Address fields - only shown for standard and express shipping\n    {\n      name: 'address',\n      label: 'Street Address',\n      type: 'text' as const,\n      required: true,\n      placeholder: '123 Main St',\n      hidden: (values: Record<string, any>) =>\n        values.shippingMethod === 'pickup',\n    },\n    {\n      name: 'city',\n      label: 'City',\n      type: 'text' as const,\n      required: true,\n      placeholder: 'New York',\n      hidden: (values: Record<string, any>) =>\n        values.shippingMethod === 'pickup',\n      group: 'location',\n    },\n    {\n      name: 'state',\n      label: 'State',\n      type: 'text' as const,\n      required: true,\n      placeholder: 'NY',\n      hidden: (values: Record<string, any>) =>\n        values.shippingMethod === 'pickup',\n      group: 'location',\n    },\n    {\n      name: 'zipCode',\n      label: 'ZIP Code',\n      type: 'text' as const,\n      required: true,\n      placeholder: '10001',\n      hidden: (values: Record<string, any>) =>\n        values.shippingMethod === 'pickup',\n      group: 'location',\n    },\n    // Pickup fields - only shown for pickup\n    {\n      name: 'pickupLocation',\n      label: 'Pickup Location',\n      type: 'select' as const,\n      required: true,\n      options: [\n        { value: 'downtown', label: 'Downtown Store' },\n        { value: 'uptown', label: 'Uptown Store' },\n        { value: 'midtown', label: 'Midtown Store' },\n      ],\n      placeholder: 'Select a store',\n      hidden: (values: Record<string, any>) =>\n        values.shippingMethod !== 'pickup',\n    },\n    {\n      name: 'pickupDate',\n      label: 'Pickup Date',\n      type: 'date' as const,\n      required: true,\n      placeholder: 'Select a date',\n      minDate: new Date(),\n      maxDate: addDays(new Date(), 14),\n      hidden: (values: Record<string, any>) =>\n        values.shippingMethod !== 'pickup',\n    },\n    {\n      name: 'specialInstructions',\n      label: 'Special Instructions',\n      type: 'textarea' as const,\n      placeholder: 'Any special instructions for delivery or pickup',\n      rows: 3,\n    },\n  ];\n\n  const handleSubmit = async (data: z.infer<typeof shippingFormSchema>) => {\n    // Mock API call\n    console.log('Shipping data:', data);\n    alert('Shipping form submitted: ' + JSON.stringify(data, null, 2));\n    return Promise.resolve();\n  };\n\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader>\n        <CardTitle>Shipping Information</CardTitle>\n        <CardDescription>\n          Choose your shipping method and provide the necessary details.\n        </CardDescription>\n      </CardHeader>\n      <CardContent>\n        <SmartForm\n          fields={shippingFormFields}\n          schema={shippingFormSchema}\n          onSubmit={handleSubmit}\n          submitText=\"Continue to Payment\"\n          layout=\"vertical\"\n          successMessage=\"Shipping information saved successfully!\"\n        />\n      </CardContent>\n    </Card>\n  );\n}\n\n// Two-Factor Authentication Example with native OTP support\n// Two-Factor Authentication Example with native OTP support\nfunction TwoFactorAuthExample() {\n  // Define the form schema with OTP verification\n  const twoFactorSchema = z.object({\n    verificationCode: z.string().min(1, 'Verification code is required'),\n    rememberDevice: z.boolean().optional(),\n  });\n\n  // Track form submission state to prevent double submission\n  const [isSubmitting, setIsSubmitting] = React.useState(false);\n\n  // Define the form fields using the native OTP field type\n  const twoFactorFields = [\n    {\n      name: 'verificationCode',\n      label: 'Verification Code',\n      type: 'otp' as const,\n      required: true,\n      length: 6,\n      autoFocus: false,\n      separator: true,\n      groupSize: 3,\n      // We'll handle autoSubmit manually to prevent duplicate submissions\n      autoSubmit: false,\n      hint: 'Enter the 6-digit code sent to your phone.',\n    },\n    {\n      name: 'rememberDevice',\n      label: 'Remember this device for 30 days',\n      type: 'checkbox' as const,\n      description:\n        \"You won't need to enter a verification code when logging in from this device\",\n    },\n  ];\n\n  const handleSubmit = async (data: z.infer<typeof twoFactorSchema>) => {\n    // Prevent duplicate submissions\n    if (isSubmitting) return;\n\n    try {\n      setIsSubmitting(true);\n\n      // Mock API call\n      console.log('Two-factor auth data:', data);\n      alert('Verification successful: ' + JSON.stringify(data, null, 2));\n\n      return Promise.resolve();\n    } finally {\n      // Reset submission state after completion\n      setIsSubmitting(false);\n    }\n  };\n\n  // Create a custom handler for OTP completion\n  const handleOTPComplete = (\n    fields: FieldDefinition[],\n    formState: any,\n    formRef: React.RefObject<HTMLFormElement>,\n  ) => {\n    // Find the OTP field\n    const otpField = fields.find(\n      (field) => field.name === 'verificationCode',\n    ) as OTPFieldDefinition;\n\n    // Modify the onComplete handler\n    if (otpField) {\n      const originalOnComplete = otpField.onComplete;\n\n      otpField.onComplete = (value: string) => {\n        // Call the original handler if it exists\n        if (originalOnComplete) {\n          originalOnComplete(value);\n        }\n\n        // Submit the form only if we're not already submitting\n        if (!isSubmitting && formRef.current) {\n          formRef.current.requestSubmit();\n        }\n      };\n    }\n\n    return fields;\n  };\n\n  return (\n    <Card className=\"w-full max-w-md mx-auto\">\n      <CardHeader>\n        <CardTitle>Two-Factor Authentication</CardTitle>\n        <CardDescription>\n          We've sent a verification code to your phone. Enter the code to\n          continue.\n        </CardDescription>\n      </CardHeader>\n      <CardContent>\n        <SmartForm\n          fields={twoFactorFields}\n          schema={twoFactorSchema}\n          onSubmit={handleSubmit}\n          submitText=\"Verify\"\n          layout=\"vertical\"\n          successMessage=\"Verification successful! You're now logged in.\"\n          // Show the submit button as a backup\n          hideSubmitButton={false}\n        />\n      </CardContent>\n    </Card>\n  );\n}\n\n// Job Application Form Example\nfunction JobApplicationFormExample() {\n  // Define the form schema\n  const jobApplicationSchema = z.object({\n    fullName: z.string().min(1, 'Full name is required'),\n    email: z.string().email('Please enter a valid email address'),\n    position: z.string().min(1, 'Please select a position'),\n    resume: z\n      .any()\n      .refine((val) => val && val.length > 0, 'Please upload your resume'),\n    startDate: z.date().min(new Date(), 'Start date must be in the future'),\n    agreeToTerms: z.literal(true, {\n      errorMap: () => ({\n        message: 'You must agree to the terms and conditions',\n      }),\n    }),\n  });\n\n  // Define the form fields\n  const jobApplicationFields = [\n    {\n      name: 'fullName',\n      label: 'Full Name',\n      type: 'text' as const,\n      required: true,\n      placeholder: 'John Doe',\n      variant: 'pill' as const,\n    },\n    {\n      name: 'email',\n      label: 'Email',\n      type: 'email' as const,\n      required: true,\n      placeholder: 'john@example.com',\n      variant: 'pill' as const,\n    },\n    {\n      name: 'position',\n      label: 'Position',\n      type: 'select' as const,\n      required: true,\n      options: [\n        { value: 'frontend', label: 'Frontend Developer' },\n        { value: 'backend', label: 'Backend Developer' },\n        { value: 'fullstack', label: 'Full Stack Developer' },\n        { value: 'designer', label: 'UI/UX Designer' },\n        { value: 'product', label: 'Product Manager' },\n      ],\n      placeholder: 'Select a position',\n      variant: 'pill' as const,\n    },\n    {\n      name: 'resume',\n      label: 'Resume',\n      type: 'file' as const,\n      required: true,\n      accept: '.pdf,.doc,.docx',\n      maxSize: 5 * 1024 * 1024, // 5MB\n      maxFiles: 1,\n      showPreviews: true,\n      showIcons: true,\n      hint: 'Upload your resume (PDF, DOC, or DOCX, max 5MB)',\n      variant: 'pill' as const,\n    },\n    {\n      name: 'startDate',\n      label: 'Earliest Start Date',\n      type: 'date' as const,\n      required: true,\n      placeholder: 'Select a date',\n      minDate: new Date(),\n      maxDate: addDays(new Date(), 90),\n      hint: 'When can you start?',\n      variant: 'pill' as const,\n    },\n    {\n      name: 'agreeToTerms',\n      label: 'I agree to the terms and conditions',\n      type: 'checkbox' as const,\n      required: true,\n      description:\n        'By submitting this form, you agree to our privacy policy and terms of service',\n    },\n  ];\n\n  const handleSubmit = async (data: z.infer<typeof jobApplicationSchema>) => {\n    // Mock API call\n    console.log('Job application data:', data);\n    alert(\"Application submitted successfully! We'll contact you soon.\");\n    return Promise.resolve();\n  };\n\n  return (\n    <Card className=\"w-full max-w-md mx-auto\">\n      <CardHeader>\n        <CardTitle>Job Application</CardTitle>\n        <CardDescription>\n          Fill out the form below to apply for a position at our company.\n        </CardDescription>\n      </CardHeader>\n      <CardContent>\n        <SmartForm\n          fields={jobApplicationFields}\n          schema={jobApplicationSchema}\n          onSubmit={handleSubmit}\n          submitText=\"Submit Application\"\n          layout=\"vertical\"\n          successMessage=\"Your application has been submitted successfully! We'll review it and get back to you soon.\"\n        />\n      </CardContent>\n    </Card>\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/forms/smart-form-demo.tsx"
    },
    {
      "path": "delta/inputs/text-input.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { Input } from '@/components/ui/input';\nimport { cn } from '@/lib/utils';\nimport type { z } from 'zod';\n\nexport interface TextInputProps\n  extends React.InputHTMLAttributes<HTMLInputElement> {\n  /** The label for the input field */\n  label: string;\n  /** The name of the input field (used for form submission) */\n  name: string;\n  /** Optional description text to display below the label */\n  description?: string;\n  /** Optional hint text to display below the input */\n  hint?: string;\n  /** Error message to display (typically from Zod validation) */\n  error?: string;\n  /** Whether the field is required */\n  required?: boolean;\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean;\n  /** Default value for the input */\n  defaultValue?: string;\n  /** Container className for the entire component */\n  containerClassName?: string;\n  /** Label className for customizing the label */\n  labelClassName?: string;\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: 'default' | 'muted';\n  /** Input variant - 'default' or 'pill' */\n  variant?: 'default' | 'pill';\n  /** Whether to show a colored border (only applies to pill variant) */\n  coloredBorder?: boolean;\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<string>;\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, value: string, error?: string) => void;\n}\n\n/**\n * TextInput component that integrates with Zod validation\n */\nexport function TextInput({\n  label,\n  name,\n  description,\n  hint,\n  error,\n  required = false,\n  pending = false,\n  defaultValue,\n  containerClassName,\n  labelClassName,\n  labelVariant = 'default',\n  variant = 'default',\n  coloredBorder = false,\n  schema,\n  onValidate,\n  className,\n  id = name,\n  value,\n  ...props\n}: TextInputProps) {\n  const [localError, setLocalError] = React.useState<string | undefined>(error);\n  const hasError = !!localError || !!error;\n  const errorId = `error-${id}`;\n  const hintId = `hint-${id}`;\n\n  // Determine if component is controlled or uncontrolled\n  const isControlled = value !== undefined;\n\n  // Update local error when prop changes\n  React.useEffect(() => {\n    setLocalError(error);\n  }, [error]);\n\n  // Handle validation with the provided schema\n  const validateInput = React.useCallback(\n    (value: string) => {\n      if (!schema) return;\n\n      const result = schema.safeParse(value);\n      if (!result.success) {\n        const errorMessage = result.error.errors[0]?.message || 'Invalid input';\n        setLocalError(errorMessage);\n        onValidate?.(false, value, errorMessage);\n      } else {\n        setLocalError(undefined);\n        onValidate?.(true, value);\n      }\n    },\n    [schema, onValidate],\n  );\n\n  // Handle input change\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newValue = e.target.value;\n\n    // If we have a schema, validate on change\n    if (schema) {\n      validateInput(newValue);\n    }\n\n    // Call the original onChange if provided\n    props.onChange?.(e);\n  };\n\n  // Handle blur event for validation\n  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    if (schema) {\n      validateInput(e.target.value);\n    }\n\n    // Call the original onBlur if provided\n    props.onBlur?.(e);\n  };\n\n  return (\n    <div\n      className={cn('group/field grid gap-2', containerClassName)}\n      data-invalid={hasError}\n    >\n      <label\n        htmlFor={id}\n        className={cn(\n          'text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive',\n          labelVariant === 'muted' && 'text-muted-foreground',\n          labelClassName,\n        )}\n      >\n        {label}\n        {required && <span aria-hidden=\"true\"> *</span>}\n      </label>\n\n      {description && (\n        <p className=\"text-xs text-muted-foreground\">{description}</p>\n      )}\n\n      <Input\n        id={id}\n        name={name}\n        disabled={pending || props.disabled}\n        aria-invalid={hasError}\n        aria-errormessage={hasError ? errorId : undefined}\n        aria-describedby={hint ? hintId : undefined}\n        aria-required={required}\n        className={cn(\n          // Default variant styling\n          'h-[46px] md:text-md text-md focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[#4E90F9] dark:ring-offset-black ring-offset-white',\n          variant === 'default' &&\n            'shadow-[0px_2px_2px_rgba(0,0,0,0.03),_0px_4px_7px_rgba(0,0,0,0.02)]',\n\n          // Pill variant styling - less rounded\n          variant === 'pill' &&\n            'bg-muted border-0 rounded-lg h-12 px-4 focus:ring-offset-2',\n          variant === 'pill' && coloredBorder && 'border-2 border-primary',\n          variant === 'pill' && 'placeholder:text-muted-foreground',\n\n          // Error styling for both variants\n          'group-data-[invalid=true]/field:border-destructive focus-visible:group-data-[invalid=true]/field:ring-destructive',\n          className,\n        )}\n        onChange={handleChange}\n        onBlur={handleBlur}\n        // Only pass one of value or defaultValue, not both\n        {...(isControlled ? { value } : { defaultValue })}\n        {...props}\n      />\n\n      {hint && !hasError && (\n        <p id={hintId} className=\"text-xs text-muted-foreground mt-1\">\n          {hint}\n        </p>\n      )}\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-xs\">\n          {localError || error}\n        </p>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/inputs/text-input.tsx"
    },
    {
      "path": "delta/inputs/checkbox-input.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { cn } from '@/lib/utils';\nimport type { z } from 'zod';\n\nexport interface CheckboxInputProps {\n  /** The label for the checkbox */\n  label: string;\n  /** The name of the checkbox field (used for form submission) */\n  name: string;\n  /** Optional description text to display below the checkbox */\n  description?: string;\n  /** Optional hint text to display below the checkbox */\n  hint?: string;\n  /** Error message to display (typically from Zod validation) */\n  error?: string;\n  /** Whether the field is required */\n  required?: boolean;\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean;\n  /** Default checked state */\n  defaultChecked?: boolean;\n  /** Controlled checked state */\n  checked?: boolean;\n  /** Container className for the entire component */\n  containerClassName?: string;\n  /** Checkbox className */\n  checkboxClassName?: string;\n  /** Label className */\n  labelClassName?: string;\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: 'default' | 'muted';\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<boolean>;\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, value: boolean, error?: string) => void;\n  /** Callback when checkbox state changes */\n  onCheckedChange?: (checked: boolean) => void;\n  /** ID for the checkbox */\n  id?: string;\n  /** Whether the checkbox is disabled */\n  disabled?: boolean;\n}\n\n/**\n * CheckboxInput component that integrates with Zod validation\n */\nexport function CheckboxInput({\n  label,\n  name,\n  description,\n  hint,\n  error,\n  required = false,\n  pending = false,\n  defaultChecked = false,\n  checked,\n  containerClassName,\n  checkboxClassName,\n  labelClassName,\n  labelVariant = 'default',\n  schema,\n  onValidate,\n  onCheckedChange,\n  id = name,\n  disabled = false,\n}: CheckboxInputProps) {\n  const [localError, setLocalError] = React.useState<string | undefined>(error);\n  const [isChecked, setIsChecked] = React.useState<boolean>(\n    checked !== undefined ? checked : defaultChecked,\n  );\n  const hasError = !!localError || !!error;\n  const errorId = `error-${id}`;\n  const hintId = `hint-${id}`;\n\n  // Update local error when prop changes\n  React.useEffect(() => {\n    setLocalError(error);\n  }, [error]);\n\n  // Update checked state when controlled prop changes\n  React.useEffect(() => {\n    if (checked !== undefined) {\n      setIsChecked(checked);\n    }\n  }, [checked]);\n\n  // Handle validation with the provided schema\n  const validateCheckbox = React.useCallback(\n    (value: boolean) => {\n      if (!schema) return;\n\n      const result = schema.safeParse(value);\n      if (!result.success) {\n        const errorMessage =\n          result.error.errors[0]?.message || 'Invalid selection';\n        setLocalError(errorMessage);\n        onValidate?.(false, value, errorMessage);\n      } else {\n        setLocalError(undefined);\n        onValidate?.(true, value);\n      }\n    },\n    [schema, onValidate],\n  );\n\n  // Handle checkbox change\n  const handleCheckedChange = (checked: boolean) => {\n    setIsChecked(checked);\n\n    // If we have a schema, validate on change\n    if (schema) {\n      validateCheckbox(checked);\n    }\n\n    // Call the original onCheckedChange if provided\n    onCheckedChange?.(checked);\n  };\n\n  return (\n    <div\n      className={cn('group/field space-y-2', containerClassName)}\n      data-invalid={hasError}\n    >\n      <div className=\"flex items-start space-x-2\">\n        <Checkbox\n          id={id}\n          name={name}\n          defaultChecked={checked === undefined ? defaultChecked : undefined}\n          checked={checked !== undefined ? checked : undefined}\n          disabled={pending || disabled}\n          onCheckedChange={handleCheckedChange}\n          aria-invalid={hasError}\n          aria-errormessage={hasError ? errorId : undefined}\n          aria-describedby={hint ? hintId : undefined}\n          aria-required={required}\n          className={cn(\n            'group-data-[invalid=true]/field:border-destructive focus-visible:group-data-[invalid=true]/field:ring-destructive',\n            checkboxClassName,\n          )}\n          required={required}\n        />\n        <div className=\"grid gap-1.5 leading-none\">\n          <label\n            htmlFor={id}\n            className={cn(\n              'text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive',\n              labelVariant === 'muted' && 'text-muted-foreground',\n              labelClassName,\n            )}\n          >\n            {label}\n            {required && <span aria-hidden=\"true\"> *</span>}\n          </label>\n          {description && (\n            <p className=\"text-xs text-muted-foreground\">{description}</p>\n          )}\n        </div>\n      </div>\n\n      {hint && !hasError && (\n        <p id={hintId} className=\"text-xs text-muted-foreground pl-6 mt-1\">\n          {hint}\n        </p>\n      )}\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-xs pl-6\">\n          {localError || error}\n        </p>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/inputs/checkbox-input.tsx"
    },
    {
      "path": "delta/inputs/select-input.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { cn } from '@/lib/utils';\nimport type { z } from 'zod';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select';\nimport { ChevronDown } from 'lucide-react';\n\nexport interface SelectOption {\n  value: string;\n  label: string;\n  disabled?: boolean;\n}\n\nexport interface SelectInputProps {\n  /** The label for the select field */\n  label: string;\n  /** The name of the select field (used for form submission) */\n  name: string;\n  /** Options for the select dropdown */\n  options: SelectOption[];\n  /** Optional description text to display below the label */\n  description?: string;\n  /** Optional hint text to display below the select */\n  hint?: string;\n  /** Error message to display (typically from Zod validation) */\n  error?: string;\n  /** Whether the field is required */\n  required?: boolean;\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean;\n  /** Default selected value */\n  defaultValue?: string;\n  /** Controlled selected value */\n  value?: string;\n  /** Placeholder text when no option is selected */\n  placeholder?: string;\n  /** Container className for the entire component */\n  containerClassName?: string;\n  /** Select trigger className */\n  selectClassName?: string;\n  /** Label className */\n  labelClassName?: string;\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: 'default' | 'muted';\n  /** Select variant - 'default' or 'pill' */\n  variant?: 'default' | 'pill';\n  /** Whether to show a colored border (only applies to pill variant) */\n  coloredBorder?: boolean;\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<string>;\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, value: string, error?: string) => void;\n  /** Callback when selection changes */\n  onValueChange?: (value: string) => void;\n  /** ID for the select */\n  id?: string;\n  /** Whether the select is disabled */\n  disabled?: boolean;\n}\n\n/**\n * SelectInput component that integrates with Zod validation\n */\nexport function SelectInput({\n  label,\n  name,\n  options,\n  description,\n  hint,\n  error,\n  required = false,\n  pending = false,\n  defaultValue,\n  value,\n  placeholder = 'Select an option',\n  containerClassName,\n  selectClassName,\n  labelClassName,\n  labelVariant = 'default',\n  variant = 'default',\n  coloredBorder = false,\n  schema,\n  onValidate,\n  onValueChange,\n  id = name,\n  disabled = false,\n}: SelectInputProps) {\n  const [localError, setLocalError] = React.useState<string | undefined>(error);\n  const hasError = !!localError || !!error;\n  const errorId = `error-${id}`;\n  const hintId = `hint-${id}`;\n\n  // Determine if component is controlled or uncontrolled\n  const isControlled = value !== undefined;\n\n  // Update local error when prop changes\n  React.useEffect(() => {\n    setLocalError(error);\n  }, [error]);\n\n  // Handle validation with the provided schema\n  const validateSelect = React.useCallback(\n    (value: string) => {\n      if (!schema) return;\n\n      const result = schema.safeParse(value);\n      if (!result.success) {\n        const errorMessage =\n          result.error.errors[0]?.message || 'Invalid selection';\n        setLocalError(errorMessage);\n        onValidate?.(false, value, errorMessage);\n      } else {\n        setLocalError(undefined);\n        onValidate?.(true, value);\n      }\n    },\n    [schema, onValidate],\n  );\n\n  // Handle selection change for shadcn Select\n  const handleValueChange = (newValue: string) => {\n    // If we have a schema, validate on change\n    if (schema) {\n      validateSelect(newValue);\n    }\n\n    // Call the original onValueChange if provided\n    onValueChange?.(newValue);\n  };\n\n  // Handle selection change for native select\n  const handleNativeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    const newValue = e.target.value;\n\n    // If we have a schema, validate on change\n    if (schema) {\n      validateSelect(newValue);\n    }\n\n    // Call the original onValueChange if provided\n    onValueChange?.(newValue);\n  };\n\n  // Render native select for pill variant\n  if (variant === 'pill') {\n    return (\n      <div\n        className={cn('group/field grid gap-2', containerClassName)}\n        data-invalid={hasError}\n      >\n        <label\n          htmlFor={id}\n          className={cn(\n            'text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive',\n            labelVariant === 'muted' && 'text-muted-foreground',\n            labelClassName,\n          )}\n        >\n          {label}\n          {required && <span aria-hidden=\"true\"> *</span>}\n        </label>\n\n        {description && (\n          <p className=\"text-xs text-muted-foreground\">{description}</p>\n        )}\n\n        <div className=\"relative\">\n          <select\n            id={id}\n            name={name}\n            onChange={handleNativeChange}\n            disabled={pending || disabled}\n            aria-invalid={hasError}\n            aria-errormessage={hasError ? errorId : undefined}\n            aria-describedby={hint ? hintId : undefined}\n            aria-required={required}\n            className={cn(\n              'h-[46px] md:text-md text-md focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[#4E90F9] dark:ring-offset-black ring-offset-white',\n              'bg-muted border-0 rounded-lg px-4 w-full pr-10',\n              'text-foreground',\n              'appearance-none',\n              'group-data-[invalid=true]/field:border-destructive focus-visible:group-data-[invalid=true]/field:ring-destructive',\n              selectClassName,\n            )}\n            // Only pass one of value or defaultValue, not both\n            {...(isControlled ? { value } : { defaultValue })}\n          >\n            {placeholder && (\n              <option value=\"\" disabled>\n                {placeholder}\n              </option>\n            )}\n            {options.map((option) => (\n              <option\n                key={option.value}\n                value={option.value}\n                disabled={option.disabled}\n              >\n                {option.label}\n              </option>\n            ))}\n          </select>\n          <ChevronDown className=\"absolute right-3 top-1/2 -translate-y-1/2 h-4 w-4 pointer-events-none text-muted-foreground\" />\n        </div>\n\n        {hint && !hasError && (\n          <p id={hintId} className=\"text-xs text-muted-foreground mt-1\">\n            {hint}\n          </p>\n        )}\n\n        {hasError && (\n          <p id={errorId} className=\"text-destructive text-xs\">\n            {localError || error}\n          </p>\n        )}\n      </div>\n    );\n  }\n\n  // Render shadcn Select for default variant\n  return (\n    <div\n      className={cn('group/field grid gap-2', containerClassName)}\n      data-invalid={hasError}\n    >\n      <label\n        htmlFor={id}\n        className={cn(\n          'text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive',\n          labelVariant === 'muted' && 'text-muted-foreground',\n          labelClassName,\n        )}\n      >\n        {label}\n        {required && <span aria-hidden=\"true\"> *</span>}\n      </label>\n\n      {description && (\n        <p className=\"text-xs text-muted-foreground\">{description}</p>\n      )}\n\n      <Select\n        onValueChange={handleValueChange}\n        disabled={pending || disabled}\n        // Only pass one of value or defaultValue, not both\n        {...(isControlled ? { value } : { defaultValue })}\n      >\n        <SelectTrigger\n          id={id}\n          className={cn(\n            'h-[46px] md:text-md text-md',\n            'shadow-[0px_1px_1px_rgba(0,0,0,0.03),_0px_3px_6px_rgba(0,0,0,0.02)]',\n            'border border-input hover:border-[#4E90F9] focus:border-[#4E90F9]',\n            'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[#4E90F9] dark:ring-offset-black ring-offset-white',\n            'group-data-[invalid=true]/field:border-destructive focus-visible:group-data-[invalid=true]/field:ring-destructive',\n            selectClassName,\n          )}\n          aria-invalid={hasError}\n          aria-errormessage={hasError ? errorId : undefined}\n          aria-describedby={hint ? hintId : undefined}\n          aria-required={required}\n        >\n          <SelectValue placeholder={placeholder} />\n        </SelectTrigger>\n        <SelectContent>\n          {options.map((option) => (\n            <SelectItem\n              className=\"h-[46px] md:text-md text-md\"\n              key={option.value}\n              value={option.value}\n              disabled={option.disabled}\n            >\n              {option.label}\n            </SelectItem>\n          ))}\n        </SelectContent>\n      </Select>\n\n      {hint && !hasError && (\n        <p id={hintId} className=\"text-xs text-muted-foreground mt-1\">\n          {hint}\n        </p>\n      )}\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-xs\">\n          {localError || error}\n        </p>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/inputs/select-input.tsx"
    },
    {
      "path": "delta/inputs/radio-input.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { cn } from '@/lib/utils';\nimport type { z } from 'zod';\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\n\nexport interface RadioOption {\n  value: string;\n  label: string;\n  description?: string;\n  disabled?: boolean;\n}\n\nexport interface RadioInputProps {\n  /** The label for the radio group */\n  label: string;\n  /** The name of the radio group (used for form submission) */\n  name: string;\n  /** Options for the radio group */\n  options: RadioOption[];\n  /** Optional description text to display below the label */\n  description?: string;\n  /** Error message to display (typically from Zod validation) */\n  error?: string;\n  /** Whether the field is required */\n  required?: boolean;\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean;\n  /** Default selected value */\n  defaultValue?: string;\n  /** Controlled selected value */\n  value?: string;\n  /** Container className for the entire component */\n  containerClassName?: string;\n  /** Radio group className */\n  radioGroupClassName?: string;\n  /** Radio item className */\n  radioItemClassName?: string;\n  /** Label className */\n  labelClassName?: string;\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: 'default' | 'muted';\n  /** Layout orientation - 'vertical' or 'horizontal' */\n  orientation?: 'vertical' | 'horizontal';\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<string>;\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, value: string, error?: string) => void;\n  /** Callback when selection changes */\n  onValueChange?: (value: string) => void;\n  /** ID for the radio group */\n  id?: string;\n  /** Whether the radio group is disabled */\n  disabled?: boolean;\n}\n\n/**\n * RadioInput component that integrates with Zod validation\n */\nexport function RadioInput({\n  label,\n  name,\n  options,\n  description,\n  error,\n  required = false,\n  pending = false,\n  defaultValue,\n  value,\n  containerClassName,\n  radioGroupClassName,\n  radioItemClassName,\n  labelClassName,\n  labelVariant = 'default',\n  orientation = 'vertical',\n  schema,\n  onValidate,\n  onValueChange,\n  id = name,\n  disabled = false,\n}: RadioInputProps) {\n  const [localError, setLocalError] = React.useState<string | undefined>(error);\n  const hasError = !!localError || !!error;\n  const errorId = `error-${id}`;\n\n  // Update local error when prop changes\n  React.useEffect(() => {\n    setLocalError(error);\n  }, [error]);\n\n  // Handle validation with the provided schema\n  const validateRadio = React.useCallback(\n    (value: string) => {\n      if (!schema) return;\n\n      const result = schema.safeParse(value);\n      if (!result.success) {\n        const errorMessage =\n          result.error.errors[0]?.message || 'Invalid selection';\n        setLocalError(errorMessage);\n        onValidate?.(false, value, errorMessage);\n      } else {\n        setLocalError(undefined);\n        onValidate?.(true, value);\n      }\n    },\n    [schema, onValidate],\n  );\n\n  // Handle selection change\n  const handleValueChange = (newValue: string) => {\n    // If we have a schema, validate on change\n    if (schema) {\n      validateRadio(newValue);\n    }\n\n    // Call the original onValueChange if provided\n    onValueChange?.(newValue);\n  };\n\n  return (\n    <div\n      className={cn('group/field grid gap-2', containerClassName)}\n      data-invalid={hasError}\n    >\n      <label\n        id={`${id}-label`}\n        className={cn(\n          'text-sm mb-2 font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive',\n          labelVariant === 'muted' && 'text-muted-foreground',\n          labelClassName,\n        )}\n      >\n        {label}\n        {required && <span aria-hidden=\"true\"> *</span>}\n      </label>\n\n      {description && (\n        <p className=\"text-xs text-muted-foreground\">{description}</p>\n      )}\n\n      <RadioGroup\n        defaultValue={defaultValue}\n        value={value}\n        onValueChange={handleValueChange}\n        disabled={pending || disabled}\n        className={cn(\n          orientation === 'horizontal'\n            ? 'flex items-center space-x-4'\n            : 'space-y-3',\n          radioGroupClassName,\n        )}\n        aria-labelledby={`${id}-label`}\n        aria-invalid={hasError}\n        aria-errormessage={hasError ? errorId : undefined}\n        aria-required={required}\n      >\n        {options.map((option) => (\n          <div key={option.value} className=\"flex items-start space-x-2\">\n            <RadioGroupItem\n              value={option.value}\n              id={`${id}-${option.value}`}\n              disabled={option.disabled || pending || disabled}\n              className={cn(\n                'group-data-[invalid=true]/field:border-destructive focus-visible:group-data-[invalid=true]/field:ring-destructive',\n                radioItemClassName,\n              )}\n            />\n            <div className=\"grid gap-1 leading-none\">\n              <label\n                htmlFor={`${id}-${option.value}`}\n                className=\"text-xs font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n              >\n                {option.label}\n              </label>\n              {option.description && (\n                <p className=\"text-xs text-muted-foreground\">\n                  {option.description}\n                </p>\n              )}\n            </div>\n          </div>\n        ))}\n      </RadioGroup>\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-xs\">\n          {localError || error}\n        </p>\n      )}\n\n      {/* Hidden input for form submission */}\n      <input type=\"hidden\" name={name} value={value || defaultValue || ''} />\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/inputs/radio-input.tsx"
    },
    {
      "path": "delta/inputs/switch-input.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { motion, HTMLMotionProps } from 'framer-motion';\nimport { cn } from '@/lib/utils';\nimport type { z } from 'zod';\n\n// CustomSwitch component moved into this file\ninterface CustomSwitchProps\n  extends Omit<\n    HTMLMotionProps<'button'>,\n    'checked' | 'defaultChecked' | 'onChange'\n  > {\n  checked?: boolean;\n  defaultChecked?: boolean;\n  onCheckedChange?: (checked: boolean) => void;\n  disabled?: boolean;\n  size?: 'default' | 'large';\n  /** Custom color for the active/checked state (CSS color or Tailwind class) */\n  activeColor?: string;\n  /** Switch shape variant */\n  variant?: 'pill' | 'rectangular';\n  /** Extends the clickable area beyond the visible component */\n  extendedClickArea?: boolean;\n}\n\nconst CustomSwitch = React.forwardRef<HTMLButtonElement, CustomSwitchProps>(\n  (\n    {\n      className,\n      checked,\n      defaultChecked,\n      onCheckedChange,\n      disabled,\n      size = 'default',\n      activeColor,\n      variant = 'rectangular',\n      extendedClickArea = false,\n      ...props\n    },\n    ref,\n  ) => {\n    const [isChecked, setIsChecked] = React.useState<boolean>(\n      checked !== undefined ? checked : defaultChecked || false,\n    );\n\n    // Update checked state when controlled prop changes\n    React.useEffect(() => {\n      if (checked !== undefined) {\n        setIsChecked(checked);\n      }\n    }, [checked]);\n\n    const handleClick = () => {\n      if (disabled) return;\n\n      const newChecked = !isChecked;\n      setIsChecked(newChecked);\n      onCheckedChange?.(newChecked);\n    };\n\n    // Custom active color style if provided\n    const activeColorStyle =\n      activeColor && isChecked ? { backgroundColor: activeColor } : {};\n\n    // Calculate toggle position based on size and variant\n    const toggleXPosition = () => {\n      if (size === 'large') {\n        return isChecked ? 24 : 2;\n      }\n      return isChecked ? 20 : 2;\n    };\n\n    return (\n      <motion.button\n        type=\"button\"\n        role=\"switch\"\n        aria-checked={isChecked}\n        data-state={isChecked ? 'checked' : 'unchecked'}\n        disabled={disabled}\n        ref={ref}\n        onClick={handleClick}\n        style={activeColorStyle}\n        className={cn(\n          'relative flex shrink-0 cursor-pointer border border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50',\n          variant === 'pill' ? 'rounded-full' : 'rounded-md',\n          isChecked ? (activeColor ? '' : 'bg-primary') : 'bg-muted',\n          size === 'large' ? 'h-[30px] w-[53px]' : 'h-[24px] w-[44px]',\n          extendedClickArea &&\n            \"before:absolute before:-inset-10 before:block before:content-['']\",\n          className,\n        )}\n        whileTap={{ scale: 0.95 }}\n        {...props}\n      >\n        <motion.div\n          initial={false}\n          animate={{\n            x: toggleXPosition(),\n          }}\n          transition={{\n            type: 'spring',\n            stiffness: 500,\n            damping: 30,\n          }}\n          className={cn(\n            'absolute top-0 bottom-0 left-0 m-auto shadow-md',\n            activeColor ? 'bg-white' : `dark:bg-black bg-background`,\n            variant === 'pill' ? 'rounded-full' : 'rounded-md',\n            size === 'large' ? 'h-6 w-6' : 'h-5 w-5',\n          )}\n        />\n      </motion.button>\n    );\n  },\n);\n\nCustomSwitch.displayName = 'CustomSwitch';\n\nexport interface SwitchInputProps {\n  /** The label for the switch */\n  label: string;\n  /** The name of the switch field (used for form submission) */\n  name: string;\n  /** Optional description text to display below the switch */\n  description?: string;\n  /** Optional hint text to display below the switch */\n  hint?: string;\n  /** Error message to display (typically from Zod validation) */\n  error?: string;\n  /** Whether the field is required */\n  required?: boolean;\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean;\n  /** Default checked state */\n  defaultChecked?: boolean;\n  /** Controlled checked state */\n  checked?: boolean;\n  /** Container className for the entire component */\n  containerClassName?: string;\n  /** Switch className */\n  switchClassName?: string;\n  /** Label className */\n  labelClassName?: string;\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: 'default' | 'muted';\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<boolean>;\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, value: boolean, error?: string) => void;\n  /** Callback when switch state changes */\n  onCheckedChange?: (checked: boolean) => void;\n  /** ID for the switch */\n  id?: string;\n  /** Whether the switch is disabled */\n  disabled?: boolean;\n  /** Size of the switch - 'default' or 'large' (1.2x default size) */\n  size?: 'default' | 'large';\n  /** Custom color for the active/checked state (CSS color or Tailwind class) */\n  activeColor?: string;\n  /** Switch shape variant - 'pill' or 'rectangular' */\n  variant?: 'pill' | 'rectangular';\n  /** Extends the clickable area beyond the visible component */\n  extendedClickArea?: boolean;\n}\n\n/**\n * SwitchInput component that integrates with Zod validation\n */\nexport function SwitchInput({\n  label,\n  name,\n  description,\n  hint,\n  error,\n  required = false,\n  pending = false,\n  defaultChecked = false,\n  checked,\n  containerClassName,\n  switchClassName,\n  labelClassName,\n  labelVariant = 'default',\n  schema,\n  onValidate,\n  onCheckedChange,\n  id = name,\n  disabled = false,\n  size = 'default',\n  activeColor,\n  variant = 'rectangular',\n  extendedClickArea = false, // Default to true for better mobile usability\n}: SwitchInputProps) {\n  const [localError, setLocalError] = React.useState<string | undefined>(error);\n  const [isChecked, setIsChecked] = React.useState<boolean>(\n    checked !== undefined ? checked : defaultChecked,\n  );\n  const hasError = !!localError || !!error;\n  const errorId = `error-${id}`;\n  const hintId = `hint-${id}`;\n\n  // Update local error when prop changes\n  React.useEffect(() => {\n    setLocalError(error);\n  }, [error]);\n\n  // Update checked state when controlled prop changes\n  React.useEffect(() => {\n    if (checked !== undefined) {\n      setIsChecked(checked);\n    }\n  }, [checked]);\n\n  // Handle validation with the provided schema\n  const validateSwitch = React.useCallback(\n    (value: boolean) => {\n      if (!schema) return;\n\n      const result = schema.safeParse(value);\n      if (!result.success) {\n        const errorMessage =\n          result.error.errors[0]?.message || 'Invalid selection';\n        setLocalError(errorMessage);\n        onValidate?.(false, value, errorMessage);\n      } else {\n        setLocalError(undefined);\n        onValidate?.(true, value);\n      }\n    },\n    [schema, onValidate],\n  );\n\n  // Handle switch change\n  const handleCheckedChange = (checked: boolean) => {\n    setIsChecked(checked);\n\n    // If we have a schema, validate on change\n    if (schema) {\n      validateSwitch(checked);\n    }\n\n    // Call the original onCheckedChange if provided\n    onCheckedChange?.(checked);\n  };\n\n  return (\n    <div\n      className={cn('group/field space-y-2', containerClassName)}\n      data-invalid={hasError}\n    >\n      <div className=\"flex items-center justify-between space-x-2\">\n        <div className=\"space-y-1\">\n          <label\n            htmlFor={id}\n            className={cn(\n              'text-md font-semibold leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive',\n              labelVariant === 'muted' && 'text-muted-foreground',\n              labelClassName,\n            )}\n          >\n            {label}\n            {required && <span aria-hidden=\"true\"> *</span>}\n          </label>\n          {description && (\n            <p className=\"text-xs text-muted-foreground\">{description}</p>\n          )}\n        </div>\n        <CustomSwitch\n          id={id}\n          defaultChecked={checked === undefined ? defaultChecked : undefined}\n          checked={checked !== undefined ? checked : undefined}\n          disabled={pending || disabled}\n          onCheckedChange={handleCheckedChange}\n          aria-invalid={hasError}\n          aria-errormessage={hasError ? errorId : undefined}\n          aria-describedby={hint ? hintId : undefined}\n          aria-required={required}\n          size={size}\n          activeColor={activeColor}\n          variant={variant}\n          extendedClickArea={extendedClickArea}\n          className={cn(\n            'group-data-[invalid=true]/field:border-destructive focus-visible:group-data-[invalid=true]/field:ring-destructive',\n            switchClassName,\n          )}\n        />\n      </div>\n\n      {hint && !hasError && (\n        <p id={hintId} className=\"text-xs text-muted-foreground mt-1\">\n          {hint}\n        </p>\n      )}\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-xs\">\n          {localError || error}\n        </p>\n      )}\n\n      {/* Hidden input for form submission */}\n      <input type=\"hidden\" name={name} value={isChecked ? 'true' : 'false'} />\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/inputs/switch-input.tsx"
    },
    {
      "path": "delta/inputs/textarea-input.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { Textarea } from '@/components/ui/textarea';\nimport { cn } from '@/lib/utils';\nimport type { z } from 'zod';\n\nexport interface TextareaInputProps\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {\n  /** The label for the textarea field */\n  label: string;\n  /** The name of the textarea field (used for form submission) */\n  name: string;\n  /** Optional description text to display below the label */\n  description?: string;\n  /** Optional hint text to display below the textarea */\n  hint?: string;\n  /** Error message to display (typically from Zod validation) */\n  error?: string;\n  /** Whether the field is required */\n  required?: boolean;\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean;\n  /** Default value for the textarea */\n  defaultValue?: string;\n  /** Container className for the entire component */\n  containerClassName?: string;\n  /** Label className for customizing the label */\n  labelClassName?: string;\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: 'default' | 'muted';\n  /** Textarea variant - 'default' or 'pill' */\n  variant?: 'default' | 'pill';\n  /** Whether to show a colored border (only applies to pill variant) */\n  coloredBorder?: boolean;\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<string>;\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, value: string, error?: string) => void;\n}\n\n/**\n * TextareaInput component that integrates with Zod validation\n */\nexport function TextareaInput({\n  label,\n  name,\n  description,\n  hint,\n  error,\n  required = false,\n  pending = false,\n  defaultValue,\n  containerClassName,\n  labelClassName,\n  labelVariant = 'default',\n  variant = 'default',\n  coloredBorder = false,\n  schema,\n  onValidate,\n  className,\n  id = name,\n  value,\n  ...props\n}: TextareaInputProps) {\n  const [localError, setLocalError] = React.useState<string | undefined>(error);\n  const hasError = !!localError || !!error;\n  const errorId = `error-${id}`;\n  const hintId = `hint-${id}`;\n\n  // Determine if component is controlled or uncontrolled\n  const isControlled = value !== undefined;\n\n  // Update local error when prop changes\n  React.useEffect(() => {\n    setLocalError(error);\n  }, [error]);\n\n  // Handle validation with the provided schema\n  const validateTextarea = React.useCallback(\n    (value: string) => {\n      if (!schema) return;\n\n      const result = schema.safeParse(value);\n      if (!result.success) {\n        const errorMessage = result.error.errors[0]?.message || 'Invalid input';\n        setLocalError(errorMessage);\n        onValidate?.(false, value, errorMessage);\n      } else {\n        setLocalError(undefined);\n        onValidate?.(true, value);\n      }\n    },\n    [schema, onValidate],\n  );\n\n  // Handle textarea change\n  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    const newValue = e.target.value;\n\n    // If we have a schema, validate on change\n    if (schema) {\n      validateTextarea(newValue);\n    }\n\n    // Call the original onChange if provided\n    props.onChange?.(e);\n  };\n\n  // Handle blur event for validation\n  const handleBlur = (e: React.FocusEvent<HTMLTextAreaElement>) => {\n    if (schema) {\n      validateTextarea(e.target.value);\n    }\n\n    // Call the original onBlur if provided\n    props.onBlur?.(e);\n  };\n\n  return (\n    <div\n      className={cn('group/field grid gap-2', containerClassName)}\n      data-invalid={hasError}\n    >\n      <label\n        htmlFor={id}\n        className={cn(\n          'text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive',\n          labelVariant === 'muted' && 'text-muted-foreground',\n          labelClassName,\n        )}\n      >\n        {label}\n        {required && <span aria-hidden=\"true\"> *</span>}\n      </label>\n\n      {description && (\n        <p className=\"text-xs text-muted-foreground\">{description}</p>\n      )}\n\n      <Textarea\n        id={id}\n        name={name}\n        disabled={pending || props.disabled}\n        aria-invalid={hasError}\n        aria-errormessage={hasError ? errorId : undefined}\n        aria-describedby={hint ? hintId : undefined}\n        aria-required={required}\n        className={cn(\n          'h-[46px] md:text-md text-md focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[#4E90F9] dark:ring-offset-black ring-offset-white',\n          // Default variant styling\n          variant === 'default' &&\n            'shadow-[0px_1px_1px_rgba(0,0,0,0.03),_0px_3px_6px_rgba(0,0,0,0.02)]',\n\n          // Pill variant styling - less rounded\n          variant === 'pill' && 'bg-muted border-0 rounded-lg px-4 py-3',\n          variant === 'pill' && coloredBorder && 'border-2 border-primary',\n          variant === 'pill' && 'placeholder:text-muted-foreground',\n\n          // Error styling for both variants\n          'group-data-[invalid=true]/field:border-destructive focus-visible:group-data-[invalid=true]/field:ring-destructive',\n          className,\n        )}\n        onChange={handleChange}\n        onBlur={handleBlur}\n        // Only pass one of value or defaultValue, not both\n        {...(isControlled ? { value } : { defaultValue })}\n        {...props}\n      />\n\n      {hint && !hasError && (\n        <p id={hintId} className=\"text-xs text-muted-foreground mt-1\">\n          {hint}\n        </p>\n      )}\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-xs\">\n          {localError || error}\n        </p>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/inputs/textarea-input.tsx"
    },
    {
      "path": "delta/inputs/date-input.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { format } from 'date-fns';\nimport { CalendarIcon } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { Button } from '@/components/ui/button';\nimport { Calendar } from '@/components/ui/calendar';\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover';\nimport type { z } from 'zod';\n\nexport interface DateInputProps {\n  /** The label for the date field */\n  label: string;\n  /** The name of the date field (used for form submission) */\n  name: string;\n  /** Optional description text to display below the label */\n  description?: string;\n  /** Optional hint text to display below the date picker */\n  hint?: string;\n  /** Error message to display (typically from Zod validation) */\n  error?: string;\n  /** Whether the field is required */\n  required?: boolean;\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean;\n  /** Default selected date */\n  defaultValue?: Date;\n  /** Controlled selected date */\n  value?: Date;\n  /** Placeholder text when no date is selected */\n  placeholder?: string;\n  /** Format to display the selected date (default: PP) */\n  dateFormat?: string;\n  /** Container className for the entire component */\n  containerClassName?: string;\n  /** Trigger button className */\n  triggerClassName?: string;\n  /** Label className */\n  labelClassName?: string;\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: 'default' | 'muted';\n  /** Date picker variant - 'default' or 'pill' */\n  variant?: 'default' | 'pill';\n  /** Whether to show a colored border (only applies to pill variant) */\n  coloredBorder?: boolean;\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<Date>;\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, value: Date, error?: string) => void;\n  /** Callback when date changes */\n  onValueChange?: (value: Date | undefined) => void;\n  /** ID for the date picker */\n  id?: string;\n  /** Whether the date picker is disabled */\n  disabled?: boolean;\n  /** Min date that can be selected */\n  minDate?: Date;\n  /** Max date that can be selected */\n  maxDate?: Date;\n}\n\n/**\n * DateInput component that integrates with Zod validation\n */\nexport function DateInput({\n  label,\n  name,\n  description,\n  hint,\n  error,\n  required = false,\n  pending = false,\n  defaultValue,\n  value,\n  placeholder = 'Select a date',\n  dateFormat = 'PPP',\n  containerClassName,\n  triggerClassName,\n  labelClassName,\n  labelVariant = 'default',\n  variant = 'default',\n  coloredBorder = false,\n  schema,\n  onValidate,\n  onValueChange,\n  id = name,\n  disabled = false,\n  minDate,\n  maxDate,\n}: DateInputProps) {\n  const [localError, setLocalError] = React.useState<string | undefined>(error);\n  const hasError = !!localError || !!error;\n  const errorId = `error-${id}`;\n  const hintId = `hint-${id}`;\n\n  // Determine if component is controlled or uncontrolled\n  const isControlled = value !== undefined;\n  const [date, setDate] = React.useState<Date | undefined>(\n    isControlled ? value : defaultValue,\n  );\n\n  // Update local error when prop changes\n  React.useEffect(() => {\n    setLocalError(error);\n  }, [error]);\n\n  // Update date when controlled value changes\n  React.useEffect(() => {\n    if (isControlled) {\n      setDate(value);\n    }\n  }, [isControlled, value]);\n\n  // Handle validation with the provided schema\n  const validateDate = React.useCallback(\n    (value: Date | undefined) => {\n      if (!schema || !value) return;\n\n      const result = schema.safeParse(value);\n      if (!result.success) {\n        const errorMessage = result.error.errors[0]?.message || 'Invalid date';\n        setLocalError(errorMessage);\n        onValidate?.(false, value, errorMessage);\n      } else {\n        setLocalError(undefined);\n        onValidate?.(true, value);\n      }\n    },\n    [schema, onValidate],\n  );\n\n  // Handle date change\n  const handleDateChange = (newDate: Date | undefined) => {\n    setDate(newDate);\n\n    // If we have a schema and a date, validate on change\n    if (schema && newDate) {\n      validateDate(newDate);\n    }\n\n    // Call the original onValueChange if provided\n    onValueChange?.(newDate);\n  };\n\n  return (\n    <div\n      className={cn('group/field grid gap-2', containerClassName)}\n      data-invalid={hasError}\n    >\n      <label\n        htmlFor={id}\n        className={cn(\n          'text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive',\n          labelVariant === 'muted' && 'text-muted-foreground',\n          labelClassName,\n        )}\n      >\n        {label}\n        {required && <span aria-hidden=\"true\"> *</span>}\n      </label>\n\n      {description && (\n        <p className=\"text-xs text-muted-foreground\">{description}</p>\n      )}\n\n      <Popover>\n        <PopoverTrigger asChild>\n          <Button\n            id={id}\n            variant=\"outline\"\n            disabled={pending || disabled}\n            className={cn(\n              'h-[46px] md:text-md text-md',\n              'w-full justify-start text-left font-normal',\n              !date && 'text-muted-foreground',\n              // Default variant styling\n              variant === 'default' &&\n                'shadow-[0px_1px_1px_rgba(0,0,0,0.03),_0px_3px_6px_rgba(0,0,0,0.02)]',\n\n              // Pill variant styling - less rounded\n              variant === 'pill' && 'bg-muted border-0 rounded-lg h-12 px-4',\n              variant === 'pill' && coloredBorder && 'border-2 border-primary',\n\n              // Error styling for both variants\n              'group-data-[invalid=true]/field:border-destructive focus-visible:group-data-[invalid=true]/field:ring-destructive',\n              triggerClassName,\n            )}\n            aria-invalid={hasError}\n            aria-errormessage={hasError ? errorId : undefined}\n            aria-describedby={hint ? hintId : undefined}\n            aria-required={required}\n          >\n            <CalendarIcon className=\"mr-2 h-4 w-4\" />\n            {date ? format(date, dateFormat) : <span>{placeholder}</span>}\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent className=\"w-auto p-0\" align=\"start\">\n          <Calendar\n            mode=\"single\"\n            selected={date}\n            onSelect={handleDateChange}\n            disabled={\n              disabled ||\n              pending ||\n              (minDate && maxDate\n                ? (date) => date < minDate || date > maxDate\n                : undefined)\n            }\n            initialFocus\n          />\n        </PopoverContent>\n      </Popover>\n\n      {/* Hidden input for form submission */}\n      <input type=\"hidden\" name={name} value={date ? date.toISOString() : ''} />\n\n      {hint && !hasError && (\n        <p id={hintId} className=\"text-xs text-muted-foreground mt-1\">\n          {hint}\n        </p>\n      )}\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-xs\">\n          {localError || error}\n        </p>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/inputs/date-input.tsx"
    },
    {
      "path": "delta/inputs/file-input.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { cn } from '@/lib/utils';\nimport {\n  CloudArrowUp,\n  X,\n  File,\n  Image,\n  FileText,\n  FileVideo,\n  FileAudio,\n} from '@phosphor-icons/react';\nimport type { z } from 'zod';\nimport { Button } from '@/components/ui/button';\n\nexport interface FileInputProps {\n  /** The label for the file input field */\n  label: string;\n  /** The name of the file input field (used for form submission) */\n  name: string;\n  /** Optional description text to display below the label */\n  description?: string;\n  /** Optional hint text to display below the file input */\n  hint?: string;\n  /** Error message to display (typically from Zod validation) */\n  error?: string;\n  /** Whether the field is required */\n  required?: boolean;\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean;\n  /** Container className for the entire component */\n  containerClassName?: string;\n  /** Dropzone className for the file drop area */\n  dropzoneClassName?: string;\n  /** Label className for customizing the label */\n  labelClassName?: string;\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: 'default' | 'muted';\n  /** Input variant - 'default' or 'pill' */\n  variant?: 'default' | 'pill';\n  /** Whether to show a colored border (only applies to pill variant) */\n  coloredBorder?: boolean;\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<File | File[]>;\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, files: File | File[], error?: string) => void;\n  /** Callback when files are selected */\n  onFilesSelected?: (files: File[]) => void;\n  /** ID for the file input */\n  id?: string;\n  /** Whether the file input is disabled */\n  disabled?: boolean;\n  /** Whether to accept multiple files */\n  multiple?: boolean;\n  /** Accepted file types (e.g., \"image/*\", \".pdf\", etc.) */\n  accept?: string;\n  /** Maximum file size in bytes */\n  maxSize?: number;\n  /** Maximum number of files (only applies when multiple is true) */\n  maxFiles?: number;\n  /** Custom text for the dropzone */\n  dropzoneText?: string;\n  /** Whether to show file previews */\n  showPreviews?: boolean;\n  /** Whether to show file type icons */\n  showIcons?: boolean;\n}\n\n/**\n * FileInput component that integrates with Zod validation\n */\nexport function FileInput({\n  label,\n  name,\n  description,\n  hint,\n  error,\n  required = false,\n  pending = false,\n  containerClassName,\n  dropzoneClassName,\n  labelClassName,\n  labelVariant = 'default',\n  variant = 'default',\n  coloredBorder = false,\n  schema,\n  onValidate,\n  onFilesSelected,\n  id = name,\n  disabled = false,\n  multiple = false,\n  accept,\n  maxSize,\n  maxFiles = 5,\n  dropzoneText,\n  showPreviews = true,\n  showIcons = true,\n}: FileInputProps) {\n  const [localError, setLocalError] = React.useState<string | undefined>(error);\n  const [files, setFiles] = React.useState<File[]>([]);\n  const [isDragging, setIsDragging] = React.useState(false);\n  const fileInputRef = React.useRef<HTMLInputElement>(null);\n  const hasError = !!localError || !!error;\n  const errorId = `error-${id}`;\n  const hintId = `hint-${id}`;\n\n  // Update local error when prop changes\n  React.useEffect(() => {\n    setLocalError(error);\n  }, [error]);\n\n  // Handle validation with the provided schema\n  const validateFiles = React.useCallback(\n    (files: File[]) => {\n      if (!schema) return;\n\n      try {\n        const result = schema.safeParse(multiple ? files : files[0]);\n        if (!result.success) {\n          const errorMessage =\n            result.error.errors[0]?.message || 'Invalid file(s)';\n          setLocalError(errorMessage);\n          onValidate?.(false, multiple ? files : files[0], errorMessage);\n        } else {\n          setLocalError(undefined);\n          onValidate?.(true, multiple ? files : files[0]);\n        }\n      } catch (err) {\n        setLocalError('Validation error');\n        onValidate?.(false, multiple ? files : files[0], 'Validation error');\n      }\n    },\n    [schema, onValidate, multiple],\n  );\n\n  // Handle file selection\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (!e.target.files?.length) return;\n\n    const selectedFiles = Array.from(e.target.files);\n\n    // Validate file size if maxSize is provided\n    if (maxSize) {\n      const oversizedFiles = selectedFiles.filter(\n        (file) => file.size > maxSize,\n      );\n      if (oversizedFiles.length > 0) {\n        const fileNames = oversizedFiles.map((f) => f.name).join(', ');\n        const errorMsg = `File${oversizedFiles.length > 1 ? 's' : ''} too large: ${fileNames}`;\n        setLocalError(errorMsg);\n        return;\n      }\n    }\n\n    // Validate number of files if multiple is true\n    if (multiple && maxFiles && selectedFiles.length > maxFiles) {\n      setLocalError(`You can only upload up to ${maxFiles} files`);\n      return;\n    }\n\n    // Update files state\n    const newFiles = multiple ? [...files, ...selectedFiles] : selectedFiles;\n\n    // Check if we're exceeding maxFiles after combining with existing files\n    if (multiple && maxFiles && newFiles.length > maxFiles) {\n      setLocalError(`You can only upload up to ${maxFiles} files`);\n      return;\n    }\n\n    setFiles(newFiles);\n\n    // Validate with schema if provided\n    if (schema) {\n      validateFiles(newFiles);\n    }\n\n    // Call onFilesSelected callback\n    onFilesSelected?.(newFiles);\n\n    // Reset the input value to allow selecting the same file again\n    if (fileInputRef.current) {\n      fileInputRef.current.value = '';\n    }\n  };\n\n  // Handle drag events\n  const handleDragEnter = (e: React.DragEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n    if (!disabled && !pending) {\n      setIsDragging(true);\n    }\n  };\n\n  const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setIsDragging(false);\n  };\n\n  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n    if (!disabled && !pending) {\n      e.dataTransfer.dropEffect = 'copy';\n      setIsDragging(true);\n    }\n  };\n\n  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setIsDragging(false);\n\n    if (disabled || pending) return;\n\n    const droppedFiles = Array.from(e.dataTransfer.files);\n\n    // Validate file types if accept is provided\n    if (accept) {\n      const acceptedTypes = accept.split(',').map((type) => type.trim());\n      const invalidFiles = droppedFiles.filter((file) => {\n        return !acceptedTypes.some((type) => {\n          if (type.startsWith('.')) {\n            // Check file extension\n            return file.name.toLowerCase().endsWith(type.toLowerCase());\n          } else if (type.includes('/*')) {\n            // Check file type category (e.g., \"image/*\")\n            const category = type.split('/')[0];\n            return file.type.startsWith(`${category}/`);\n          } else {\n            // Check exact mime type\n            return file.type === type;\n          }\n        });\n      });\n\n      if (invalidFiles.length > 0) {\n        const fileNames = invalidFiles.map((f) => f.name).join(', ');\n        const errorMsg = `Invalid file type${invalidFiles.length > 1 ? 's' : ''}: ${fileNames}`;\n        setLocalError(errorMsg);\n        return;\n      }\n    }\n\n    // Validate file size if maxSize is provided\n    if (maxSize) {\n      const oversizedFiles = droppedFiles.filter((file) => file.size > maxSize);\n      if (oversizedFiles.length > 0) {\n        const fileNames = oversizedFiles.map((f) => f.name).join(', ');\n        const errorMsg = `File${oversizedFiles.length > 1 ? 's' : ''} too large: ${fileNames}`;\n        setLocalError(errorMsg);\n        return;\n      }\n    }\n\n    // Validate number of files if multiple is true\n    const newFiles = multiple ? [...files, ...droppedFiles] : droppedFiles;\n\n    if (multiple && maxFiles && newFiles.length > maxFiles) {\n      setLocalError(`You can only upload up to ${maxFiles} files`);\n      return;\n    }\n\n    setFiles(newFiles);\n\n    // Validate with schema if provided\n    if (schema) {\n      validateFiles(newFiles);\n    }\n\n    // Call onFilesSelected callback\n    onFilesSelected?.(newFiles);\n  };\n\n  // Handle file removal\n  const removeFile = (index: number) => {\n    const newFiles = [...files];\n    newFiles.splice(index, 1);\n    setFiles(newFiles);\n\n    // Validate with schema if provided\n    if (schema) {\n      validateFiles(newFiles);\n    }\n\n    // Call onFilesSelected callback\n    onFilesSelected?.(newFiles);\n  };\n\n  // Get appropriate icon for file type\n  const getFileIcon = (file: File) => {\n    if (file.type.startsWith('image/')) {\n      return <Image weight=\"regular\" className=\"h-5 w-5\" />;\n    } else if (file.type.startsWith('video/')) {\n      return <FileVideo weight=\"regular\" className=\"h-5 w-5\" />;\n    } else if (file.type.startsWith('audio/')) {\n      return <FileAudio weight=\"regular\" className=\"h-5 w-5\" />;\n    } else if (file.type.startsWith('text/') || file.type.includes('pdf')) {\n      return <FileText weight=\"regular\" className=\"h-5 w-5\" />;\n    } else {\n      return <File weight=\"regular\" className=\"h-5 w-5\" />;\n    }\n  };\n\n  // Format file size\n  const formatFileSize = (bytes: number) => {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return (\n      Number.parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]\n    );\n  };\n\n  // Generate image preview URL\n  const getImagePreview = (file: File) => {\n    if (file.type.startsWith('image/')) {\n      return URL.createObjectURL(file);\n    }\n    return null;\n  };\n\n  return (\n    <div\n      className={cn('group/field grid gap-2', containerClassName)}\n      data-invalid={hasError}\n    >\n      <label\n        htmlFor={id}\n        className={cn(\n          'text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive',\n          labelVariant === 'muted' && 'text-muted-foreground',\n          labelClassName,\n        )}\n      >\n        {label}\n        {required && <span aria-hidden=\"true\"> *</span>}\n      </label>\n\n      {description && (\n        <p className=\"text-xs text-muted-foreground\">{description}</p>\n      )}\n\n      <div\n        className={cn(\n          'relative cursor-pointer transition-colors',\n          'flex flex-col items-center justify-center gap-2 text-center p-4 rounded-lg',\n          // Default variant with single dashed border\n          variant === 'default' &&\n            'border-2 border-dashed border-muted-foreground/25',\n          variant === 'default' &&\n            'shadow-[0px_1px_1px_rgba(0,0,0,0.03),_0px_3px_6px_rgba(0,0,0,0.02)]',\n\n          // Pill variant with solid border (not dashed)\n          variant === 'pill' &&\n            'bg-muted border border-solid border-transparent rounded-lg',\n          variant === 'pill' && coloredBorder && 'border-primary/30',\n\n          // Dragging state\n          isDragging && 'border-primary/50 bg-primary/5',\n\n          // Error state\n          hasError &&\n            'border-destructive/50 group-data-[invalid=true]/field:border-destructive',\n\n          // Disabled state\n          (disabled || pending) && 'opacity-60 cursor-not-allowed',\n\n          dropzoneClassName,\n        )}\n        onDragEnter={handleDragEnter}\n        onDragOver={handleDragOver}\n        onDragLeave={handleDragLeave}\n        onDrop={handleDrop}\n        onClick={() => !disabled && !pending && fileInputRef.current?.click()}\n        aria-invalid={hasError}\n        aria-errormessage={hasError ? errorId : undefined}\n        aria-describedby={hint ? hintId : undefined}\n      >\n        <input\n          ref={fileInputRef}\n          id={id}\n          name={name}\n          type=\"file\"\n          accept={accept}\n          multiple={multiple}\n          disabled={disabled || pending}\n          className=\"sr-only\"\n          onChange={handleFileChange}\n          aria-required={required}\n        />\n\n        <CloudArrowUp\n          weight=\"regular\"\n          className=\"h-10 w-10 text-muted-foreground/70\"\n        />\n\n        <div className=\"space-y-1\">\n          <p className=\"text-md font-medium text-foreground\">\n            {dropzoneText || (\n              <>\n                <span className=\"text-primary\">Click to upload</span> or drag\n                and drop\n              </>\n            )}\n          </p>\n          <p className=\"text-xs text-muted-foreground\">\n            {multiple\n              ? `Upload up to ${maxFiles} file${maxFiles !== 1 ? 's' : ''}`\n              : 'Upload a file'}\n            {accept && ` (${accept.replace(/,/g, ', ')})`}\n            {maxSize && ` up to ${formatFileSize(maxSize)}`}\n          </p>\n        </div>\n      </div>\n\n      {/* File previews */}\n      {showPreviews && files.length > 0 && (\n        <div className=\"mt-2 space-y-2\">\n          {files.map((file, index) => {\n            const imagePreview = getImagePreview(file);\n\n            return (\n              <div\n                key={`${file.name}-${index}`}\n                className={cn(\n                  'flex items-center justify-between p-2',\n                  variant === 'pill'\n                    ? 'bg-muted rounded-lg'\n                    : 'bg-muted/50 border border-border rounded',\n                )}\n              >\n                <div className=\"flex items-center gap-2 overflow-hidden\">\n                  {showIcons && (\n                    <div className=\"flex-shrink-0 text-muted-foreground\">\n                      {getFileIcon(file)}\n                    </div>\n                  )}\n\n                  {imagePreview && (\n                    <div className=\"h-10 w-10 rounded overflow-hidden flex-shrink-0 bg-background\">\n                      <img\n                        src={imagePreview || '/placeholder.svg'}\n                        alt={file.name}\n                        className=\"h-full w-full object-cover\"\n                      />\n                    </div>\n                  )}\n\n                  <div className=\"min-w-0 flex-1\">\n                    <p className=\"text-md font-medium truncate\">{file.name}</p>\n                    <p className=\"text-xs text-muted-foreground\">\n                      {formatFileSize(file.size)}\n                    </p>\n                  </div>\n                </div>\n\n                <Button\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"h-8 w-8 rounded-full flex-shrink-0 transition-none hover:bg-transparent\"\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    removeFile(index);\n                  }}\n                  disabled={disabled || pending}\n                  aria-label={`Remove ${file.name}`}\n                >\n                  <X weight=\"regular\" className=\"h-4 w-4\" />\n                </Button>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {hint && !hasError && (\n        <p id={hintId} className=\"text-xs text-muted-foreground mt-1\">\n          {hint}\n        </p>\n      )}\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-xs\">\n          {localError || error}\n        </p>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/inputs/file-input.tsx"
    },
    {
      "path": "delta/inputs/otp-input.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { cn } from '@/lib/utils';\nimport type { z } from 'zod';\n\nexport interface OTPInputProps {\n  /** The label for the OTP input field */\n  label: string;\n  /** The name of the OTP input field (used for form submission) */\n  name: string;\n  /** Optional description text to display below the label */\n  description?: string;\n  /** Optional hint text to display below the OTP input */\n  hint?: string;\n  /** Error message to display (typically from Zod validation) */\n  error?: string;\n  /** Whether the field is required */\n  required?: boolean;\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean;\n  /** Default value for the OTP input */\n  defaultValue?: string;\n  /** Controlled value */\n  value?: string;\n  /** Container className for the entire component */\n  containerClassName?: string;\n  /** Label className for customizing the label */\n  labelClassName?: string;\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: 'default' | 'muted';\n  /** Input variant - 'default' or 'pill' */\n  variant?: 'default' | 'pill';\n  /** Whether to show a colored border (only applies to pill variant) */\n  coloredBorder?: boolean;\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<string>;\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, value: string, error?: string) => void;\n  /** Callback when OTP value changes */\n  onChange?: (value: string) => void;\n  /** Callback when OTP is completed */\n  onComplete?: (value: string) => void;\n  /** ID for the OTP input */\n  id?: string;\n  /** Whether the OTP input is disabled */\n  disabled?: boolean;\n  /** Length of the OTP code */\n  length?: number;\n  /** Character to display when input is masked */\n  maskChar?: string;\n  /** Whether to mask the input (like a password) */\n  mask?: boolean;\n  /** Whether to auto-focus the first input on mount */\n  autoFocus?: boolean;\n  /** Whether to render with a separator between groups */\n  separator?: boolean;\n  /** Size of each group of digits */\n  groupSize?: number;\n  /** Whether to automatically submit the form when OTP is completed */\n  autoSubmit?: boolean;\n}\n\n/**\n * OTPInput component that integrates with Zod validation\n */\nexport function OTPInput({\n  label,\n  name,\n  description,\n  hint,\n  error,\n  required = false,\n  pending = false,\n  defaultValue = '',\n  value,\n  containerClassName,\n  labelClassName,\n  labelVariant = 'default',\n  variant = 'default',\n  coloredBorder = false,\n  schema,\n  onValidate,\n  onChange,\n  onComplete,\n  id = name,\n  disabled = false,\n  length = 6,\n  maskChar = '•',\n  mask = false,\n  autoFocus = false,\n  separator = false,\n  groupSize = 3,\n  autoSubmit = false,\n}: OTPInputProps) {\n  const [localError, setLocalError] = React.useState<string | undefined>(error);\n  const [otpValue, setOtpValue] = React.useState<string[]>(\n    (value || defaultValue || '')\n      .split('')\n      .slice(0, length)\n      .concat(Array(length).fill(''))\n      .slice(0, length),\n  );\n  const inputRefs = React.useRef<(HTMLInputElement | null)[]>([]);\n  const hasError = !!localError || !!error;\n  const errorId = `error-${id}`;\n  const hintId = `hint-${id}`;\n  const formRef = React.useRef<HTMLFormElement | null>(null);\n\n  // Determine if component is controlled or uncontrolled\n  const isControlled = value !== undefined;\n\n  // Update local error when prop changes\n  React.useEffect(() => {\n    setLocalError(error);\n  }, [error]);\n\n  // Update OTP value when controlled value changes\n  React.useEffect(() => {\n    if (isControlled && value !== undefined) {\n      setOtpValue(\n        value\n          .split('')\n          .slice(0, length)\n          .concat(Array(length).fill(''))\n          .slice(0, length),\n      );\n    }\n  }, [isControlled, value, length]);\n\n  // Find the closest form element\n  React.useEffect(() => {\n    if (autoSubmit) {\n      const input = inputRefs.current[0];\n      if (input) {\n        let element: HTMLElement | null = input;\n        while (element && element.tagName !== 'FORM') {\n          element = element.parentElement;\n        }\n        formRef.current = element as HTMLFormElement;\n      }\n    }\n  }, [autoSubmit]);\n\n  // Handle validation with the provided schema\n  const validateOTP = React.useCallback(\n    (value: string) => {\n      if (!schema) return;\n\n      // Only validate if all digits are entered or if the form has been submitted\n      if (value.length === length) {\n        const result = schema.safeParse(value);\n        if (!result.success) {\n          const errorMessage =\n            result.error.errors[0]?.message || 'Invalid code';\n          setLocalError(errorMessage);\n          onValidate?.(false, value, errorMessage);\n        } else {\n          setLocalError(undefined);\n          onValidate?.(true, value);\n        }\n      } else {\n        // Clear error while user is still typing\n        setLocalError(undefined);\n      }\n    },\n    [schema, onValidate, length],\n  );\n\n  // Handle input change\n  const handleChange = (\n    index: number,\n    e: React.ChangeEvent<HTMLInputElement>,\n  ) => {\n    const value = e.target.value;\n\n    // Handle paste event (detected by multiple characters)\n    if (value.length > 1) {\n      handlePaste(index, value);\n      return;\n    }\n\n    // Update the OTP value\n    const newOtpValue = [...otpValue];\n    newOtpValue[index] = value;\n    setOtpValue(newOtpValue);\n\n    // Move focus to the next input if a value was entered\n    if (value && index < length - 1) {\n      inputRefs.current[index + 1]?.focus();\n    }\n\n    // Call onChange with the new value - ensure it's a clean string\n    const newValue = newOtpValue.join('');\n    onChange?.(newValue);\n\n    // Check if OTP is complete\n    if (newOtpValue.filter(Boolean).length === length) {\n      onComplete?.(newValue);\n\n      // Auto-submit the form if enabled\n      if (autoSubmit && formRef.current) {\n        setTimeout(() => {\n          formRef.current?.requestSubmit();\n        }, 100);\n      }\n    }\n  };\n\n  // Handle paste event\n  const handlePaste = (startIndex: number, pastedValue: string) => {\n    // Clean the pasted value to only include digits and letters\n    const cleanedValue = pastedValue.replace(/\\s/g, '');\n\n    // Create a new OTP value array\n    const newOtpValue = [...otpValue];\n\n    // Fill in the OTP value with the pasted characters\n    for (\n      let i = 0;\n      i < Math.min(cleanedValue.length, length - startIndex);\n      i++\n    ) {\n      newOtpValue[startIndex + i] = cleanedValue[i];\n    }\n\n    setOtpValue(newOtpValue);\n\n    // Focus the next empty input or the last input\n    const nextEmptyIndex = newOtpValue.findIndex(\n      (v, i) => i >= startIndex && !v,\n    );\n    if (nextEmptyIndex !== -1 && nextEmptyIndex < length) {\n      inputRefs.current[nextEmptyIndex]?.focus();\n    } else {\n      inputRefs.current[length - 1]?.focus();\n    }\n\n    // Call onChange with the new value\n    const newValue = newOtpValue.join('');\n    onChange?.(newValue);\n\n    // Validate if we have a schema\n    if (schema) {\n      validateOTP(newValue);\n    }\n\n    // Check if OTP is complete and trigger onComplete only once\n    if (newOtpValue.every((v) => v) && newOtpValue.length === length) {\n      onComplete?.(newValue);\n    }\n  };\n\n  // Handle key down event\n  const handleKeyDown = (\n    index: number,\n    e: React.KeyboardEvent<HTMLInputElement>,\n  ) => {\n    // Move focus to the previous input on backspace if the current input is empty\n    if (e.key === 'Backspace') {\n      if (!otpValue[index] && index > 0) {\n        inputRefs.current[index - 1]?.focus();\n\n        // Clear the previous input\n        const newOtpValue = [...otpValue];\n        newOtpValue[index - 1] = '';\n        setOtpValue(newOtpValue);\n\n        // Call onChange with the new value\n        onChange?.(newOtpValue.join(''));\n      }\n\n      // Don't prevent default for backspace when there's content to delete\n      if (!otpValue[index]) {\n        e.preventDefault();\n      }\n    }\n\n    // Prevent arrow key navigation\n    else if (\n      e.key === 'ArrowRight' ||\n      e.key === 'ArrowLeft' ||\n      e.key === 'ArrowUp' ||\n      e.key === 'ArrowDown'\n    ) {\n      e.preventDefault();\n    }\n  };\n\n  // Handle focus event\n  const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {\n    // Select the input content on focus\n    e.target.select();\n  };\n\n  // Create input groups based on groupSize\n  const inputGroups = [];\n  for (let i = 0; i < length; i += groupSize) {\n    const group = [];\n    for (let j = 0; j < groupSize && i + j < length; j++) {\n      group.push(i + j);\n    }\n    inputGroups.push(group);\n  }\n\n  return (\n    <div\n      className={cn('group/field grid gap-2', containerClassName)}\n      data-invalid={hasError}\n    >\n      <label\n        htmlFor={`${id}-0`}\n        className={cn(\n          'text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive',\n          labelVariant === 'muted' && 'text-muted-foreground',\n          labelClassName,\n        )}\n      >\n        {label}\n        {required && <span aria-hidden=\"true\"> *</span>}\n      </label>\n\n      {description && (\n        <p className=\"text-sm text-muted-foreground\">{description}</p>\n      )}\n\n      <div className=\"flex items-center justify-center space-x-1.5 sm:space-x-2\">\n        {inputGroups.map((group, groupIndex) => (\n          <React.Fragment key={`group-${groupIndex}`}>\n            <div className=\"flex items-center space-x-1.5 sm:space-x-2\">\n              {group.map((index) => (\n                <div key={`input-${index}`} className=\"relative\">\n                  <input\n                    ref={(el: HTMLInputElement | null) => {\n                      if (inputRefs.current) {\n                        inputRefs.current[index] = el;\n                      }\n                    }}\n                    id={index === 0 ? `${id}-0` : `${id}-${index}`}\n                    name={index === 0 ? name : `${name}-${index}`}\n                    type=\"text\"\n                    inputMode=\"numeric\"\n                    pattern=\"[0-9]*\"\n                    maxLength={1}\n                    autoComplete=\"off\" // Add this line to prevent browser from saving input\n                    value={mask && otpValue[index] ? maskChar : otpValue[index]}\n                    onChange={(e) => handleChange(index, e)}\n                    onKeyDown={(e) => handleKeyDown(index, e)}\n                    onFocus={handleFocus}\n                    disabled={pending || disabled}\n                    aria-invalid={hasError}\n                    aria-errormessage={hasError ? errorId : undefined}\n                    aria-describedby={hint ? hintId : undefined}\n                    aria-required={required}\n                    autoFocus={autoFocus && index === 0}\n                    className={cn(\n                      'w-9 h-10 sm:w-10 sm:h-12 bg-background text-center text-base sm:text-lg font-medium',\n                      'focus:outline-none focus:ring-2 focus:ring-[#4E90F9] dark:ring-offset-black ring-offset-white',\n                      // Default variant styling\n                      variant === 'default' &&\n                        'border border-input rounded-md shadow-[0px_1px_1px_rgba(0,0,0,0.03),_0px_3px_6px_rgba(0,0,0,0.02)]',\n                      // Pill variant styling\n                      variant === 'pill' &&\n                        'bg-muted border-0 rounded-lg focus:ring-offset-2',\n                      variant === 'pill' &&\n                        coloredBorder &&\n                        'border-2 border-primary',\n                      // Error styling for both variants\n                      'group-data-[invalid=true]/field:border-destructive focus-visible:group-data-[invalid=true]/field:ring-destructive',\n                    )}\n                  />\n                  {/* Animated caret for empty inputs */}\n                </div>\n              ))}\n            </div>\n            {separator && groupIndex < inputGroups.length - 1 && (\n              <div className=\"text-muted-foreground text-base sm:text-lg font-medium\">\n                -\n              </div>\n            )}\n          </React.Fragment>\n        ))}\n      </div>\n\n      {/* Hidden input for form submission with the complete value */}\n      <input\n        type=\"hidden\"\n        name={name}\n        value={otpValue.join('')}\n        data-testid={`${id}-hidden`}\n      />\n\n      {hint && !hasError && (\n        <p id={hintId} className=\"text-xs text-muted-foreground mt-1\">\n          {hint}\n        </p>\n      )}\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-sm\">\n          {localError || error}\n        </p>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/inputs/otp-input.tsx"
    }
  ]
}