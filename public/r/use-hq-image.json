{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-hq-image",
  "type": "registry:hook",
  "title": "useHqImage",
  "description": "A hook for use-hq-image",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "delta/hooks/use-hq-image.ts",
      "content": "'use client';\n\nimport { useState, useCallback, useEffect, useRef } from 'react';\n\nexport type HqImage = { url: string };\n\n// Create a global cache that persists between hook instances\n// This will store loaded images across component instances\nconst imageCache = new Map<string, HTMLImageElement>();\n\n/**\n * A hook that returns high-quality images from a curated collection\n * with silent retry functionality and image caching\n * @param initialIndex Optional specific index to use instead of random selection\n * @param maxRetries Maximum number of retries for failed images (default: 5)\n * @returns An object containing the selected image, functions to refresh it, and a method to get multiple random images\n */\nexport function useHqImage(initialIndex?: number, maxRetries: number = 5) {\n  // Track failed image URLs to avoid reusing them\n  const failedUrls = useRef<Set<string>>(new Set());\n\n  // Track retry attempts for current image\n  const retryCount = useRef<number>(0);\n\n  // Track retry attempts for grid images\n  const gridRetryCount = useRef<Map<string, number>>(new Map());\n\n  // Track loaded status for images\n  const loadedImages = useRef<Set<string>>(new Set());\n\n  // Function to preload an image and add it to the cache\n  const preloadImage = useCallback((url: string): Promise<HTMLImageElement> => {\n    // If image is already in cache, return it\n    if (imageCache.has(url)) {\n      return Promise.resolve(imageCache.get(url)!);\n    }\n\n    // Create a new promise to load the image\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n\n      img.onload = () => {\n        // Add to cache on successful load\n        imageCache.set(url, img);\n        loadedImages.current.add(url);\n        resolve(img);\n      };\n\n      img.onerror = () => {\n        reject(new Error(`Failed to load image: ${url}`));\n      };\n\n      img.src = url;\n    });\n  }, []);\n\n  // Get a random image from the collection, avoiding failed URLs\n  const getRandomImage = useCallback((): HqImage => {\n    // Filter out failed URLs if we have any\n    const availableImages =\n      failedUrls.current.size > 0\n        ? exampleImages.filter((img) => !failedUrls.current.has(img.url))\n        : exampleImages;\n\n    // If we've exhausted all images, reset failed URLs and try again\n    if (availableImages.length === 0) {\n      console.warn(\n        'All images have failed to load. Resetting failed URLs list.',\n      );\n      failedUrls.current.clear();\n      return exampleImages[Math.floor(Math.random() * exampleImages.length)];\n    }\n\n    const randomIndex = Math.floor(Math.random() * availableImages.length);\n    const selectedImage = availableImages[randomIndex];\n\n    // Try to preload the image (don't await, let it load in background)\n    preloadImage(selectedImage.url).catch(() => {\n      // If preloading fails, it will be handled by the error handlers\n    });\n\n    return selectedImage;\n  }, [preloadImage]);\n\n  // Initialize state with either the specified image or a random one\n  const [image, setImage] = useState<HqImage>(() => {\n    if (\n      initialIndex !== undefined &&\n      initialIndex >= 0 &&\n      initialIndex < exampleImages.length\n    ) {\n      const selectedImage = exampleImages[initialIndex];\n      // Try to preload the image (don't await, let it load in background)\n      preloadImage(selectedImage.url).catch(() => {\n        // If preloading fails, it will be handled by the error handlers\n      });\n      return selectedImage;\n    }\n    return getRandomImage();\n  });\n\n  // Function to refresh the image with a new random one\n  const refreshImage = useCallback(() => {\n    // Reset retry count when manually refreshing\n    retryCount.current = 0;\n    setImage(getRandomImage());\n  }, [getRandomImage]);\n\n  // Function to handle image load errors and retry\n  const handleImageError = useCallback(\n    (imageUrl: string): HqImage => {\n      // Add to failed URLs set\n      failedUrls.current.add(imageUrl);\n\n      // Log warning\n      console.warn(`Image failed to load: ${imageUrl}. Trying another image.`);\n\n      // Get a new image\n      return getRandomImage();\n    },\n    [getRandomImage],\n  );\n\n  // New function to get multiple unique random images\n  const getRandomImages = useCallback(\n    (count: number): HqImage[] => {\n      // Reset grid retry tracking when getting new batch\n      gridRetryCount.current.clear();\n\n      // Ensure we don't request more images than available\n      const requestCount = Math.min(count, exampleImages.length);\n\n      // Create a copy of the images array to shuffle, filtering out known failed URLs\n      const availableImages =\n        failedUrls.current.size > 0\n          ? exampleImages.filter((img) => !failedUrls.current.has(img.url))\n          : exampleImages;\n\n      const shuffled = [...availableImages];\n\n      // Fisher-Yates shuffle algorithm\n      for (let i = shuffled.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n      }\n\n      // Get the selected images\n      const selectedImages = shuffled.slice(0, requestCount);\n\n      // Preload all selected images in the background\n      selectedImages.forEach((img) => {\n        preloadImage(img.url).catch(() => {\n          // If preloading fails, it will be handled by the error handlers\n        });\n      });\n\n      // Return the selected images\n      return selectedImages;\n    },\n    [preloadImage],\n  );\n\n  // Function to retry a specific grid image\n  const retryGridImage = useCallback(\n    (imageUrl: string): HqImage => {\n      // Track retry count for this specific URL\n      const currentRetries = gridRetryCount.current.get(imageUrl) || 0;\n\n      if (currentRetries < maxRetries) {\n        // Increment retry count\n        gridRetryCount.current.set(imageUrl, currentRetries + 1);\n        console.warn(\n          `Grid image failed to load: ${imageUrl}. Retry ${currentRetries + 1}/${maxRetries}`,\n        );\n\n        // Get a new image\n        return getRandomImage();\n      } else {\n        // Max retries reached, mark as failed\n        failedUrls.current.add(imageUrl);\n        console.warn(\n          `Grid image failed after ${maxRetries} retries: ${imageUrl}`,\n        );\n\n        // Get a new image\n        return getRandomImage();\n      }\n    },\n    [getRandomImage, maxRetries],\n  );\n\n  // Function to check if an image is cached\n  const isImageCached = useCallback((url: string): boolean => {\n    return imageCache.has(url);\n  }, []);\n\n  // Function to get an image from cache\n  const getImageFromCache = useCallback(\n    (url: string): HTMLImageElement | null => {\n      return imageCache.get(url) || null;\n    },\n    [],\n  );\n\n  // Create a wrapped version of the hook's return value with retry and caching functionality\n  const hookWithRetry = {\n    // Original image with retry functionality\n    image,\n\n    // Original refresh function\n    refreshImage,\n\n    // Original get random images function\n    getRandomImages,\n\n    // All images\n    allImages: exampleImages,\n\n    // New functions for retry handling\n    handleImageError,\n    retryGridImage,\n\n    // Function to check if an image URL has failed\n    hasImageFailed: (url: string) => failedUrls.current.has(url),\n\n    // Function to reset all failed URLs\n    resetFailedImages: () => {\n      failedUrls.current.clear();\n      retryCount.current = 0;\n      gridRetryCount.current.clear();\n      console.log('Reset all failed image tracking');\n    },\n\n    // Cache-related functions\n    preloadImage,\n    isImageCached,\n    getImageFromCache,\n\n    // Function to clear the image cache\n    clearImageCache: () => {\n      imageCache.clear();\n      loadedImages.current.clear();\n      console.log('Image cache cleared');\n    },\n\n    // Get cache stats\n    getCacheStats: () => ({\n      cacheSize: imageCache.size,\n      cachedUrls: Array.from(imageCache.keys()),\n    }),\n  };\n\n  return hookWithRetry;\n}\n\n// Hardcoded image collection\nexport const exampleImages = [\n  {\n    url: 'https://images.unsplash.com/photo-1727341554370-80e0fe9ad082?q=80&w=2276&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1640680608781-2e4199dd1579?q=80&w=3087&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1726083085160-feeb4e1e5b00?q=80&w=3024&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1562016600-ece13e8ba570?q=80&w=2838&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1624344965199-ed40391d20f2?q=80&w=2960&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1689553079282-45df1b35741b?q=80&w=3087&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1721968317938-cf8c60fccd1a?q=80&w=2728&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1677338354108-223e807fb1bd?q=80&w=3087&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  },\n  {\n    url: 'https://images.aiscribbles.com/34fe5695dbc942628e3cad9744e8ae13.png?v=60d084',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1734189743286-a39af55f48c3',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1733309544294-700e617cba60',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1738916218012-4e580beae18e',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1735905131227-88f4942d1d38',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1734760418281-62c3f2279296',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1741017162002-fac8e37509f9',\n  },\n  {\n    url: 'https://images.unsplash.com/photo-1732905176274-ffdcffbeab41',\n  },\n];\n",
      "type": "registry:hook",
      "target": "delta/hooks/use-hq-image.ts"
    }
  ]
}
