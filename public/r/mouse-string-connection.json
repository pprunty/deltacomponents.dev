{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "mouse-string-connection",
  "type": "registry:component",
  "author": "patrick prunty <https://www.patrickprunty.com>",
  "files": [
    {
      "path": "registry/landing-page/mouse-string-connection.tsx",
      "content": "\"use client\"\n\nimport type React from \"react\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface MouseStringConnectionProps {\n  children: React.ReactNode\n  className?: string\n  strokeColor?: string\n  strokeWidth?: number\n  dashArray?: [number, number]\n  maxOpacity?: number\n  curveIntensity?: number\n  arrowSize?: number\n  fadeDistance?: number\n  disabled?: boolean\n}\n\ninterface MousePosition {\n  x: number | null\n  y: number | null\n}\n\nexport default function MouseStringConnection({\n  children,\n  className,\n  strokeColor = \"hsl(var(--foreground) / 0.75)\",\n  strokeWidth = 1,\n  dashArray = [10, 4],\n  maxOpacity = 0.75,\n  curveIntensity = 0.5,\n  arrowSize = 10,\n  fadeDistance = 750,\n  disabled = false,\n}: MouseStringConnectionProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const targetRef = useRef<HTMLDivElement>(null)\n  const animationRef = useRef<number | undefined>(undefined)\n  const [mouse, setMouse] = useState<MousePosition>({ x: null, y: null })\n\n  // Helper function to get the actual CSS variable value\n  const getForegroundColor = useCallback((opacity: number) => {\n    if (typeof window === \"undefined\") return `rgba(30, 41, 59, ${opacity})`\n\n    const style = getComputedStyle(document.documentElement)\n    const foregroundValue = style.getPropertyValue(\"--foreground\").trim()\n\n    if (foregroundValue) {\n      // Convert the HSL values to rgba\n      // foregroundValue should be something like \"#1e293b\" or \"30 41 59\" (for hsl format)\n      if (foregroundValue.startsWith(\"#\")) {\n        // Hex color - convert to rgb\n        const hex = foregroundValue.replace(\"#\", \"\")\n        const r = parseInt(hex.substr(0, 2), 16)\n        const g = parseInt(hex.substr(2, 2), 16)\n        const b = parseInt(hex.substr(4, 2), 16)\n        return `rgba(${r}, ${g}, ${b}, ${opacity})`\n      } else {\n        // Assume it's space-separated RGB values like \"30 41 59\"\n        const [r, g, b] = foregroundValue\n          .split(\" \")\n          .map((v) => parseInt(v.trim()))\n        return `rgba(${r || 30}, ${g || 41}, ${b || 59}, ${opacity})`\n      }\n    }\n\n    // Fallback\n    return `rgba(30, 41, 59, ${opacity})`\n  }, [])\n\n  const updateCanvasSize = useCallback(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const { devicePixelRatio = 1 } = window\n    const rect = canvas.getBoundingClientRect()\n\n    canvas.width = rect.width * devicePixelRatio\n    canvas.height = rect.height * devicePixelRatio\n    canvas.style.width = `${rect.width}px`\n    canvas.style.height = `${rect.height}px`\n\n    const ctx = canvas.getContext(\"2d\")\n    if (ctx) {\n      ctx.scale(devicePixelRatio, devicePixelRatio)\n    }\n  }, [])\n\n  const handleMouseMove = useCallback(\n    (e: MouseEvent) => {\n      if (disabled) return\n      setMouse({ x: e.clientX, y: e.clientY })\n    },\n    [disabled]\n  )\n\n  const drawArrow = useCallback(() => {\n    const canvas = canvasRef.current\n    const target = targetRef.current\n    const ctx = canvas?.getContext(\"2d\")\n\n    if (!canvas || !target || !ctx || !mouse.x || !mouse.y) return\n\n    const x0 = mouse.x\n    const y0 = mouse.y\n\n    // Get target center and dimensions\n    const rect = target.getBoundingClientRect()\n    const cx = rect.left + rect.width / 2\n    const cy = rect.top + rect.height / 2\n\n    // Calculate angle and end point (stopping at button edge)\n    const angle = Math.atan2(cy - y0, cx - x0)\n    const x1 = cx - Math.cos(angle) * (rect.width / 2 + 12)\n    const y1 = cy - Math.sin(angle) * (rect.height / 2 + 12)\n\n    // Calculate curve control point\n    const midX = (x0 + x1) / 2\n    const midY = (y0 + y1) / 2\n    const distance = Math.hypot(x1 - x0, y1 - y0)\n    const offset = Math.min(200, distance * curveIntensity)\n    const t = Math.max(-1, Math.min(1, (y0 - y1) / 200))\n    const controlX = midX\n    const controlY = midY + offset * t\n\n    // Calculate opacity based on distance\n    const minDistance = Math.max(rect.width, rect.height) / 2\n    const opacity = Math.min(\n      maxOpacity,\n      Math.max(0, (distance - minDistance) / fadeDistance)\n    )\n\n    if (opacity <= 0) return\n\n    // Parse stroke color and apply opacity\n    let colorWithOpacity: string\n\n    if (strokeColor === \"hsl(var(--foreground) / 0.75)\") {\n      // Use the computed foreground color for theme support\n      colorWithOpacity = getForegroundColor(opacity)\n    } else if (strokeColor.includes(\"rgba\")) {\n      colorWithOpacity = strokeColor.replace(/[\\d.]+\\)$/g, `${opacity})`)\n    } else if (strokeColor.includes(\"rgb\")) {\n      colorWithOpacity = strokeColor\n        .replace(\"rgb\", \"rgba\")\n        .replace(\")\", `, ${opacity})`)\n    } else {\n      // Fallback for other color formats\n      colorWithOpacity = `rgba(255, 255, 255, ${opacity})`\n    }\n\n    ctx.strokeStyle = colorWithOpacity\n    ctx.lineWidth = strokeWidth\n\n    // Draw curved dashed line\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(x0, y0)\n    ctx.quadraticCurveTo(controlX, controlY, x1, y1)\n    ctx.setLineDash(dashArray)\n    ctx.stroke()\n    ctx.restore()\n\n    // Draw arrowhead\n    const arrowAngle = Math.atan2(y1 - controlY, x1 - controlX)\n    ctx.beginPath()\n    ctx.moveTo(x1, y1)\n    ctx.lineTo(\n      x1 - arrowSize * Math.cos(arrowAngle - Math.PI / 6),\n      y1 - arrowSize * Math.sin(arrowAngle - Math.PI / 6)\n    )\n    ctx.moveTo(x1, y1)\n    ctx.lineTo(\n      x1 - arrowSize * Math.cos(arrowAngle + Math.PI / 6),\n      y1 - arrowSize * Math.sin(arrowAngle + Math.PI / 6)\n    )\n    ctx.stroke()\n  }, [\n    mouse,\n    strokeColor,\n    strokeWidth,\n    dashArray,\n    maxOpacity,\n    curveIntensity,\n    arrowSize,\n    fadeDistance,\n    getForegroundColor,\n  ])\n\n  const animate = useCallback(() => {\n    const canvas = canvasRef.current\n    const ctx = canvas?.getContext(\"2d\")\n\n    if (!canvas || !ctx) return\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n    if (!disabled) {\n      drawArrow()\n    }\n\n    animationRef.current = requestAnimationFrame(animate)\n  }, [drawArrow, disabled])\n\n  useEffect(() => {\n    updateCanvasSize()\n    window.addEventListener(\"resize\", updateCanvasSize)\n    window.addEventListener(\"mousemove\", handleMouseMove)\n\n    return () => {\n      window.removeEventListener(\"resize\", updateCanvasSize)\n      window.removeEventListener(\"mousemove\", handleMouseMove)\n    }\n  }, [updateCanvasSize, handleMouseMove])\n\n  useEffect(() => {\n    animate()\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current)\n      }\n    }\n  }, [animate])\n\n  return (\n    <div className={cn(\"relative\", className)}>\n      <div ref={targetRef}>{children}</div>\n      <canvas\n        ref={canvasRef}\n        className=\"fixed inset-0 pointer-events-none z-50\"\n        style={{ width: \"100vw\", height: \"100vh\" }}\n      />\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "/components/delta/landing-page/mouse-string-connection.tsx"
    }
  ]
}
