{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "snap-scroll",
  "type": "registry:component",
  "title": "Snap Scroll",
  "description": "A component for snap scrolling content",
  "dependencies": [],
  "registryDependencies": ["utils"],
  "files": [
    {
      "path": "delta/components/snap-scroll.tsx",
      "content": "\"use client\"\n\nimport type React from \"react\"\nimport { useEffect, useCallback, useRef, useState, useMemo } from \"react\"\nimport { usePathname } from \"next/navigation\"\nimport { debounce } from \"lodash\"\nimport { Loader2 } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\n\n/**\n * Item interface for snap scroll items\n */\nexport interface SnapScrollItem {\n  id: string\n  [key: string]: any\n}\n\n/**\n * Props for the SnapScroll component\n */\nexport interface SnapScrollProps {\n  /** Child elements to be rendered as snap items */\n  children: React.ReactNode\n\n  /** Array of items to be scrolled through */\n  items: SnapScrollItem[]\n\n  /** Whether to update the URL when scrolling to a new item */\n  enableDynamicRouting?: boolean\n\n  /** Prefix for the dynamic route (e.g., /posts/[id]) */\n  routePrefix?: string\n\n  /** Callback to fetch more items when reaching the threshold */\n  onFetchMore: () => Promise<void>\n\n  /** Number of items before the end to trigger fetching more */\n  fetchThreshold?: number\n\n  /** Custom class name for the container */\n  className?: string\n\n  /** Custom class name for each snap item */\n  itemClassName?: string\n\n  /** Custom loading component */\n  loadingComponent?: React.ReactNode\n\n  /** Whether to show scroll progress indicator */\n  showProgress?: boolean\n\n  /** Callback fired when the active item changes */\n  onItemChange?: (index: number, item: SnapScrollItem) => void\n\n  /** Scroll behavior */\n  scrollBehavior?: ScrollBehavior\n\n  /** Debounce time for scroll events in ms */\n  scrollDebounce?: number\n\n  /** CSS position property for the container */\n  position?: \"fixed\" | \"absolute\" | \"static\"\n}\n\n/**\n * Props for the SnapScrollItem component\n */\nexport interface SnapScrollItemProps {\n  /** Child elements to be rendered inside the snap item */\n  children: React.ReactNode\n\n  /** Custom class name for the item */\n  className?: string\n}\n\n/**\n * A component that creates a vertical snap-scrolling experience with dynamic loading\n * and optional URL updates.\n */\nexport const SnapScroll: React.FC<SnapScrollProps> = ({\n  children,\n  items,\n  enableDynamicRouting = false,\n  routePrefix = \"items\",\n  onFetchMore,\n  fetchThreshold = 3,\n  className = \"\",\n  itemClassName = \"\",\n  loadingComponent,\n  showProgress = false,\n  onItemChange,\n  scrollBehavior = \"smooth\",\n  scrollDebounce = 100,\n  position = \"fixed\",\n}) => {\n  const pathname = usePathname()\n  const containerRef = useRef<HTMLDivElement>(null)\n  const [currentIndex, setCurrentIndex] = useState(0)\n  const [isLoading, setIsLoading] = useState(false)\n  const [isFetching, setIsFetching] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  // Memoize the URL update function to prevent unnecessary re-renders\n  const updateURL = useCallback(\n    (index: number) => {\n      if (enableDynamicRouting && index >= 0 && index < items.length) {\n        const newPath = `/${routePrefix}/${items[index].id}`\n        window.history.replaceState({ path: newPath }, \"\", newPath)\n      }\n    },\n    [enableDynamicRouting, items, routePrefix],\n  )\n\n  // Handle scroll events\n  const handleScroll = useCallback(() => {\n    const snapContainer = containerRef.current\n    if (!snapContainer || isLoading) return\n\n    const scrollPosition = snapContainer.scrollTop\n    const containerHeight = snapContainer.clientHeight\n    const index = Math.round(scrollPosition / containerHeight)\n\n    // Update current index and URL if needed\n    if (index !== currentIndex && index >= 0 && index < items.length) {\n      setCurrentIndex(index)\n      updateURL(index)\n\n      // Call the onItemChange callback if provided\n      if (onItemChange) {\n        onItemChange(index, items[index])\n      }\n    }\n\n    // Check if we need to fetch more items\n    const shouldFetchMore =\n      !isFetching &&\n      !isLoading &&\n      items.length > 0 &&\n      // Either we're at the last item\n      (index >= items.length - 1 ||\n        // Or we're approaching the threshold\n        (items.length - index <= fetchThreshold && index < items.length - 1))\n\n    if (shouldFetchMore) {\n      setIsFetching(true)\n      onFetchMore()\n        .then(() => {\n          setIsFetching(false)\n        })\n        .catch((err) => {\n          setError(err instanceof Error ? err.message : \"Failed to fetch more items\")\n          setIsFetching(false)\n        })\n    }\n  }, [currentIndex, updateURL, items, onFetchMore, fetchThreshold, isLoading, isFetching, onItemChange])\n\n  // Set up scroll event listener with debounce\n  useEffect(() => {\n    const container = containerRef.current\n    const debouncedHandleScroll = debounce(handleScroll, scrollDebounce)\n\n    if (container) {\n      container.addEventListener(\"scroll\", debouncedHandleScroll)\n    }\n\n    return () => {\n      if (container) {\n        container.removeEventListener(\"scroll\", debouncedHandleScroll)\n      }\n      debouncedHandleScroll.cancel()\n    }\n  }, [handleScroll, scrollDebounce])\n\n  // Handle URL-based navigation\n  useEffect(() => {\n    if (enableDynamicRouting && pathname && items.length > 0) {\n      const itemId = pathname.split(\"/\").pop()\n      const index = items.findIndex((item) => item.id === itemId)\n      const snapContainer = containerRef.current\n\n      if (snapContainer && index !== -1 && index !== currentIndex) {\n        snapContainer.scrollTo({\n          top: index * snapContainer.clientHeight,\n          behavior: scrollBehavior,\n        })\n        setCurrentIndex(index)\n      }\n    }\n  }, [pathname, items, currentIndex, enableDynamicRouting, scrollBehavior])\n\n  // Keyboard navigation\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (!containerRef.current) return\n\n      if (e.key === \"ArrowDown\" || e.key === \"PageDown\") {\n        e.preventDefault()\n        const nextIndex = Math.min(currentIndex + 1, items.length - 1)\n        if (nextIndex !== currentIndex) {\n          containerRef.current.scrollTo({\n            top: nextIndex * containerRef.current.clientHeight,\n            behavior: scrollBehavior,\n          })\n        }\n      } else if (e.key === \"ArrowUp\" || e.key === \"PageUp\") {\n        e.preventDefault()\n        const prevIndex = Math.max(currentIndex - 1, 0)\n        if (prevIndex !== currentIndex) {\n          containerRef.current.scrollTo({\n            top: prevIndex * containerRef.current.clientHeight,\n            behavior: scrollBehavior,\n          })\n        }\n      }\n    }\n\n    window.addEventListener(\"keydown\", handleKeyDown)\n    return () => window.removeEventListener(\"keydown\", handleKeyDown)\n  }, [currentIndex, items.length, scrollBehavior])\n\n  // Progress indicators\n  const progressIndicators = useMemo(() => {\n    if (!showProgress || items.length === 0) return null\n\n    return (\n      <div className={`${position} right-4 top-1/2 -translate-y-1/2 flex flex-col gap-2 z-50`}>\n        {items.map((_, idx) => (\n          <button\n            key={idx}\n            className={cn(\n              \"w-2 h-2 rounded-full transition-all duration-300\",\n              idx === currentIndex ? \"bg-primary w-3 h-3\" : \"bg-gray-300 hover:bg-gray-400\",\n            )}\n            onClick={() => {\n              if (containerRef.current) {\n                containerRef.current.scrollTo({\n                  top: idx * containerRef.current.clientHeight,\n                  behavior: scrollBehavior,\n                })\n              }\n            }}\n            aria-label={`Go to item ${idx + 1}`}\n          />\n        ))}\n      </div>\n    )\n  }, [items, currentIndex, showProgress, scrollBehavior, position])\n\n  // Default loading component\n  const defaultLoadingComponent = (\n    <div className=\"flex items-center justify-center h-24 w-full\">\n      <Loader2 className=\"h-8 w-8 animate-spin text-primary\" />\n    </div>\n  )\n\n  return (\n    <>\n      <div\n        ref={containerRef}\n        className={cn(\n          \"flex flex-col h-screen overflow-y-scroll scroll-smooth snap-y snap-mandatory scrollbar-hide\",\n          className,\n        )}\n        tabIndex={0}\n        role=\"region\"\n        aria-label=\"Scrollable content\"\n      >\n        {children}\n        {isFetching && (loadingComponent || defaultLoadingComponent)}\n        {error && (\n          <div className=\"p-4 bg-red-50 text-red-500 text-center\">\n            {error}\n            <button\n              className=\"ml-2 underline\"\n              onClick={() => {\n                setError(null)\n                setIsFetching(true)\n                onFetchMore()\n                  .then(() => setIsFetching(false))\n                  .catch(() => setIsFetching(false))\n              }}\n            >\n              Retry\n            </button>\n          </div>\n        )}\n      </div>\n      {progressIndicators}\n    </>\n  )\n}\n\n/**\n * Individual item component for the SnapScroll container\n */\nexport const SnapScrollItem: React.FC<SnapScrollItemProps> = ({ children, className = \"\" }) => {\n  return (\n    <div\n      className={cn(\n        \"snap-start flex h-screen flex-shrink-0 items-start justify-center transition-transform duration-300 transform will-change-transform translate-z-0\",\n        className,\n      )}\n    >\n      {children}\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "delta/components/snap-scroll.tsx"
    },
    {
      "path": "delta/examples/snap-scroll-basic-demo.tsx",
      "content": "\"use client\"\n\nimport { useState, useCallback } from \"react\"\nimport { SnapScroll, SnapScrollItem, type SnapScrollItem as Item } from \"@/delta/components/snap-scroll\"\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from \"@/components/ui/card\"\nimport { Button } from \"@/components/ui/button\"\nimport { ChevronDown, ChevronUp } from \"lucide-react\"\nimport { ClipLoader } from \"react-spinners\"\n\n/**\n * A basic demo of the SnapScroll component\n */\nexport default function SnapScrollDemo() {\n  // Sample data for the demo\n  const [items, setItems] = useState<Item[]>(\n    Array.from({ length: 5 }, (_, i) => ({\n      id: `item-${i + 1}`,\n      title: `Item ${i + 1}`,\n      description: `This is the description for item ${i + 1}`,\n      color: getRandomColor(),\n    })),\n  )\n\n  // Options state\n  const [enableRouting, setEnableRouting] = useState(false)\n  const [showProgress, setShowProgress] = useState(false)\n  const [isFetching, setIsFetching] = useState(false)\n\n  // Function to fetch more items\n  const fetchMoreItems = useCallback(async () => {\n    // Set loading state\n    setIsFetching(true)\n\n    // Simulate network delay\n    await new Promise((resolve) => setTimeout(resolve, 1500))\n\n    // Add 3 more items\n    const currentLength = items.length\n    const newItems = Array.from({ length: 3 }, (_, i) => ({\n      id: `item-${currentLength + i + 1}`,\n      title: `Item ${currentLength + i + 1}`,\n      description: `This is the description for item ${currentLength + i + 1}`,\n      color: getRandomColor(),\n    }))\n\n    setItems((prev) => [...prev, ...newItems])\n    setIsFetching(false)\n  }, [items])\n\n  // Handle item change\n  const handleItemChange = useCallback((index: number, item: Item) => {\n    console.log(`Active item changed to: ${item.title} (index: ${index})`)\n  }, [])\n\n  return (\n    <div className=\"relative\">\n      {/* Options panel */}\n      <div className=\"fixed top-4 left-4 z-50 bg-white/90 backdrop-blur-sm p-4 rounded-lg shadow-lg\">\n        <h3 className=\"font-medium mb-2\">Options</h3>\n        <div className=\"space-y-2\">\n          <label className=\"flex items-center gap-2\">\n            <input type=\"checkbox\" checked={enableRouting} onChange={() => setEnableRouting(!enableRouting)} />\n            Enable URL Routing\n          </label>\n        </div>\n        <div className=\"mt-4\">\n          <p className=\"text-xs text-muted-foreground\">Items: {items.length} | Use keyboard ↑/↓ to navigate</p>\n        </div>\n      </div>\n\n      {/* Snap Scroll Component */}\n      <SnapScroll\n        items={items}\n        onFetchMore={fetchMoreItems}\n        enableDynamicRouting={enableRouting}\n        routePrefix=\"demo\"\n        position=\"absolute\"\n        fetchThreshold={2}\n        showProgress={showProgress}\n        onItemChange={handleItemChange}\n      >\n        {items.map((item, index) => (\n          <SnapScrollItem key={item.id}>\n            <Card\n              className=\"w-[90%] max-w-3xl m-4 shadow-lg transition-all duration-300 hover:shadow-xl\"\n              style={{ backgroundColor: item.color }}\n            >\n              <CardHeader>\n                <CardTitle>{item.title}</CardTitle>\n                <CardDescription className=\"text-black/70\">Scroll to navigate between items</CardDescription>\n              </CardHeader>\n              <CardContent>\n                <p className=\"text-black/80\">{item.description}</p>\n                <div className=\"h-40 flex items-center justify-center mt-4 bg-white/20 rounded-lg\">\n                  <p className=\"text-4xl font-bold\">{index + 1}</p>\n                </div>\n              </CardContent>\n              <CardFooter className=\"flex justify-between\">\n                <Button\n                  variant=\"outline\"\n                  size=\"icon\"\n                  onClick={() => {\n                    const container = document.querySelector(\".snap-y\")\n                    if (container) {\n                      container.scrollBy({\n                        top: -window.innerHeight,\n                        behavior: \"smooth\",\n                      })\n                    }\n                  }}\n                >\n                  <ChevronUp className=\"h-4 w-4\" />\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"icon\"\n                  onClick={() => {\n                    const container = document.querySelector(\".snap-y\")\n                    if (container) {\n                      container.scrollBy({\n                        top: window.innerHeight,\n                        behavior: \"smooth\",\n                      })\n                    }\n                  }}\n                >\n                  <ChevronDown className=\"h-4 w-4\" />\n                </Button>\n              </CardFooter>\n            </Card>\n          </SnapScrollItem>\n        ))}\n      </SnapScroll>\n\n      {/* Centered ClipLoader spinner */}\n      {isFetching && (\n        <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/20 backdrop-blur-sm\">\n          <div className=\"bg-white p-6 rounded-lg shadow-xl\">\n            <ClipLoader size={35} color=\"#3b82f6\" speedMultiplier={0.8} />\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n\n// Helper function to generate random pastel colors\nfunction getRandomColor() {\n  const hue = Math.floor(Math.random() * 360)\n  return `hsl(${hue}, 70%, 85%)`\n}\n",
      "type": "registry:component",
      "target": "delta/examples/snap-scroll-basic-demo.tsx"
    },
    {
      "path": "content/docs/snap-scroll.mdx",
      "content": "# SnapScroll\n\nA snap-scroll component.\n\n## Basic Usage\n\n<ComponentTabs name=\"snap-scroll-basic\" />\n\n<InstallationInstructions componentName=\"snap-scroll\" />\n\n## Props\n\n<Table>\n  <TableHeader>\n    <TableRow>\n      <TableHead>Prop</TableHead>\n      <TableHead>Type</TableHead>\n      <TableHead>Default</TableHead>\n      <TableHead>Description</TableHead>\n    </TableRow>\n  </TableHeader>\n  <TableBody>\n\n  </TableBody>\n</Table>\n",
      "type": "registry:component",
      "target": "content/docs/snap-scroll.mdx"
    }
  ]
}
