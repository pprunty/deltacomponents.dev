{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "animate-in",
  "type": "registry:component",
  "author": "patrick prunty <https://www.patrickprunty.com>",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "registry/animations/animate-in.tsx",
      "content": "\"use client\"\n\nimport React, { useEffect, useRef, useState } from \"react\"\nimport { motion } from \"motion/react\"\n\ninterface AnimateInProps {\n  children: React.ReactNode\n  direction?: \"up\" | \"left\" | \"right\" | \"fade\"\n  delay?: number\n  className?: string\n  useIntersectionObserver?: boolean\n  threshold?: number\n  triggerOnce?: boolean\n  duration?: number\n  enableBlur?: boolean\n  blurAmount?: number\n}\n\nconst AnimateIn: React.FC<AnimateInProps> = ({\n  children,\n  direction = \"up\",\n  delay = 0,\n  className = \"\",\n  useIntersectionObserver = false,\n  threshold = 0.1,\n  triggerOnce = true,\n  duration = 0.6,\n  enableBlur = false,\n  blurAmount = 8,\n}) => {\n  const [isVisible, setIsVisible] = useState(false)\n  const elementRef = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    if (useIntersectionObserver) {\n      const observer = new IntersectionObserver(\n        ([entry]) => {\n          if (entry.isIntersecting) {\n            setIsVisible(true)\n            if (triggerOnce) {\n              observer.unobserve(entry.target)\n            }\n          } else if (!triggerOnce) {\n            setIsVisible(false)\n          }\n        },\n        { threshold }\n      )\n\n      if (elementRef.current) {\n        observer.observe(elementRef.current)\n      }\n\n      return () => {\n        const currentElement = elementRef.current\n        if (currentElement) {\n          observer.unobserve(currentElement)\n        }\n      }\n    } else {\n      // Original delay-based behavior\n      const timer = setTimeout(() => {\n        setIsVisible(true)\n      }, delay)\n\n      return () => clearTimeout(timer)\n    }\n  }, [delay, useIntersectionObserver, threshold, triggerOnce])\n\n  const getInitialState = () => {\n    const baseState = (() => {\n      switch (direction) {\n        case \"left\":\n          return { opacity: 0, x: -30 }\n        case \"right\":\n          return { opacity: 0, x: 30 }\n        case \"fade\":\n          return { opacity: 0 }\n        case \"up\":\n        default:\n          return { opacity: 0, y: 20 }\n      }\n    })()\n\n    return enableBlur\n      ? { ...baseState, filter: `blur(${blurAmount}px)` }\n      : baseState\n  }\n\n  const getAnimateState = () => {\n    const baseState = (() => {\n      switch (direction) {\n        case \"left\":\n          return { opacity: 1, x: 0 }\n        case \"right\":\n          return { opacity: 1, x: 0 }\n        case \"fade\":\n          return { opacity: 1 }\n        case \"up\":\n        default:\n          return { opacity: 1, y: 0 }\n      }\n    })()\n\n    return enableBlur ? { ...baseState, filter: \"blur(0px)\" } : baseState\n  }\n\n  return (\n    <motion.div\n      ref={elementRef}\n      className={className}\n      initial={getInitialState()}\n      animate={isVisible ? getAnimateState() : getInitialState()}\n      transition={{\n        duration,\n        delay: useIntersectionObserver ? 0 : delay / 1000,\n        ease: \"easeOut\",\n      }}\n    >\n      {children}\n    </motion.div>\n  )\n}\n\nexport default AnimateIn\n",
      "type": "registry:component",
      "target": "/delta/animate-in.tsx"
    }
  ]
}