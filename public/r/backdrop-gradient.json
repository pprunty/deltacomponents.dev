{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "backdrop-gradient",
  "type": "registry:component",
  "files": [
    {
      "path": "registry/components/backdrop-gradient.tsx",
      "content": "\"use client\"\n\nimport type React from \"react\"\nimport { useEffect, useState, useRef } from \"react\"\nimport Image from \"next/image\"\nimport { cn } from \"@/lib/utils\"\n\n// Define the props interface\ninterface BackdropGradientProps {\n  src: string\n  alt: string\n  width?: number\n  height?: number\n  className?: string\n  imageClassName?: string\n  gradientIntensity?: number\n  blurAmount?: number\n  children?: React.ReactNode\n}\n\nexport function BackdropGradient(props: BackdropGradientProps) {\n  // Use individual variables instead of destructuring\n  const src = props.src || \"https://placehold.co/300x300\"\n  const alt = props.alt || \"Image\"\n  const width = props.width || 300\n  const height = props.height || 300\n  const className = props.className || \"\"\n  const imageClassName = props.imageClassName || \"\"\n  const gradientIntensity = typeof props.gradientIntensity === \"number\" ? props.gradientIntensity : 0.7\n  const blurAmount = typeof props.blurAmount === \"number\" ? props.blurAmount : 70\n  const children = props.children\n\n  // State\n  const [dominantColors, setDominantColors] = useState([\"#cccccc\", \"#999999\", \"#666666\"])\n  const [imageLoaded, setImageLoaded] = useState(false)\n  const canvasRef = useRef<HTMLCanvasElement | null>(null)\n\n  // Extract colors from image\n  function processImage(imgElement) {\n    try {\n      const canvas = canvasRef.current\n      if (!canvas) return\n\n      const ctx = canvas.getContext(\"2d\")\n      if (!ctx) return\n\n      // Set canvas dimensions\n      canvas.width = imgElement.width\n      canvas.height = imgElement.height\n\n      // Draw image to canvas\n      ctx.drawImage(imgElement, 0, 0, imgElement.width, imgElement.height)\n\n      // Get image data\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)\n      const data = imageData.data\n\n      // Sample colors\n      const colorMap = {}\n      const sampleSize = 10\n\n      for (let i = 0; i < data.length; i += 4 * sampleSize) {\n        // Ensure we don't go out of bounds\n        if (i + 3 >= data.length) continue\n\n        const r = data[i] || 0\n        const g = data[i + 1] || 0\n        const b = data[i + 2] || 0\n        const a = data[i + 3] || 0\n\n        // Skip transparent or extreme colors\n        if (a < 128) continue\n        if (r + g + b < 100 || r + g + b > 650) continue\n\n        // Create hex color\n        const hex = rgbToHex(r, g, b)\n        colorMap[hex] = (colorMap[hex] || 0) + 1\n      }\n\n      // Convert to array and sort\n      const colorArray = []\n      for (const color in colorMap) {\n        colorArray.push([color, colorMap[color]])\n      }\n\n      // Sort by frequency\n      colorArray.sort((a, b) => b[1] - a[1])\n\n      // Get top 3 colors\n      const topColors = []\n      for (let i = 0; i < Math.min(3, colorArray.length); i++) {\n        topColors.push(colorArray[i][0])\n      }\n\n      // Set colors if we found any\n      if (topColors.length > 0) {\n        setDominantColors(topColors)\n      }\n    } catch (error) {\n      console.error(\"Error processing image:\", error)\n    }\n  }\n\n  // Convert RGB to hex\n  function rgbToHex(r, g, b) {\n    return \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)\n  }\n\n  // Load image and extract colors\n  useEffect(() => {\n    if (!src) return\n\n    // Reset state\n    setImageLoaded(false)\n\n    const imgElement = new Image()\n    imgElement.crossOrigin = \"anonymous\"\n\n    // Handle image load\n    imgElement.onload = () => {\n      processImage(imgElement)\n      setImageLoaded(true)\n    }\n\n    // Handle image error\n    imgElement.onerror = () => {\n      console.error(\"Error loading image\")\n      setImageLoaded(true)\n    }\n\n    // Set source to start loading\n    imgElement.src = src\n\n    // Cleanup\n    return () => {\n      imgElement.onload = null\n      imgElement.onerror = null\n    }\n  }, [src])\n\n  // Handle image load in the component\n  function handleImageLoad() {\n    setImageLoaded(true)\n  }\n\n  // Create gradient style\n  const gradientStyle = {\n    backgroundImage: \"radial-gradient(circle at center, \" + dominantColors.join(\", \") + \")\",\n    filter: \"blur(\" + blurAmount + \"px)\",\n    opacity: gradientIntensity,\n  }\n\n  // Render component\n  return (\n    <div className={cn(\"relative overflow-hidden rounded-lg\", className)}>\n      {/* Hidden canvas for color extraction */}\n      <canvas ref={canvasRef} className=\"hidden\" />\n\n      {/* Gradient background */}\n      {imageLoaded && (\n        <div\n          className=\"absolute inset-0 w-[200%] h-[200%] -translate-x-1/4 -translate-y-1/4 z-0\"\n          style={gradientStyle}\n        />\n      )}\n\n      {/* Image */}\n      <div className=\"relative z-10 flex items-center justify-center\">\n        <Image\n          src={src || \"/placeholder.svg\"}\n          alt={alt}\n          width={width}\n          height={height}\n          className={cn(\"object-cover\", imageClassName)}\n          onLoad={handleImageLoad}\n        />\n      </div>\n\n      {/* Optional content */}\n      {children && <div className=\"relative z-20\">{children}</div>}\n    </div>\n  )\n}\n",
      "type": "registry:component"
    }
  ]
}