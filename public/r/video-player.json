{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "video-player",
  "type": "registry:component",
  "title": "Video Player",
  "description": "A component for video-player",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "delta/components/video-player.tsx",
      "content": "'use client';\n\nimport { useEffect, useRef, useState } from 'react';\n\nimport { cn } from '@/lib/utils';\n\ninterface VideoPlayerProps {\n  src: string;\n  title?: string;\n  className?: string;\n  storageKey?: string;\n  autoPlayOnReturn?: boolean;\n  useDynamicPoster?: boolean;\n}\n\nexport function VideoPlayer({\n  src,\n  title,\n  className,\n  storageKey = 'video-player-state',\n  autoPlayOnReturn = true,\n  useDynamicPoster = true,\n}: VideoPlayerProps) {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [volume, setVolume] = useState(1);\n  const [isMuted, setIsMuted] = useState(false);\n  const [titleOpacity, setTitleOpacity] = useState(1);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isMobile, setIsMobile] = useState(false);\n  const [posterImage, setPosterImage] = useState<string | null>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [displayTitle, setDisplayTitle] = useState<string | undefined>(title);\n\n  // Extract filename from path if no title is provided\n  useEffect(() => {\n    if (!title && src) {\n      // Extract the last part of the path (filename)\n      const parts = src.split('/');\n      const filename = parts[parts.length - 1];\n      // Remove any query parameters if present\n      const cleanFilename = filename.split('?')[0];\n      setDisplayTitle(cleanFilename);\n    } else {\n      setDisplayTitle(title);\n    }\n  }, [title, src]);\n\n  // Check if mobile on mount and window resize\n  useEffect(() => {\n    const checkMobile = () => {\n      setIsMobile(window.innerWidth < 768);\n    };\n\n    checkMobile(); // Initial check\n    window.addEventListener('resize', checkMobile);\n\n    return () => window.removeEventListener('resize', checkMobile);\n  }, []);\n\n  // Handle title opacity based on playback time\n  useEffect(() => {\n    if (currentTime > 3) {\n      setTitleOpacity(0);\n    } else {\n      setTitleOpacity(1);\n    }\n  }, [currentTime]);\n\n  // Load saved state on mount\n  useEffect(() => {\n    const savedState = localStorage.getItem(storageKey);\n    if (savedState) {\n      try {\n        const { time, volume, muted, paused, savedDuration } =\n          JSON.parse(savedState);\n\n        // If we have a saved duration, use it until the real one loads\n        if (savedDuration && savedDuration > 0) {\n          setDuration(savedDuration);\n        }\n\n        const loadVideo = () => {\n          if (videoRef.current) {\n            videoRef.current.currentTime = time || 0;\n            videoRef.current.volume = volume || 1;\n            videoRef.current.muted = muted || false;\n            setCurrentTime(time || 0);\n            setVolume(volume || 1);\n            setIsMuted(muted || false);\n\n            // If autoPlayOnReturn is true or it wasn't paused before, play it automatically\n            if ((autoPlayOnReturn || !paused) && videoRef.current.paused) {\n              videoRef.current.play().catch(() => {\n                // Auto-play might be blocked by browser\n                setIsPlaying(false);\n              });\n            }\n          }\n        };\n\n        if (videoRef.current) {\n          // If video is already loaded enough to seek\n          if (videoRef.current.readyState >= 2) {\n            loadVideo();\n            setIsLoading(false);\n          } else {\n            // Wait for video to be loaded enough to seek\n            const handleCanSeek = () => {\n              loadVideo();\n              setIsLoading(false);\n              videoRef.current?.removeEventListener(\n                'loadedmetadata',\n                handleCanSeek,\n              );\n            };\n            videoRef.current.addEventListener('loadedmetadata', handleCanSeek);\n          }\n        }\n      } catch (error) {\n        console.error('Error parsing saved video state:', error);\n        localStorage.removeItem(storageKey);\n      }\n    }\n  }, [storageKey, autoPlayOnReturn]);\n\n  // Handle autoPlayOnReturn when page becomes visible\n  useEffect(() => {\n    // Handle visibility change (e.g. tab switching)\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'visible') {\n        // Update poster if needed\n        const savedPoster = localStorage.getItem(`${storageKey}-poster`);\n        if (savedPoster && !posterImage) {\n          setPosterImage(savedPoster);\n        }\n\n        // Try to play when returning to the page if autoPlayOnReturn is true\n        if (autoPlayOnReturn && videoRef.current) {\n          videoRef.current.play().catch((error) => {\n            console.error('Error auto-playing video on return:', error);\n          });\n        }\n      } else if (document.visibilityState === 'hidden') {\n        // Capture a frame when user leaves the page\n        const frameSrc = captureVideoFrame();\n        if (frameSrc) {\n          setPosterImage(frameSrc);\n          try {\n            localStorage.setItem(`${storageKey}-poster`, frameSrc);\n          } catch (e) {\n            console.error('Failed to save poster on visibility change:', e);\n          }\n        }\n      }\n    };\n\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    return () => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [autoPlayOnReturn, storageKey, posterImage]);\n\n  // Save state on changes with debounce for better performance\n  useEffect(() => {\n    let saveTimeout: NodeJS.Timeout | null = null;\n\n    const saveState = () => {\n      if (saveTimeout) {\n        clearTimeout(saveTimeout);\n      }\n\n      saveTimeout = setTimeout(() => {\n        const state = {\n          time: currentTime,\n          volume,\n          muted: isMuted,\n          paused: !isPlaying,\n          savedDuration: duration,\n        };\n        localStorage.setItem(storageKey, JSON.stringify(state));\n      }, 500); // Debounce for 500ms\n    };\n\n    // Save state during playback with reduced frequency\n    const interval = setInterval(() => {\n      if (isPlaying) {\n        saveState();\n\n        // Also capture a frame periodically during playback\n        // But less frequently than state saves to reduce performance impact\n        if (currentTime % 15 < 5) {\n          // Approximately every 15 seconds\n          const frameSrc = captureVideoFrame();\n          if (frameSrc) {\n            setPosterImage(frameSrc);\n            try {\n              localStorage.setItem(`${storageKey}-poster`, frameSrc);\n            } catch (e) {\n              // Handle storage quota exceeded\n              console.warn('Failed to save poster during playback:', e);\n            }\n          }\n        }\n      }\n    }, 5000); // Save every 5 seconds during playback for better performance\n\n    // Save state on pause/play/volume changes\n    saveState();\n\n    return () => {\n      if (saveTimeout) clearTimeout(saveTimeout);\n      clearInterval(interval);\n    };\n  }, [currentTime, volume, isMuted, isPlaying, duration, storageKey]);\n\n  // Capture and save the current frame as poster image\n  const captureVideoFrame = () => {\n    if (!videoRef.current || !canvasRef.current || !useDynamicPoster)\n      return null;\n\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n\n    // Only capture if video has actual frames available\n    if (\n      !context ||\n      video.readyState < 2 ||\n      !video.videoWidth ||\n      !video.videoHeight\n    )\n      return null;\n\n    // Set canvas dimensions to match video\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n\n    // Draw the current frame to canvas\n    try {\n      // Fix for SecurityError by checking video source\n      // This occurs when video is loaded from a different origin without CORS headers\n      if (video.crossOrigin !== 'anonymous') {\n        // Skip frame capture for cross-origin videos without proper CORS\n        if (\n          video.src.startsWith('http') &&\n          !video.src.startsWith(window.location.origin)\n        ) {\n          return null;\n        }\n      }\n\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n      // Convert to data URL (with quality parameter for JPG)\n      try {\n        const dataUrl = canvas.toDataURL('image/jpeg', 0.85);\n        return dataUrl;\n      } catch (e) {\n        // If we got a security error, it's likely due to CORS issues\n        console.error('Failed to export canvas to data URL:', e);\n        return null;\n      }\n    } catch (e) {\n      console.error('Failed to capture video frame:', e);\n      return null;\n    }\n  };\n\n  // Save poster image periodically when playing\n  useEffect(() => {\n    if (!isPlaying) return;\n\n    // Save frame every 10 seconds while playing\n    const interval = setInterval(() => {\n      const frameSrc = captureVideoFrame();\n      if (frameSrc) {\n        setPosterImage(frameSrc);\n        try {\n          localStorage.setItem(`${storageKey}-poster`, frameSrc);\n        } catch (e) {\n          // If localStorage quota is exceeded, remove the item and try again with a lower quality\n          localStorage.removeItem(`${storageKey}-poster`);\n          const canvas = canvasRef.current;\n          if (canvas) {\n            try {\n              const lowQualityDataUrl = canvas.toDataURL('image/jpeg', 0.5);\n              localStorage.setItem(`${storageKey}-poster`, lowQualityDataUrl);\n            } catch (e) {\n              console.error(\n                'Failed to save poster even with lower quality:',\n                e,\n              );\n            }\n          }\n        }\n      }\n    }, 10000);\n\n    return () => clearInterval(interval);\n  }, [isPlaying, storageKey]);\n\n  // Load poster image on mount\n  useEffect(() => {\n    const savedPoster = localStorage.getItem(`${storageKey}-poster`);\n    if (savedPoster) {\n      setPosterImage(savedPoster);\n    }\n  }, [storageKey]);\n\n  // Save state before unload\n  useEffect(() => {\n    const handleBeforeUnload = () => {\n      // Capture current frame before unloading\n      const frameSrc = captureVideoFrame();\n\n      const state = {\n        time: videoRef.current?.currentTime || 0,\n        volume: videoRef.current?.volume || 1,\n        muted: videoRef.current?.muted || false,\n        paused: videoRef.current?.paused || true,\n        savedDuration: videoRef.current?.duration || duration,\n      };\n\n      localStorage.setItem(storageKey, JSON.stringify(state));\n\n      // Save the poster frame if available\n      if (frameSrc) {\n        try {\n          localStorage.setItem(`${storageKey}-poster`, frameSrc);\n        } catch (e) {\n          console.error('Failed to save poster on unload:', e);\n        }\n      }\n    };\n\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    return () => window.removeEventListener('beforeunload', handleBeforeUnload);\n  }, [storageKey, duration]);\n\n  // Handle mobile view optimization\n  useEffect(() => {\n    const handleResize = () => {\n      if (videoRef.current) {\n        if (window.innerWidth < 768) {\n          // Center the video for mobile view\n          videoRef.current.style.objectPosition = 'center';\n          videoRef.current.style.objectFit = 'cover';\n        } else {\n          // Reset for desktop\n          videoRef.current.style.objectPosition = '';\n          videoRef.current.style.objectFit = '';\n        }\n      }\n    };\n\n    handleResize(); // Call once on mount\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  // Handle video events\n  useEffect(() => {\n    const video = videoRef.current;\n    if (!video) return;\n\n    const handleTimeUpdate = () => {\n      setCurrentTime(video.currentTime);\n    };\n\n    const handleDurationChange = () => {\n      setDuration(video.duration);\n    };\n\n    const handlePlay = () => {\n      setIsPlaying(true);\n    };\n\n    const handlePause = () => {\n      setIsPlaying(false);\n    };\n\n    const handleVolumeChange = () => {\n      setVolume(video.volume);\n      setIsMuted(video.muted);\n    };\n\n    const handleLoadedData = () => {\n      setIsLoading(false);\n    };\n\n    const handleWaiting = () => {\n      setIsLoading(true);\n    };\n\n    const handleCanPlay = () => {\n      setIsLoading(false);\n    };\n\n    video.addEventListener('timeupdate', handleTimeUpdate);\n    video.addEventListener('durationchange', handleDurationChange);\n    video.addEventListener('play', handlePlay);\n    video.addEventListener('pause', handlePause);\n    video.addEventListener('volumechange', handleVolumeChange);\n    video.addEventListener('loadeddata', handleLoadedData);\n    video.addEventListener('waiting', handleWaiting);\n    video.addEventListener('canplay', handleCanPlay);\n\n    return () => {\n      video.removeEventListener('timeupdate', handleTimeUpdate);\n      video.removeEventListener('durationchange', handleDurationChange);\n      video.removeEventListener('play', handlePlay);\n      video.removeEventListener('pause', handlePause);\n      video.removeEventListener('volumechange', handleVolumeChange);\n      video.removeEventListener('loadeddata', handleLoadedData);\n      video.removeEventListener('waiting', handleWaiting);\n      video.removeEventListener('canplay', handleCanPlay);\n    };\n  }, []);\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn(\n        'relative w-full overflow-hidden bg-black aspect-video dark:bg-black',\n        className,\n      )}\n    >\n      {displayTitle && (\n        <div\n          style={{\n            opacity: titleOpacity,\n            transition: 'opacity 1.5s ease-in-out',\n          }}\n          className={cn(\n            'absolute z-10 p-4 text-lg text-white',\n            isMobile ? 'left-8 top-0' : 'left-0 top-0', // Position more to the right on mobile\n          )}\n        >\n          <div className=\"line-clamp-1\">{displayTitle}</div>\n        </div>\n      )}\n\n      {/* Hidden canvas for capturing frames */}\n      <canvas ref={canvasRef} className=\"hidden\" />\n\n      <video\n        ref={videoRef}\n        className=\"w-full h-full\"\n        src={src}\n        poster={posterImage || undefined}\n        controls // Added native controls here\n        playsInline\n        preload=\"metadata\"\n        crossOrigin=\"anonymous\" // Add crossOrigin to help with canvas security\n        onLoadedMetadata={() => {\n          if (videoRef.current) {\n            setDuration(videoRef.current.duration);\n          }\n        }}\n      />\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/components/video-player.tsx"
    },
    {
      "path": "delta/components/video-player-demo.tsx",
      "content": "import { VideoPlayer } from './video-player';\n\nexport default function VideoPlayerDemo() {\n  return (\n    <VideoPlayer\n      src=\"https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"\n      title=\"Big Buck Bunny - Sample Video\"\n      storageKey=\"demo-video-player-state\"\n    />\n  );\n}\n",
      "type": "registry:component",
      "target": "delta/components/video-player-demo.tsx"
    }
  ]
}
