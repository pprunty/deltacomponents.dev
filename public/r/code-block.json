{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "code-block",
  "type": "registry:component",
  "files": [
    {
      "path": "registry/components/code-block.tsx",
      "content": "'use client';\n\nimport type React from 'react';\nimport { useEffect, useState, useRef } from 'react';\nimport { getHighlighter } from 'shikiji';\nimport type { Highlighter, BundledTheme } from 'shikiji';\nimport { useTheme } from 'next-themes';\nimport { cn } from '@/lib/utils';\nimport {\n  ClipboardText,\n  Check,\n  CaretDown,\n  CaretUp,\n} from '@phosphor-icons/react';\nimport './code-block.css';\nimport { Button } from \"@/components/ui/button\"\nimport { CheckIcon, ClipboardIcon } from \"lucide-react\"\n\n// Define theme mapping\ntype ThemeOption = 'github' | 'vitesse' | 'gruvbox' | 'plastic' | 'default';\n\n// Map theme options to actual Shikiji theme names\nconst themeMapping: Record<\n  ThemeOption,\n  { light: BundledTheme; dark: BundledTheme }\n> = {\n  default: { light: 'github-light', dark: 'github-dark' },\n  github: { light: 'github-light', dark: 'github-dark' },\n  vitesse: { light: 'vitesse-light', dark: 'vitesse-dark' },\n  // Gruvbox isn't in the list, using similar themes\n  gruvbox: { light: 'solarized-light', dark: 'material-theme-darker' },\n  // Plastic isn't in the list, using similar dark themes\n  plastic: { light: 'light-plus', dark: 'material-theme' },\n};\n\n// Get all unique theme names for loading\nconst allThemes = Array.from(\n  new Set(\n    Object.values(themeMapping).flatMap(({ light, dark }) => [light, dark]),\n  ),\n) as BundledTheme[];\n\n// Cache key generator\nconst getCacheKey = (code: string, language: string, theme: BundledTheme) =>\n  `code-block-${encodeURIComponent(code)}-${language}-${theme}`;\n\nexport interface CodeBlockProps {\n  code: string;\n  language?: string;\n  showLineNumbers?: boolean;\n  className?: string;\n  highlightLines?: number[];\n  caption?: string;\n  maxHeight?: string;\n  showCopyButton?: boolean;\n  showExpandButton?: boolean;\n  theme?: ThemeOption;\n  border?: boolean;\n  gradientOverlay?: boolean;\n}\n\nexport default function CodeBlock({\n  code,\n  language = 'typescript',\n  showLineNumbers = false,\n  className,\n  highlightLines = [],\n  caption,\n  maxHeight = '300px',\n  showCopyButton = true,\n  showExpandButton = true,\n  theme = 'default',\n  border = false,\n  gradientOverlay = false,\n}: CodeBlockProps) {\n  const [highlighter, setHighlighter] = useState<Highlighter | null>(null);\n  const [highlightedCode, setHighlightedCode] = useState<string>('');\n  const [copied, setCopied] = useState(false);\n  const [mounted, setMounted] = useState(false);\n  const [expanded, setExpanded] = useState(false);\n  const [contentOverflows, setContentOverflows] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const contentRef = useRef<HTMLDivElement>(null);\n  const [currentTheme, setCurrentTheme] =\n    useState<BundledTheme>('github-light');\n\n  const { resolvedTheme } = useTheme();\n\n  // Initialize the highlighter\n  useEffect(() => {\n    const initHighlighter = async () => {\n      try {\n        setIsLoading(true);\n        const hl = await getHighlighter({\n          themes: allThemes,\n          langs: [language as string],\n        });\n\n        // Load all themes explicitly\n        await Promise.all(allThemes.map((theme) => hl.loadTheme(theme)));\n\n        setHighlighter(hl);\n      } catch (error) {\n        console.error('Failed to initialize highlighter:', error);\n      }\n    };\n\n    initHighlighter();\n  }, [language]);\n\n  // Detect theme changes using multiple methods for better compatibility\n  useEffect(() => {\n    if (!mounted) return;\n\n    // Function to determine current theme\n    const detectTheme = () => {\n      // 1. Check for data-theme attribute on document element (most direct)\n      const dataTheme = document.documentElement.getAttribute('data-theme');\n      // 2. Check for .dark class on document element (common approach)\n      const hasDarkClass = document.documentElement.classList.contains('dark');\n      // 3. Use resolvedTheme as fallback\n      const nextThemesValue = resolvedTheme;\n\n      // Determine if dark mode from all potential sources\n      const isDark =\n        dataTheme === 'dark' || hasDarkClass || nextThemesValue === 'dark';\n\n      const selectedTheme = themeMapping[theme] || themeMapping.default;\n      setCurrentTheme(isDark ? selectedTheme.dark : selectedTheme.light);\n    };\n\n    // Detect theme initially\n    detectTheme();\n\n    // Set up mutation observer to watch for data-theme attribute changes\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (\n          mutation.type === 'attributes' &&\n          (mutation.attributeName === 'data-theme' ||\n            mutation.attributeName === 'class')\n        ) {\n          detectTheme();\n        }\n      });\n    });\n\n    // Start observing the document element for attribute changes\n    observer.observe(document.documentElement, {\n      attributes: true,\n      attributeFilter: ['data-theme', 'class'],\n    });\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [resolvedTheme, mounted, theme]);\n\n  // Handle theme changes and code highlighting with caching\n  useEffect(() => {\n    if (!highlighter || !mounted) return;\n\n    try {\n      setIsLoading(true);\n\n      // Generate cache key\n      const cacheKey = getCacheKey(code, language, currentTheme);\n\n      // Try to get from cache\n      const cachedHtml = localStorage.getItem(cacheKey);\n\n      if (cachedHtml) {\n        setHighlightedCode(cachedHtml);\n        setIsLoading(false);\n        return;\n      }\n\n      // If not in cache, generate and cache it\n      const html = highlighter.codeToHtml(code, {\n        lang: language as string,\n        theme: currentTheme,\n      });\n\n      setHighlightedCode(html);\n      localStorage.setItem(cacheKey, html);\n      setIsLoading(false);\n    } catch (error) {\n      console.error('Error highlighting code:', error);\n      setHighlightedCode(`<pre>${code}</pre>`);\n      setIsLoading(false);\n    }\n  }, [highlighter, code, language, mounted, currentTheme]);\n\n  // Check if content overflows the maxHeight\n  useEffect(() => {\n    if (!contentRef.current || !mounted) return;\n\n    const checkOverflow = () => {\n      const element = contentRef.current;\n      if (!element) return;\n\n      // Convert maxHeight to pixels for comparison\n      let maxHeightPx = 0;\n      if (maxHeight.endsWith('px')) {\n        maxHeightPx = Number.parseInt(maxHeight, 10);\n      } else if (maxHeight.endsWith('rem')) {\n        const remValue = Number.parseInt(maxHeight, 10);\n        const rootFontSize = Number.parseFloat(\n          getComputedStyle(document.documentElement).fontSize,\n        );\n        maxHeightPx = remValue * rootFontSize;\n      } else if (maxHeight.endsWith('em')) {\n        const emValue = Number.parseInt(maxHeight, 10);\n        const parentFontSize = Number.parseFloat(\n          getComputedStyle(element.parentElement || document.body).fontSize,\n        );\n        maxHeightPx = emValue * parentFontSize;\n      } else if (maxHeight.endsWith('vh')) {\n        const vhValue = Number.parseInt(maxHeight, 10);\n        maxHeightPx = (vhValue / 100) * window.innerHeight;\n      } else {\n        // Default fallback\n        maxHeightPx = Number.parseInt(maxHeight, 10) || 300;\n      }\n\n      // Check if content height exceeds maxHeight\n      setContentOverflows(element.scrollHeight > maxHeightPx);\n    };\n\n    // Initial check\n    checkOverflow();\n\n    // Check again when window is resized\n    window.addEventListener('resize', checkOverflow);\n\n    // Check again after a short delay to ensure content is fully rendered\n    const timeoutId = setTimeout(checkOverflow, 100);\n\n    return () => {\n      window.removeEventListener('resize', checkOverflow);\n      clearTimeout(timeoutId);\n    };\n  }, [highlightedCode, maxHeight, mounted]);\n\n  // Handle copy to clipboard\n  const copyToClipboard = () => {\n    navigator.clipboard.writeText(code);\n    setCopied(true);\n    setTimeout(() => setCopied(false), 2000);\n  };\n\n  // Handle client-side rendering\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  // Render a skeleton while loading\n  const renderSkeleton = () => (\n    <div className=\"animate-pulse\">\n      <div className=\"h-6 bg-muted/30 rounded mb-2 w-3/4\"></div>\n      <div className=\"h-6 bg-muted/30 rounded mb-2\"></div>\n      <div className=\"h-6 bg-muted/30 rounded mb-2 w-5/6\"></div>\n      <div className=\"h-6 bg-muted/30 rounded mb-2 w-2/3\"></div>\n      <div className=\"h-6 bg-muted/30 rounded w-4/5\"></div>\n    </div>\n  );\n\n  // Determine what to render based on the current state\n  const renderContent = () => {\n    // If we have highlighted code and we're not loading, show the code\n    if (!isLoading && highlightedCode && mounted) {\n      return (\n        <div\n          dangerouslySetInnerHTML={{ __html: highlightedCode }}\n          className=\"shiki-container\"\n        />\n      );\n    }\n\n    // Otherwise, always show the skeleton (both during SSR and client loading)\n    return renderSkeleton();\n  };\n\n  return (\n    <div\n      className={cn(\n        'relative w-full bg-card text-card-foreground shadow-sm',\n        border && 'border border-border rounded-lg',\n        className,\n      )}\n    >\n      {caption && (\n        <div className=\"text-sm text-muted-foreground mb-2\">{caption}</div>\n      )}\n      <div className=\"relative w-full code-block-container\">\n        {/* Only show copy button when mounted and not loading */}\n        {showCopyButton && mounted && !isLoading && (\n          <div className=\"absolute right-4 top-2 z-10\">\n            <Button\n                   size=\"icon\"\n                   variant=\"ghost\"\n                   className=\"absolute right-2.5 top-2 z-10 size-6 text-zinc-50 hover:bg-zinc-700 hover:text-zinc-50 [&_svg]:size-3\"\n                                 onClick={copyToClipboard}\n\n                 >\n                   <span className=\"sr-only\">Copy</span>\n                   {copied ? <CheckIcon /> : <ClipboardIcon />}\n                 </Button>\n          </div>\n        )}\n        <div\n          ref={contentRef}\n          className={cn(\n            'pt-4 pb-5 px-4 w-full code-content',\n            !expanded\n              ? 'max-h-[var(--code-block-max-height)] overflow-y-auto'\n              : 'max-h-[600px] overflow-y-auto',\n            showLineNumbers && 'relative',\n          )}\n          style={\n            {\n              '--code-block-max-height': gradientOverlay ? '150px' : maxHeight,\n            } as React.CSSProperties\n          }\n        >\n          {renderContent()}\n        </div>\n        {showExpandButton && contentOverflows && mounted && (\n          <>\n            {!expanded && gradientOverlay && (\n              <div className=\"absolute bottom-0 left-0 right-0 h-24 bg-gradient-to-t from-card from-10% to-transparent pointer-events-none\" />\n            )}\n            <div\n              className={cn(\n                'absolute right-4',\n                expanded ? 'bottom-2' : 'bottom-0',\n              )}\n            >\n              <button\n                onClick={() => setExpanded(!expanded)}\n                className={cn(\n                  'p-2 rounded-lg z-10',\n                  'bg-background/80 backdrop-blur-sm',\n                  'text-muted-foreground hover:text-foreground hover:bg-background',\n                  'transition-all duration-200',\n                  'shadow-sm hover:shadow-md',\n                  'border border-border/50',\n                )}\n                aria-label={expanded ? 'Collapse code' : 'Expand code'}\n              >\n                {expanded ? (\n                  <CaretUp size={18} weight=\"bold\" />\n                ) : (\n                  <CaretDown size={18} weight=\"bold\" />\n                )}\n              </button>\n            </div>\n          </>\n        )}\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}