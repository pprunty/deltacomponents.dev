{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "file-input",
  "type": "registry:component",
  "dependencies": [
    "zod",
    "lucide-react"
  ],
  "files": [
    {
      "path": "registry/inputs/file-input.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport {\n  CloudArrowUp,\n  Export,\n  File,\n  FileAudio,\n  FileText,\n  FileVideo,\n  Image,\n  X,\n} from \"@phosphor-icons/react\"\nimport type { z } from \"zod\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\nexport interface FileInputProps {\n  /** The label for the file input field */\n  label: string\n  /** The name of the file input field (used for form submission) */\n  name: string\n  /** Optional description text to display below the label */\n  description?: string\n  /** Optional hint text to display below the file input */\n  hint?: string\n  /** Error message to display (typically from Zod validation) */\n  error?: string\n  /** Whether the field is required */\n  required?: boolean\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean\n  /** Container className for the entire component */\n  containerClassName?: string\n  /** Dropzone className for the file drop area */\n  dropzoneClassName?: string\n  /** Label className for customizing the label */\n  labelClassName?: string\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: \"default\" | \"muted\"\n  /** Input variant - 'default' or 'pill' */\n  variant?: \"default\" | \"pill\"\n  /** Whether to show a colored border (only applies to pill variant) */\n  coloredBorder?: boolean\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<File | File[]>\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, files: File | File[], error?: string) => void\n  /** Callback when files are selected */\n  onFilesSelected?: (files: File[]) => void\n  /** ID for the file input */\n  id?: string\n  /** Whether the file input is disabled */\n  disabled?: boolean\n  /** Whether to accept multiple files */\n  multiple?: boolean\n  /** Accepted file types (e.g., \"image/*\", \".pdf\", etc.) */\n  accept?: string\n  /** Maximum file size in bytes */\n  maxSize?: number\n  /** Maximum number of files (only applies when multiple is true) */\n  maxFiles?: number\n  /** Custom text for the dropzone */\n  dropzoneText?: string\n  /** Whether to show file previews */\n  showPreviews?: boolean\n  /** Whether to show file type icons */\n  showIcons?: boolean\n}\n\n/**\n * FileInput component that integrates with Zod validation\n */\nexport function FileInput({\n  label,\n  name,\n  description,\n  hint,\n  error,\n  required = false,\n  pending = false,\n  containerClassName,\n  dropzoneClassName,\n  labelClassName,\n  labelVariant = \"default\",\n  variant = \"default\",\n  coloredBorder = false,\n  schema,\n  onValidate,\n  onFilesSelected,\n  id = name,\n  disabled = false,\n  multiple = false,\n  accept,\n  maxSize,\n  maxFiles = 5,\n  dropzoneText,\n  showPreviews = true,\n  showIcons = true,\n}: FileInputProps) {\n  const [localError, setLocalError] = React.useState<string | undefined>(error)\n  const [files, setFiles] = React.useState<File[]>([])\n  const [isDragging, setIsDragging] = React.useState(false)\n  const fileInputRef = React.useRef<HTMLInputElement>(null)\n  const hasError = !!localError || !!error\n  const errorId = `error-${id}`\n  const hintId = `hint-${id}`\n\n  // Update local error when prop changes\n  React.useEffect(() => {\n    setLocalError(error)\n  }, [error])\n\n  // Handle validation with the provided schema\n  const validateFiles = React.useCallback(\n    (files: File[]) => {\n      if (!schema) return\n\n      try {\n        const result = schema.safeParse(multiple ? files : files[0])\n        if (!result.success) {\n          const errorMessage =\n            result.error.errors[0]?.message || \"Invalid file(s)\"\n          setLocalError(errorMessage)\n          onValidate?.(false, multiple ? files : files[0], errorMessage)\n        } else {\n          setLocalError(undefined)\n          onValidate?.(true, multiple ? files : files[0])\n        }\n      } catch (err) {\n        setLocalError(\"Validation error\")\n        onValidate?.(false, multiple ? files : files[0], \"Validation error\")\n      }\n    },\n    [schema, onValidate, multiple]\n  )\n\n  // Handle file selection\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (!e.target.files?.length) return\n\n    const selectedFiles = Array.from(e.target.files)\n\n    // Validate file size if maxSize is provided\n    if (maxSize) {\n      const oversizedFiles = selectedFiles.filter((file) => file.size > maxSize)\n      if (oversizedFiles.length > 0) {\n        const fileNames = oversizedFiles.map((f) => f.name).join(\", \")\n        const errorMsg = `File${oversizedFiles.length > 1 ? \"s\" : \"\"} too large: ${fileNames}`\n        setLocalError(errorMsg)\n        return\n      }\n    }\n\n    // Validate number of files if multiple is true\n    if (multiple && maxFiles && selectedFiles.length > maxFiles) {\n      setLocalError(`You can only upload up to ${maxFiles} files`)\n      return\n    }\n\n    // Update files state\n    const newFiles = multiple ? [...files, ...selectedFiles] : selectedFiles\n\n    // Check if we're exceeding maxFiles after combining with existing files\n    if (multiple && maxFiles && newFiles.length > maxFiles) {\n      setLocalError(`You can only upload up to ${maxFiles} files`)\n      return\n    }\n\n    setFiles(newFiles)\n\n    // Validate with schema if provided\n    if (schema) {\n      validateFiles(newFiles)\n    }\n\n    // Call onFilesSelected callback\n    onFilesSelected?.(newFiles)\n\n    // Reset the input value to allow selecting the same file again\n    if (fileInputRef.current) {\n      fileInputRef.current.value = \"\"\n    }\n  }\n\n  // Handle drag events\n  const handleDragEnter = (e: React.DragEvent<HTMLDivElement>) => {\n    e.preventDefault()\n    e.stopPropagation()\n    if (!disabled && !pending) {\n      setIsDragging(true)\n    }\n  }\n\n  const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {\n    e.preventDefault()\n    e.stopPropagation()\n    setIsDragging(false)\n  }\n\n  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {\n    e.preventDefault()\n    e.stopPropagation()\n    if (!disabled && !pending) {\n      e.dataTransfer.dropEffect = \"copy\"\n      setIsDragging(true)\n    }\n  }\n\n  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {\n    e.preventDefault()\n    e.stopPropagation()\n    setIsDragging(false)\n\n    if (disabled || pending) return\n\n    const droppedFiles = Array.from(e.dataTransfer.files)\n\n    // Validate file types if accept is provided\n    if (accept) {\n      const acceptedTypes = accept.split(\",\").map((type) => type.trim())\n      const invalidFiles = droppedFiles.filter((file) => {\n        return !acceptedTypes.some((type) => {\n          if (type.startsWith(\".\")) {\n            // Check file extension\n            return file.name.toLowerCase().endsWith(type.toLowerCase())\n          } else if (type.includes(\"/*\")) {\n            // Check file type category (e.g., \"image/*\")\n            const category = type.split(\"/\")[0]\n            return file.type.startsWith(`${category}/`)\n          } else {\n            // Check exact mime type\n            return file.type === type\n          }\n        })\n      })\n\n      if (invalidFiles.length > 0) {\n        const fileNames = invalidFiles.map((f) => f.name).join(\", \")\n        const errorMsg = `Invalid file type${invalidFiles.length > 1 ? \"s\" : \"\"}: ${fileNames}`\n        setLocalError(errorMsg)\n        return\n      }\n    }\n\n    // Validate file size if maxSize is provided\n    if (maxSize) {\n      const oversizedFiles = droppedFiles.filter((file) => file.size > maxSize)\n      if (oversizedFiles.length > 0) {\n        const fileNames = oversizedFiles.map((f) => f.name).join(\", \")\n        const errorMsg = `File${oversizedFiles.length > 1 ? \"s\" : \"\"} too large: ${fileNames}`\n        setLocalError(errorMsg)\n        return\n      }\n    }\n\n    // Validate number of files if multiple is true\n    const newFiles = multiple ? [...files, ...droppedFiles] : droppedFiles\n\n    if (multiple && maxFiles && newFiles.length > maxFiles) {\n      setLocalError(`You can only upload up to ${maxFiles} files`)\n      return\n    }\n\n    setFiles(newFiles)\n\n    // Validate with schema if provided\n    if (schema) {\n      validateFiles(newFiles)\n    }\n\n    // Call onFilesSelected callback\n    onFilesSelected?.(newFiles)\n  }\n\n  // Handle file removal\n  const removeFile = (index: number) => {\n    const newFiles = [...files]\n    newFiles.splice(index, 1)\n    setFiles(newFiles)\n\n    // Validate with schema if provided\n    if (schema) {\n      validateFiles(newFiles)\n    }\n\n    // Call onFilesSelected callback\n    onFilesSelected?.(newFiles)\n  }\n\n  // Helper function to format accepted file types\n  const formatAcceptedTypes = (accept?: string) => {\n    if (!accept) return \"\"\n\n    const types = accept\n      .split(\",\")\n      .map((type) => type.trim())\n      .map((type) => {\n        // Handle file extensions (e.g., \".pdf\" -> \"PDF\")\n        if (type.startsWith(\".\")) {\n          return type.slice(1).toUpperCase()\n        }\n        // Handle MIME types (e.g., \"image/*\" -> \"IMAGE\")\n        if (type.includes(\"/\")) {\n          const [category] = type.split(\"/\")\n          return category.toUpperCase()\n        }\n        // Return uppercase without dot\n        return type.toUpperCase()\n      })\n\n    // Format with proper grammar\n    if (types.length === 0) return \"\"\n    if (types.length === 1) return types[0]\n    if (types.length === 2) return `${types[0]} and ${types[1]}`\n\n    // For 3 or more items: \"A, B, and C\"\n    const lastType = types.pop()\n    return `${types.join(\", \")}, and ${lastType}`\n  }\n\n  // File type to icon mapping\n  const fileTypeIconMap: Record<string, string> = {\n    // PDF files\n    pdf: \"/vectors/pdf.svg\",\n\n    // Microsoft Office files\n    doc: \"/vectors/word.svg\",\n    docx: \"/vectors/word.svg\",\n    ppt: \"/vectors/ppt.svg\",\n    pptx: \"/vectors/ppt.svg\",\n\n    // Excel files\n    xls: \"/vectors/xlsx.svg\",\n    xlsx: \"/vectors/xlsx.svg\",\n\n    // Audio files\n    mp3: \"/vectors/mp3.svg\",\n\n    // Video files\n    mp4: \"/vectors/mp4.svg\",\n  }\n\n  // Get appropriate icon for file type\n  const getFileIcon = (file: File) => {\n    // For images, continue using the Image icon from phosphor\n    if (file.type.startsWith(\"image/\")) {\n      return <Image weight=\"regular\" className=\"h-6 w-6\" />\n    }\n\n    // Get file extension\n    const extension = file.name.split(\".\").pop()?.toLowerCase()\n\n    // Check if we have a specific icon for this file type\n    if (extension && fileTypeIconMap[extension]) {\n      return (\n        <img\n          src={fileTypeIconMap[extension]}\n          alt={`${extension} file`}\n          className=\"h-10 w-10\"\n        />\n      )\n    }\n\n    // Fallback to generic file icon\n    return <img src=\"/vectors/file.svg\" alt=\"file\" className=\"h-10 w-10\" />\n  }\n\n  // Format file size\n  const formatFileSize = (bytes: number) => {\n    if (bytes === 0) return \"0 Bytes\"\n    const k = 1024\n    const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"]\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\n    return (\n      Number.parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + \" \" + sizes[i]\n    )\n  }\n\n  // Smart filename truncation\n  const truncateFilename = (filename: string, maxLength: number = 30) => {\n    if (filename.length <= maxLength) return filename\n\n    // Split filename into name and extension\n    const lastDotIndex = filename.lastIndexOf(\".\")\n    const name = lastDotIndex > 0 ? filename.slice(0, lastDotIndex) : filename\n    const extension = lastDotIndex > 0 ? filename.slice(lastDotIndex) : \"\"\n\n    // If the name part is too long, truncate it\n    if (name.length > maxLength) {\n      // For UUID-like strings (8-4-4-4-12 format), try to preserve meaningful parts\n      const uuidPattern =\n        /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n      if (uuidPattern.test(name)) {\n        // For UUIDs, show first 8 chars, last 8 chars, and extension\n        return `${name.slice(0, 8)}...${name.slice(-8)}${extension}`\n      }\n\n      // For regular filenames, show start and end\n      const charsToShow = Math.floor((maxLength - 3) / 2)\n      return `${name.slice(0, charsToShow)}...${name.slice(-charsToShow)}${extension}`\n    }\n\n    return filename\n  }\n\n  // Generate image preview URL\n  const getImagePreview = (file: File) => {\n    if (file.type.startsWith(\"image/\")) {\n      return URL.createObjectURL(file)\n    }\n    return null\n  }\n\n  return (\n    <div\n      className={cn(\"group/field grid gap-2\", containerClassName)}\n      data-invalid={hasError}\n    >\n      <label\n        htmlFor={id}\n        className={cn(\n          \"text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive\",\n          labelVariant === \"muted\" && \"text-muted-foreground\",\n          labelClassName\n        )}\n      >\n        {label}\n        {required && <span aria-hidden=\"true\"> *</span>}\n      </label>\n\n      {description && (\n        <p className=\"text-xs text-muted-foreground\">{description}</p>\n      )}\n\n      <div\n        className={cn(\n          \"relative cursor-pointer transition-colors bg-background\",\n          \"flex flex-col items-center justify-center gap-2 text-center p-4 rounded-lg\",\n          // Default variant with single dashed border\n          variant === \"default\" &&\n            \"border border-dashed border-muted-foreground/25\",\n          variant === \"default\" &&\n            \"shadow-[0px_1px_1px_rgba(0,0,0,0.03),_0px_3px_6px_rgba(0,0,0,0.02)]\",\n          // Mobile-specific border dash pattern\n          variant === \"default\" &&\n            \"sm:border-dashed md:border-dashed lg:border-dashed [border-image:url(\\\"data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' fill='none' xmlns='http://www.w3.org/2000/svg%27%3E%3Cpath d='M0 10H20' stroke='%23666' stroke-width='2' stroke-dasharray='8 8'/%3E%3C/svg%3E\\\")_1]\",\n\n          // Pill variant without border\n          variant === \"pill\" && \"bg-muted border border-transparent rounded-lg\",\n          variant === \"pill\" && coloredBorder && \"border-primary/30\",\n\n          // Dragging state\n          isDragging && \"border-primary/50 bg-primary/5\",\n\n          // Error state\n          hasError &&\n            \"border-destructive/50 group-data-[invalid=true]/field:border-destructive\",\n\n          // Disabled state\n          (disabled || pending) && \"opacity-60 cursor-not-allowed\",\n\n          dropzoneClassName\n        )}\n        onDragEnter={handleDragEnter}\n        onDragOver={handleDragOver}\n        onDragLeave={handleDragLeave}\n        onDrop={handleDrop}\n        onClick={() => !disabled && !pending && fileInputRef.current?.click()}\n        aria-invalid={hasError}\n        aria-errormessage={hasError ? errorId : undefined}\n        aria-describedby={hint ? hintId : undefined}\n      >\n        <input\n          ref={fileInputRef}\n          id={id}\n          name={name}\n          type=\"file\"\n          accept={accept}\n          multiple={multiple}\n          disabled={disabled || pending}\n          className=\"sr-only\"\n          onChange={handleFileChange}\n          aria-required={required}\n        />\n\n        <CloudArrowUp\n          weight=\"regular\"\n          className=\"h-7 w-7 text-muted-foreground/70\"\n        />\n\n        <div className=\"space-y-2\">\n          <p className=\"text-md font-medium text-foreground\">\n            {dropzoneText || \"Choose a file or drag and drop it here\"}\n          </p>\n          <p className=\"text-xs text-muted-foreground\">\n            {(() => {\n              const parts = []\n\n              // Add file types if accept is provided\n              if (accept) {\n                const formattedTypes = formatAcceptedTypes(accept)\n                if (formattedTypes) {\n                  parts.push(formattedTypes)\n                }\n              }\n\n              // Add size limit (use default 10MB if not provided)\n              const sizeLimit = maxSize || 10 * 1024 * 1024 // Default 10MB\n              parts.push(`up to ${formatFileSize(sizeLimit)}`)\n\n              return parts.length > 0\n                ? parts.join(\", \")\n                : multiple\n                  ? `Upload up to ${maxFiles} file${maxFiles !== 1 ? \"s\" : \"\"}`\n                  : \"Upload a file\"\n            })()}\n          </p>\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            size=\"sm\"\n            onClick={(e) => {\n              e.stopPropagation()\n              if (!disabled && !pending) {\n                fileInputRef.current?.click()\n              }\n            }}\n            disabled={disabled || pending}\n            className=\"mt-2 cursor-pointer\"\n          >\n            Browse files\n          </Button>\n        </div>\n      </div>\n\n      {/* File previews */}\n      {showPreviews && files.length > 0 && (\n        <div className=\"mt-2 space-y-2\">\n          {files.map((file, index) => {\n            const imagePreview = getImagePreview(file)\n\n            return (\n              <div\n                key={`${file.name}-${index}`}\n                className={cn(\n                  \"flex items-center justify-between p-2\",\n                  variant === \"pill\"\n                    ? \"bg-muted rounded-lg\"\n                    : \"bg-muted/50 border border-border rounded\"\n                )}\n              >\n                <div className=\"flex items-center gap-2 overflow-hidden min-w-0\">\n                  {showIcons && !imagePreview && (\n                    <div className=\"flex-shrink-0 text-muted-foreground\">\n                      {getFileIcon(file)}\n                    </div>\n                  )}\n\n                  {imagePreview && (\n                    <div className=\"h-10 w-10 rounded overflow-hidden flex-shrink-0 bg-background\">\n                      <img\n                        src={imagePreview || \"/placeholder.svg\"}\n                        alt={file.name}\n                        className=\"h-full w-full object-cover\"\n                      />\n                    </div>\n                  )}\n\n                  <div className=\"min-w-0 flex-1\">\n                    <p\n                      className=\"text-md font-medium truncate\"\n                      title={file.name}\n                    >\n                      {truncateFilename(file.name)}\n                    </p>\n                    <p className=\"text-xs text-muted-foreground\">\n                      {formatFileSize(file.size)}\n                    </p>\n                  </div>\n                </div>\n\n                <Button\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"h-8 w-8 rounded-full flex-shrink-0 transition-none hover:bg-transparent\"\n                  onClick={(e) => {\n                    e.stopPropagation()\n                    removeFile(index)\n                  }}\n                  disabled={disabled || pending}\n                  aria-label={`Remove ${file.name}`}\n                >\n                  <X weight=\"regular\" className=\"h-4 w-4\" />\n                </Button>\n              </div>\n            )\n          })}\n        </div>\n      )}\n\n      {hint && !hasError && (\n        <p id={hintId} className=\"text-xs text-muted-foreground mt-1\">\n          {hint}\n        </p>\n      )}\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-xs\">\n          {localError || error}\n        </p>\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:component"
    }
  ]
}