{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tags-input",
  "type": "registry:component",
  "author": "patrick prunty <https://www.patrickprunty.com>",
  "dependencies": ["zod"],
  "files": [
    {
      "path": "registry/inputs/tags-input.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { X } from \"lucide-react\"\nimport type { z } from \"zod\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport type TagTriggerKey = \"Enter\" | \"Space\" | \"Comma\"\n\nexport interface TagsInputProps\n  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, \"onChange\"> {\n  /** The label for the input field */\n  label: string\n  /** The name of the input field (used for form submission) */\n  name: string\n  /** Optional description text to display below the label */\n  description?: string\n  /** Optional hint text to display below the input */\n  hint?: string\n  /** Error message to display (typically from Zod validation) */\n  error?: string\n  /** Whether the field is required */\n  required?: boolean\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean\n  /** Container className for the entire component */\n  containerClassName?: string\n  /** Label className for customizing the label */\n  labelClassName?: string\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: \"default\" | \"muted\"\n  /** Input variant - 'default' or 'pill' */\n  variant?: \"default\" | \"pill\"\n  /** Whether to show a colored border (only applies to pill variant) */\n  coloredBorder?: boolean\n  /** Default value for the tags */\n  defaultValue?: string[]\n  /** Current value for the tags (controlled component) */\n  value?: string[]\n  /** Callback when tags change */\n  onChange?: (tags: string[]) => void\n  /** Key that triggers tag addition - defaults to Enter */\n  triggerKey?: TagTriggerKey\n  /** Maximum number of tags allowed */\n  maxTags?: number\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<string[]>\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, value: string[], error?: string) => void\n}\n\nexport function TagsInput({\n  label,\n  name,\n  description,\n  hint,\n  error,\n  required = false,\n  pending = false,\n  defaultValue,\n  containerClassName,\n  labelClassName,\n  labelVariant = \"default\",\n  variant = \"default\",\n  coloredBorder = false,\n  triggerKey = \"Enter\",\n  maxTags,\n  schema,\n  onValidate,\n  className,\n  id = name,\n  value,\n  onChange,\n  ...props\n}: TagsInputProps) {\n  const [inputValue, setInputValue] = React.useState(\"\")\n  const [localTags, setLocalTags] = React.useState<string[]>(\n    value || defaultValue || []\n  )\n  const [localError, setLocalError] = React.useState<string | undefined>(error)\n  const inputRef = React.useRef<HTMLInputElement>(null)\n\n  const hasError = !!localError || !!error\n  const errorId = `error-${id}`\n  const hintId = `hint-${id}`\n\n  // Controlled vs. uncontrolled\n  const isControlled = value !== undefined\n\n  // Max tags check\n  const isMaxTagsReached = maxTags !== undefined && localTags.length >= maxTags\n\n  // Sync controlled value → localTags\n  React.useEffect(() => {\n    if (isControlled && JSON.stringify(value) !== JSON.stringify(localTags)) {\n      setLocalTags(value || [])\n    }\n  }, [value, isControlled, localTags])\n\n  // Sync error prop → localError\n  React.useEffect(() => {\n    setLocalError(error)\n  }, [error])\n\n  // Zod validation\n  const validateTags = React.useCallback(\n    (tags: string[]) => {\n      if (!schema) return\n      const result = schema.safeParse(tags)\n      if (!result.success) {\n        const msg = result.error.errors[0]?.message || \"Invalid input\"\n        setLocalError(msg)\n        onValidate?.(false, tags, msg)\n      } else {\n        setLocalError(undefined)\n        onValidate?.(true, tags)\n      }\n    },\n    [schema, onValidate]\n  )\n\n  const updateTags = (newTags: string[]) => {\n    if (isControlled) {\n      onChange?.(newTags)\n    } else {\n      setLocalTags(newTags)\n      onChange?.(newTags)\n    }\n    schema && validateTags(newTags)\n  }\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const val = e.target.value\n    if (triggerKey === \"Comma\" && val.endsWith(\",\")) {\n      const tag = val.slice(0, -1).trim()\n      if (tag && !localTags.includes(tag) && !isMaxTagsReached) {\n        updateTags([...localTags, tag])\n      }\n      setInputValue(\"\")\n    } else {\n      setInputValue(val)\n    }\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (\n      (triggerKey === \"Enter\" && e.key === \"Enter\") ||\n      (triggerKey === \"Space\" && e.key === \" \") ||\n      (triggerKey === \"Comma\" && e.key === \",\")\n    ) {\n      e.preventDefault()\n      const tag = inputValue.trim()\n      if (tag && !localTags.includes(tag) && !isMaxTagsReached) {\n        updateTags([...localTags, tag])\n      }\n      setInputValue(\"\")\n    } else if (e.key === \"Backspace\" && !inputValue && localTags.length > 0) {\n      updateTags(localTags.slice(0, -1))\n    }\n  }\n\n  const handleBlur = () => {\n    const tag = inputValue.trim()\n    if (tag && !localTags.includes(tag) && !isMaxTagsReached) {\n      updateTags([...localTags, tag])\n    }\n    setInputValue(\"\")\n    schema && validateTags(localTags)\n  }\n\n  const getTriggerKeyText = () => {\n    switch (triggerKey) {\n      case \"Enter\":\n        return \"Enter\"\n      case \"Space\":\n        return \"Space\"\n      case \"Comma\":\n        return \"comma\"\n      default:\n        return \"Enter\"\n    }\n  }\n\n  const getHintText = () => {\n    if (maxTags !== undefined) {\n      const remaining = maxTags - localTags.length\n      if (remaining <= 0) {\n        return `Maximum ${maxTags} tags reached`\n      }\n      return (\n        hint ||\n        `${remaining} tag${remaining === 1 ? \"\" : \"s\"} remaining (${localTags.length}/${maxTags})`\n      )\n    }\n    return hint\n  }\n\n  return (\n    <div\n      className={cn(\"group/field grid gap-2\", containerClassName)}\n      data-invalid={hasError}\n    >\n      <label\n        htmlFor={id}\n        className={cn(\n          \"text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive\",\n          labelVariant === \"muted\" && \"text-muted-foreground\",\n          labelClassName\n        )}\n      >\n        {label}\n        {required && <span aria-hidden=\"true\"> *</span>}\n      </label>\n\n      {description && (\n        <p className=\"text-xs text-muted-foreground\">{description}</p>\n      )}\n\n      {/* -- Unified styling here: */}\n      <input\n        ref={inputRef}\n        type=\"text\"\n        id={id}\n        name={name}\n        value={inputValue}\n        onChange={handleInputChange}\n        onKeyDown={handleKeyDown}\n        onBlur={handleBlur}\n        disabled={pending || props.disabled || isMaxTagsReached}\n        aria-invalid={hasError}\n        aria-errormessage={hasError ? errorId : undefined}\n        aria-describedby={hint ? hintId : undefined}\n        aria-required={required}\n        autoComplete=\"off\"\n        placeholder={\n          isMaxTagsReached\n            ? `Maximum ${maxTags} tags reached`\n            : props.placeholder ||\n              `Type and press ${getTriggerKeyText()} to add tags`\n        }\n        {...props}\n        className={cn(\n          // Base for both variants\n          \"h-[46px] md:text-md text-md focus-visible:outline-none bg-background placeholder:text-muted-foreground\",\n\n          // Default variant styling\n          variant === \"default\" &&\n            \"border border-input shadow-[0px_2px_2px_rgba(0,0,0,0.03),_0px_4px_7px_rgba(0,0,0,0.02)] \" +\n              \"focus-visible:border-primary focus-visible:ring-2 focus-visible:ring-primary/20 rounded-md px-3\",\n\n          // Pill variant styling (flat, padded, rounded + your ring-offset tweak)\n          variant === \"pill\" &&\n            \"bg-muted border-0 rounded-lg h-12 px-4 \" +\n              \"focus-visible:border-primary focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-background\",\n          variant === \"pill\" && coloredBorder && \"border-2 border-primary\",\n\n          // Error override for both\n          \"group-data-[invalid=true]/field:border-destructive focus-visible:group-data-[invalid=true]/field:ring-destructive\",\n\n          // When max reached\n          isMaxTagsReached && \"opacity-50 cursor-not-allowed\",\n\n          className\n        )}\n      />\n\n      {/* Tags display */}\n      {localTags.length > 0 && (\n        <div className=\"flex flex-wrap gap-2 mt-1\">\n          {localTags.map((tag) => (\n            <div\n              key={tag}\n              className={cn(\n                \"flex items-center gap-1 px-2 py-1 text-sm bg-secondary\",\n                variant === \"pill\" ? \"rounded-lg\" : \"rounded-md\"\n              )}\n            >\n              <span>{tag}</span>\n              <button\n                type=\"button\"\n                onClick={() => {\n                  const filtered = localTags.filter((t) => t !== tag)\n                  updateTags(filtered)\n                }}\n                className=\"text-muted-foreground hover:text-foreground\"\n                disabled={pending || props.disabled}\n                aria-label={`Remove ${tag}`}\n              >\n                <X className=\"h-3 w-3\" />\n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n\n      {getHintText() && !hasError && (\n        <p\n          id={hintId}\n          className={cn(\n            \"text-xs mt-1\",\n            isMaxTagsReached\n              ? \"text-orange-600 dark:text-orange-400\"\n              : \"text-muted-foreground\"\n          )}\n        >\n          {getHintText()}\n        </p>\n      )}\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-xs\">\n          {localError || error}\n        </p>\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "/components/delta/inputs/tags-input.tsx"
    }
  ]
}
