{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tags-input",
  "type": "registry:component",
  "dependencies": [
    "zod"
  ],
  "files": [
    {
      "path": "registry/inputs/tags-input.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { X as PhosphorX } from '@phosphor-icons/react';\nimport { cn } from '@/lib/utils';\nimport type { z } from 'zod';\n\nexport type TagTriggerKey = 'Enter' | 'Space' | 'Comma';\n\nexport interface TagsInputProps\n  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'onChange'> {\n  /** The label for the input field */\n  label: string;\n  /** The name of the input field (used for form submission) */\n  name: string;\n  /** Optional description text to display below the label */\n  description?: string;\n  /** Optional hint text to display below the input */\n  hint?: string;\n  /** Error message to display (typically from Zod validation) */\n  error?: string;\n  /** Whether the field is required */\n  required?: boolean;\n  /** Whether the field is in a loading/pending state */\n  pending?: boolean;\n  /** Container className for the entire component */\n  containerClassName?: string;\n  /** Label className for customizing the label */\n  labelClassName?: string;\n  /** Label variant - 'default' or 'muted' */\n  labelVariant?: 'default' | 'muted';\n  /** Input variant - 'default' or 'pill' */\n  variant?: 'default' | 'pill';\n  /** Whether to show a colored border (only applies to pill variant) */\n  coloredBorder?: boolean;\n  /** Default value for the tags */\n  defaultValue?: string[];\n  /** Current value for the tags (controlled component) */\n  value?: string[];\n  /** Callback when tags change */\n  onChange?: (tags: string[]) => void;\n  /** Key that triggers tag addition - defaults to Enter */\n  triggerKey?: TagTriggerKey;\n  /** Zod schema for validation (optional - can be handled at the form level) */\n  schema?: z.ZodType<string[]>;\n  /** Callback when validation occurs */\n  onValidate?: (isValid: boolean, value: string[], error?: string) => void;\n}\n\nexport function TagsInput({\n  label,\n  name,\n  description,\n  hint,\n  error,\n  required = false,\n  pending = false,\n  defaultValue,\n  containerClassName,\n  labelClassName,\n  labelVariant = 'default',\n  variant = 'default',\n  coloredBorder = false,\n  triggerKey = 'Enter',\n  schema,\n  onValidate,\n  className,\n  id = name,\n  value,\n  onChange,\n  ...props\n}: TagsInputProps) {\n  const [inputValue, setInputValue] = React.useState('');\n  const [localTags, setLocalTags] = React.useState<string[]>(\n    value || defaultValue || [],\n  );\n  const [localError, setLocalError] = React.useState<string | undefined>(error);\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  const hasError = !!localError || !!error;\n  const errorId = `error-${id}`;\n  const hintId = `hint-${id}`;\n\n  // Determine if component is controlled or uncontrolled\n  const isControlled = value !== undefined;\n\n  // Update local tags when value prop changes (for controlled component)\n  React.useEffect(() => {\n    if (isControlled && JSON.stringify(value) !== JSON.stringify(localTags)) {\n      setLocalTags(value || []);\n    }\n  }, [value, isControlled, localTags]);\n\n  // Update local error when prop changes\n  React.useEffect(() => {\n    setLocalError(error);\n  }, [error]);\n\n  // Handle validation with the provided schema\n  const validateTags = React.useCallback(\n    (tags: string[]) => {\n      if (!schema) return;\n\n      const result = schema.safeParse(tags);\n      if (!result.success) {\n        const errorMessage = result.error.errors[0]?.message || 'Invalid input';\n        setLocalError(errorMessage);\n        onValidate?.(false, tags, errorMessage);\n      } else {\n        setLocalError(undefined);\n        onValidate?.(true, tags);\n      }\n    },\n    [schema, onValidate],\n  );\n\n  const updateTags = (newTags: string[]) => {\n    if (isControlled) {\n      // For controlled component, just call onChange\n      onChange?.(newTags);\n    } else {\n      // For uncontrolled, update internal state\n      setLocalTags(newTags);\n      onChange?.(newTags);\n    }\n\n    // Validate if schema is provided\n    if (schema) {\n      validateTags(newTags);\n    }\n  };\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    // Only handle comma as a special case in the onChange handler\n    if (triggerKey === 'Comma' && value.endsWith(',')) {\n      const newTag = value.slice(0, -1).trim();\n      if (newTag && !localTags.includes(newTag)) {\n        const newTags = [...localTags, newTag];\n        updateTags(newTags);\n        setInputValue('');\n      } else {\n        setInputValue('');\n      }\n    } else {\n      setInputValue(value);\n    }\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    // Handle the selected trigger key\n    if (\n      (triggerKey === 'Enter' && e.key === 'Enter') ||\n      (triggerKey === 'Space' && e.key === ' ') ||\n      (triggerKey === 'Comma' && e.key === ',')\n    ) {\n      e.preventDefault();\n      const newTag = inputValue.trim();\n      if (newTag && !localTags.includes(newTag)) {\n        const newTags = [...localTags, newTag];\n        updateTags(newTags);\n      }\n      setInputValue('');\n    } else if (e.key === 'Backspace' && !inputValue && localTags.length > 0) {\n      // Always allow backspace to remove the last tag when input is empty\n      const newTags = localTags.slice(0, -1);\n      updateTags(newTags);\n    }\n  };\n\n  const removeTag = (tagToRemove: string) => {\n    const newTags = localTags.filter((tag) => tag !== tagToRemove);\n    updateTags(newTags);\n  };\n\n  const handleBlur = () => {\n    // Add tag on blur if there's input\n    const newTag = inputValue.trim();\n    if (newTag && !localTags.includes(newTag)) {\n      const newTags = [...localTags, newTag];\n      updateTags(newTags);\n      setInputValue('');\n    }\n\n    // Validate on blur\n    if (schema) {\n      validateTags(localTags);\n    }\n  };\n\n  // Get the trigger key display text for the placeholder\n  const getTriggerKeyText = () => {\n    switch (triggerKey) {\n      case 'Enter':\n        return 'Enter';\n      case 'Space':\n        return 'Space';\n      case 'Comma':\n        return 'comma';\n      default:\n        return 'Enter';\n    }\n  };\n\n  return (\n    <div\n      className={cn('group/field grid gap-2', containerClassName)}\n      data-invalid={hasError}\n    >\n      <label\n        htmlFor={id}\n        className={cn(\n          'text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 group-data-[invalid=true]/field:text-destructive',\n          labelVariant === 'muted' && 'text-muted-foreground',\n          labelClassName,\n        )}\n      >\n        {label}\n        {required && <span aria-hidden=\"true\"> *</span>}\n      </label>\n\n      {description && (\n        <p className=\"text-xs text-muted-foreground\">{description}</p>\n      )}\n\n      {/* Input container - styled like TextInput */}\n      <input\n        ref={inputRef}\n        type=\"text\"\n        id={id}\n        name={name}\n        value={inputValue}\n        onChange={handleInputChange}\n        onKeyDown={handleKeyDown}\n        onBlur={handleBlur}\n        disabled={pending || props.disabled}\n        aria-invalid={hasError}\n        aria-errormessage={hasError ? errorId : undefined}\n        aria-describedby={hint ? hintId : undefined}\n        aria-required={required}\n        className={cn(\n          // Default variant styling\n          'h-[46px] md:text-md text-md focus-visible:outline-none focus-visible:ring-2 bg-background focus-visible:ring-primary dark:ring-offset-black ring-offset-white placeholder:text-muted-foreground',\n          variant === 'default' &&\n            'shadow-[0px_2px_2px_rgba(0,0,0,0.03),_0px_4px_7px_rgba(0,0,0,0.02)] border border-input rounded-md px-3',\n\n          // Pill variant styling\n          variant === 'pill' &&\n            'bg-muted border-0 rounded-lg h-12 px-4 focus:ring-offset-2',\n          variant === 'pill' && coloredBorder && 'border-2 border-primary',\n          variant === 'pill' && 'placeholder:text-muted-foreground',\n\n          // Error styling for both variants\n          'group-data-[invalid=true]/field:border-destructive focus-visible:group-data-[invalid=true]/field:ring-destructive',\n          className,\n        )}\n        placeholder={\n          props.placeholder ||\n          `Type and press ${getTriggerKeyText()} to add tags`\n        }\n        {...props}\n      />\n\n      {/* Tags container - completely separate from input */}\n      {localTags.length > 0 && (\n        <div className=\"flex flex-wrap gap-2 mt-1\">\n          {localTags.map((tag) => (\n            <div\n              key={tag}\n              className={cn(\n                'flex items-center gap-1 px-2 py-1 text-sm bg-secondary',\n                variant === 'pill' ? 'rounded-lg' : 'rounded-md',\n              )}\n            >\n              <span>{tag}</span>\n              <button\n                type=\"button\"\n                onClick={() => removeTag(tag)}\n                className=\"text-muted-foreground hover:text-foreground\"\n                disabled={pending || props.disabled}\n                aria-label={`Remove ${tag}`}\n              >\n                <PhosphorX className=\"h-3 w-3\" weight=\"bold\" />\n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n\n      {hint && !hasError && (\n        <p id={hintId} className=\"text-xs text-muted-foreground mt-1\">\n          {hint}\n        </p>\n      )}\n\n      {hasError && (\n        <p id={errorId} className=\"text-destructive text-xs\">\n          {localError || error}\n        </p>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}