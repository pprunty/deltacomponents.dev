{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "floating-object",
  "type": "registry:component",
  "files": [
    {
      "path": "registry/animations/floating-object.tsx",
      "content": "\"use client\"\n\nimport type { ReactNode } from \"react\"\nimport { useEffect, useState, useRef, useCallback } from \"react\"\nimport { motion } from \"framer-motion\"\n\ninterface FloatingObjectProps {\n  children: ReactNode\n  pattern?: \"float\" | \"circular\" | \"random-directions\"\n  intensity?: \"subtle\" | \"medium\" | \"strong\"\n  speed?: \"slow\" | \"medium\" | \"fast\"\n  direction?: \"clockwise\" | \"counterclockwise\"\n  className?: string\n}\n\ninterface FloatingObjectsProps {\n  children: ReactNode[]\n  containerWidth?: number\n  containerHeight?: number\n  intensity?: \"subtle\" | \"medium\" | \"strong\"\n  speed?: \"slow\" | \"medium\" | \"fast\"\n  collisionEnabled?: boolean\n  className?: string\n}\n\ninterface ObjectState {\n  id: string\n  x: number\n  y: number\n  vx: number\n  vy: number\n  radius: number\n}\n\nexport function FloatingObjects({\n  children,\n  containerWidth = 400,\n  containerHeight = 300,\n  intensity = \"medium\",\n  speed = \"medium\",\n  collisionEnabled = true,\n  className,\n}: FloatingObjectsProps) {\n  const containerRef = useRef<HTMLDivElement>(null)\n  const animationFrameRef = useRef<number>()\n  const [objects, setObjects] = useState<ObjectState[]>([])\n\n  // Define intensity levels\n  const intensityMap = {\n    subtle: { maxSpeed: 0.5, radius: 20 },\n    medium: { maxSpeed: 1, radius: 25 },\n    strong: { maxSpeed: 2, radius: 30 },\n  }\n\n  // Define speed multipliers\n  const speedMap = {\n    slow: 0.5,\n    medium: 1,\n    fast: 1.5,\n  }\n\n  const config = intensityMap[intensity]\n  const speedMultiplier = speedMap[speed]\n\n  // Initialize objects\n  useEffect(() => {\n    const initialObjects: ObjectState[] = children.map((_, index) => {\n      const angle = (index / children.length) * 2 * Math.PI\n      const distance = Math.min(containerWidth, containerHeight) * 0.2\n      \n      return {\n        id: `object-${index}`,\n        x: containerWidth / 2 + Math.cos(angle) * distance,\n        y: containerHeight / 2 + Math.sin(angle) * distance,\n        vx: (Math.random() - 0.5) * config.maxSpeed * speedMultiplier,\n        vy: (Math.random() - 0.5) * config.maxSpeed * speedMultiplier,\n        radius: config.radius,\n      }\n    })\n    setObjects(initialObjects)\n  }, [children.length, containerWidth, containerHeight, config.maxSpeed, config.radius, speedMultiplier])\n\n  // Animation loop\n  const animate = useCallback(() => {\n    setObjects(prev => {\n      const newObjects = prev.map(obj => {\n        let { x, y, vx, vy } = obj\n\n        // Update position\n        x += vx\n        y += vy\n\n        // Bounce off walls\n        if (x <= obj.radius || x >= containerWidth - obj.radius) {\n          vx = -vx * 0.9 // Add some dampening\n          x = Math.max(obj.radius, Math.min(containerWidth - obj.radius, x))\n        }\n        if (y <= obj.radius || y >= containerHeight - obj.radius) {\n          vy = -vy * 0.9\n          y = Math.max(obj.radius, Math.min(containerHeight - obj.radius, y))\n        }\n\n        return { ...obj, x, y, vx, vy }\n      })\n\n      // Handle collisions between objects\n      if (collisionEnabled) {\n        for (let i = 0; i < newObjects.length; i++) {\n          for (let j = i + 1; j < newObjects.length; j++) {\n            const obj1 = newObjects[i]\n            const obj2 = newObjects[j]\n            \n            const dx = obj2.x - obj1.x\n            const dy = obj2.y - obj1.y\n            const distance = Math.sqrt(dx * dx + dy * dy)\n            const minDistance = obj1.radius + obj2.radius\n\n            if (distance < minDistance) {\n              // Collision detected - simple elastic collision\n              const angle = Math.atan2(dy, dx)\n              const sin = Math.sin(angle)\n              const cos = Math.cos(angle)\n\n              // Rotate velocities\n              const vx1 = obj1.vx * cos + obj1.vy * sin\n              const vy1 = obj1.vy * cos - obj1.vx * sin\n              const vx2 = obj2.vx * cos + obj2.vy * sin\n              const vy2 = obj2.vy * cos - obj2.vx * sin\n\n              // Swap velocities (elastic collision)\n              const newVx1 = vx2\n              const newVx2 = vx1\n\n              // Rotate back\n              obj1.vx = newVx1 * cos - vy1 * sin\n              obj1.vy = vy1 * cos + newVx1 * sin\n              obj2.vx = newVx2 * cos - vy2 * sin\n              obj2.vy = vy2 * cos + newVx2 * sin\n\n              // Separate objects to prevent sticking\n              const overlap = minDistance - distance\n              const separationX = (dx / distance) * overlap * 0.5\n              const separationY = (dy / distance) * overlap * 0.5\n              \n              obj1.x -= separationX\n              obj1.y -= separationY\n              obj2.x += separationX\n              obj2.y += separationY\n            }\n          }\n        }\n      }\n\n      return newObjects\n    })\n\n    animationFrameRef.current = requestAnimationFrame(animate)\n  }, [collisionEnabled, containerWidth, containerHeight])\n\n  // Start animation\n  useEffect(() => {\n    if (objects.length > 0) {\n      animationFrameRef.current = requestAnimationFrame(animate)\n    }\n\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current)\n      }\n    }\n  }, [animate, objects.length])\n\n  return (\n    <div\n      ref={containerRef}\n      className={`relative ${className}`}\n      style={{ width: containerWidth, height: containerHeight }}\n    >\n      {objects.map((obj, index) => (\n        <motion.div\n          key={obj.id}\n          className=\"absolute\"\n          style={{\n            x: obj.x - obj.radius,\n            y: obj.y - obj.radius,\n            willChange: 'transform',\n          }}\n          animate={{\n            x: obj.x - obj.radius,\n            y: obj.y - obj.radius,\n          }}\n          transition={{\n            type: \"tween\",\n            duration: 0.1,\n            ease: \"linear\",\n          }}\n        >\n          {children[index]}\n        </motion.div>\n      ))}\n    </div>\n  )\n}\n\nexport function FloatingObject({\n  children,\n  pattern = \"float\",\n  intensity = \"medium\",\n  speed = \"medium\",\n  direction = \"clockwise\",\n  className,\n}: FloatingObjectProps) {\n  const [randomPath, setRandomPath] = useState<Array<{ x: number; y: number }>>(\n    []\n  )\n\n  // Define intensity levels for movement radius\n  const intensityMap = {\n    subtle: { radius: 15, float: { x: 3, y: 2, rotate: 1 } },\n    medium: { radius: 25, float: { x: 6, y: 4, rotate: 2 } },\n    strong: { radius: 40, float: { x: 10, y: 8, rotate: 3 } },\n  }\n\n  // Define speed levels for animation duration\n  const speedMap = {\n    slow: 8,\n    medium: 5,\n    fast: 3,\n  }\n\n  const movement = intensityMap[intensity]\n  const duration = speedMap[speed]\n\n  // Generate random directional path\n  useEffect(() => {\n    if (pattern === \"random-directions\") {\n      const generateRandomPath = () => {\n        const directions = [\n          { x: 0, y: -movement.radius }, // North\n          { x: movement.radius * 0.7, y: -movement.radius * 0.7 }, // Northeast\n          { x: movement.radius, y: 0 }, // East\n          { x: movement.radius * 0.7, y: movement.radius * 0.7 }, // Southeast\n          { x: 0, y: movement.radius }, // South\n          { x: -movement.radius * 0.7, y: movement.radius * 0.7 }, // Southwest\n          { x: -movement.radius, y: 0 }, // West\n          { x: -movement.radius * 0.7, y: -movement.radius * 0.7 }, // Northwest\n        ]\n\n        // Create a path with 6-8 random waypoints\n        const pathLength = 6 + Math.floor(Math.random() * 3)\n        const path = [{ x: 0, y: 0 }] // Start at center\n\n        for (let i = 0; i < pathLength; i++) {\n          const randomDirection =\n            directions[Math.floor(Math.random() * directions.length)]\n          // Add some randomness to the exact position\n          const randomX =\n            randomDirection.x + (Math.random() - 0.5) * movement.radius * 0.3\n          const randomY =\n            randomDirection.y + (Math.random() - 0.5) * movement.radius * 0.3\n          path.push({ x: randomX, y: randomY })\n        }\n\n        path.push({ x: 0, y: 0 }) // Return to center\n        return path\n      }\n\n      setRandomPath(generateRandomPath())\n    }\n  }, [pattern, movement.radius])\n\n  // Circular motion animation\n  if (pattern === \"circular\") {\n    const multiplier = direction === \"clockwise\" ? 1 : -1\n\n    return (\n      <motion.div\n        className={className}\n        animate={{\n          x: [0, movement.radius, 0, -movement.radius, 0],\n          y: [\n            0,\n            movement.radius * multiplier,\n            0,\n            -movement.radius * multiplier,\n            0,\n          ],\n        }}\n        transition={{\n          duration: duration,\n          ease: \"linear\",\n          repeat: Number.POSITIVE_INFINITY,\n          repeatType: \"loop\",\n        }}\n        style={{\n          willChange: \"transform\",\n        }}\n      >\n        {children}\n      </motion.div>\n    )\n  }\n\n  // Random directional movement\n  if (pattern === \"random-directions\" && randomPath.length > 0) {\n    const xPath = randomPath.map((point) => point.x)\n    const yPath = randomPath.map((point) => point.y)\n\n    return (\n      <motion.div\n        className={className}\n        animate={{\n          x: xPath,\n          y: yPath,\n          rotate: [0, 5, -5, 3, -3, 0],\n        }}\n        transition={{\n          duration: duration * 2, // Slower for more deliberate movement\n          ease: \"easeInOut\",\n          repeat: Number.POSITIVE_INFINITY,\n          repeatType: \"loop\",\n        }}\n        style={{\n          willChange: \"transform\",\n        }}\n        onAnimationComplete={() => {\n          // Generate new random path when animation completes\n          setTimeout(() => {\n            const directions = [\n              { x: 0, y: -movement.radius }, // North\n              { x: movement.radius * 0.7, y: -movement.radius * 0.7 }, // Northeast\n              { x: movement.radius, y: 0 }, // East\n              { x: movement.radius * 0.7, y: movement.radius * 0.7 }, // Southeast\n              { x: 0, y: movement.radius }, // South\n              { x: -movement.radius * 0.7, y: movement.radius * 0.7 }, // Southwest\n              { x: -movement.radius, y: 0 }, // West\n              { x: -movement.radius * 0.7, y: -movement.radius * 0.7 }, // Northwest\n            ]\n\n            const pathLength = 6 + Math.floor(Math.random() * 3)\n            const path = [{ x: 0, y: 0 }]\n\n            for (let i = 0; i < pathLength; i++) {\n              const randomDirection =\n                directions[Math.floor(Math.random() * directions.length)]\n              const randomX =\n                randomDirection.x +\n                (Math.random() - 0.5) * movement.radius * 0.3\n              const randomY =\n                randomDirection.y +\n                (Math.random() - 0.5) * movement.radius * 0.3\n              path.push({ x: randomX, y: randomY })\n            }\n\n            path.push({ x: 0, y: 0 })\n            setRandomPath(path)\n          }, Math.random() * 2000) // Random delay before generating new path\n        }}\n      >\n        {children}\n      </motion.div>\n    )\n  }\n\n  // Default floating pattern (original)\n  return (\n    <motion.div\n      className={className}\n      animate={{\n        x: [0, movement.float.x, -movement.float.x, movement.float.x, 0],\n        y: [0, -movement.float.y, movement.float.y, -movement.float.y, 0],\n        rotate: [\n          0,\n          movement.float.rotate,\n          -movement.float.rotate,\n          movement.float.rotate,\n          0,\n        ],\n      }}\n      transition={{\n        duration: duration,\n        ease: \"easeInOut\",\n        repeat: Number.POSITIVE_INFINITY,\n        repeatType: \"loop\",\n      }}\n      style={{\n        willChange: \"transform\",\n      }}\n    >\n      {children}\n    </motion.div>\n  )\n}\n",
      "type": "registry:component"
    }
  ]
}
